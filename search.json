[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Git y GitHub con R",
    "section": "",
    "text": "Empecemos con Git\nEste libro le proporciona instrucciones sobre cómo:\nEl lector objetivo es alguien que usa R para análisis de datos o que trabaja en paquetes de R, aunque parte del contenido puede ser útil para quienes trabajan en áreas adyacentes.\nLas primeras dos partes, Instalación y Conectar Git, GitHub, RStudio, proporciona un inicio rápido para verificar su configuración.\nEn Primeras victorias en GitHub, acumulamos algunos éxitos iniciales con los flujos de trabajo básicos que son necesarios para llevar su trabajo a GitHub. También mostramos la sinergia especial entre R/R Markdown/RStudio y GitHub, lo que proporciona una poderosa demostración de por qué toda esta configuración vale la pena.\nEl uso de Git/GitHub en ciencia de datos tiene una vibra ligeramente diferente a la del desarrollo de software puro, debido a diferencias en el contexto y el objetivo del usuario. Happy Git tiene como objetivo complementar los recursos generales de Git existentes destacando los patrones de uso más gratificantes para la ciencia de datos. Esta perspectiva sobre el panorama de Git se presenta en Conceptos básicos de Git y Flujos de trabajo diarios.",
    "crumbs": [
      "Empecemos con Git"
    ]
  },
  {
    "objectID": "index.html#licencia",
    "href": "index.html#licencia",
    "title": "Git y GitHub con R",
    "section": "Licencia",
    "text": "Licencia\n\nHappy Git and GitHub for the useR de Jennifer Bryan esta licenciado bajo Creative Commons Attribution-NonCommercial 4.0 International License.",
    "crumbs": [
      "Empecemos con Git"
    ]
  },
  {
    "objectID": "index.html#sobre-la-traducción",
    "href": "index.html#sobre-la-traducción",
    "title": "Git y GitHub con R",
    "section": "Sobre la traducción",
    "text": "Sobre la traducción\nEsta traducción de “Git & GitHub con R” es un proyecto personal de David Díaz Rodríguez con el objetivo de facilitar el estudio del control de versiones en proyectos de Ciencia de Datos, tanto al propio traductor como a todas aquellas personas de habla hispana que deseen aprender sobre este tema.\nSeñalar que esta es una traducción textual del libro por lo que cuando se hacen referencias en primera persona se trata de los autores y no el traductor.\nSi detecta algún error relacionado con el contenido de la traducción, siéntase libre de abrir un issue o un pull request en este repositorio.",
    "crumbs": [
      "Empecemos con Git"
    ]
  },
  {
    "objectID": "overview.html",
    "href": "overview.html",
    "title": "1  ¿Por qué Git? ¿Por qué GitHub?",
    "section": "",
    "text": "1.1 ¿Por qué Git?\nGit es siste de control de versión. Su propósito original era ayudar a grupos de desarrolladores a trabajar en colaboración en grandes proyectos de software. Git gestiona la evolución de un conjunto de archivos, llamado repositorio, de una manera sensata y altamente estructurada. Si no tiene idea de lo que estoy hablando, considérelo como las funciones de “Seguimiento de cambios” de Microsoft Word con esteroides.\nGit ha sido reutilizado por la comunidad científica de datos. Además de usarlo para el código fuente, lo usamos para administrar la variada colección de archivos que componen los proyectos típicos de análisis de datos, que a menudo consisten en datos, cifras, informes y, sí, código fuente.\nUn analista de datos en solitario que trabaje en una sola computadora se beneficiará de la adopción del control de versiones. Pero no lo suficiente como para justificar el dolor de la instalación y la agitación del flujo de trabajo. Hay formas mucho más sencillas de obtener copias de seguridad versionadas de sus archivos, si eso es lo único que le preocupa.\nEn mi opinión, para los nuevos usuarios, las ventajas de Git sólo superan las desventajas cuando se tienen en cuenta los gastos generales de comunicación y colaboración con otras personas. ¿Quién de nosotros no necesita hacer eso? Su vida es mucho más fácil si esto está integrado en su flujo de trabajo, en lugar de ser un proceso separado que teme o descuida.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>¿Por qué Git? ¿Por qué GitHub?</span>"
    ]
  },
  {
    "objectID": "overview.html#por-qué-github",
    "href": "overview.html#por-qué-github",
    "title": "1  ¿Por qué Git? ¿Por qué GitHub?",
    "section": "1.2 ¿Por qué GitHub?",
    "text": "1.2 ¿Por qué GitHub?\nAquí es donde los servicios de hosting como GitHub, Bitbucket, y GitLab intervienen. Proporcionan un hogar para sus proyectos basados en Git en Internet. Si no tienes idea de lo que estoy hablando, considéralo DropBox, pero es mucho, mucho mejor. El host remoto actúa como canal de distribución o centro de compensación para su proyecto administrado por Git. Permite que otras personas vean tus cosas, se sincronicen contigo y tal vez incluso realicen cambios. Estos proveedores de alojamiento mejoran los servidores Unix Git tradicionales con interfaces basadas en web bien diseñadas.\nIncluso para proyectos privados en solitario, es una buena idea trasladar su trabajo a una ubicación remota para su tranquilidad. ¿Por qué? Porque es bastante fácil arruinar tu repositorio Git local, especialmente cuando eres nuevo en esto. La buena noticia es que a menudo sólo se daña la infraestructura de Git. ¡Tus archivos están bien! Lo que hace que tu Git se vuelva aún más frustrante. Existen soluciones oficiales de Git para estos problemas, pero pueden requerir experiencia y paciencia a las que no puedes acceder a las 3 a.m. Si recientemente subiste tu trabajo a GitHub, es fácil obtener una copia nueva, arreglar las cosas con los cambios que solo existe localmente y continúa con tu vida.\nEn este libro se expone la integración con GitHub, no con Bitbucket o GitLab, por el bien de especificidad. Sin embargo, todos los principios generales e incluso algunas mecánicas se trasladarán a estas plataformas de alojamiento alternativas.\nNo se deje atrapar demasiado por lo público versus lo privado en este momento. Hay muchas formas de obtener repositorios privados de los principales proveedores a bajo costo o sin costo alguno. ¡Simplemente comience y descubra si Git/GitHub funcionará para usted y cómo! Si supera este acuerdo, puede invertir alguna combinación de conocimiento técnico y dinero en el problema. Puede pagar por un nivel superior de servicio o alojar usted mismo una de estas plataformas.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>¿Por qué Git? ¿Por qué GitHub?</span>"
    ]
  },
  {
    "objectID": "overview.html#va-a-doler",
    "href": "overview.html#va-a-doler",
    "title": "1  ¿Por qué Git? ¿Por qué GitHub?",
    "section": "1.3 ¿Va a doler?",
    "text": "1.3 ¿Va a doler?\nSí.\nDebe instalar Git, hacer que Git local se comunique con GitHub y asegurarse de que RStudio pueda comunicarse con Git local (y, por lo tanto, con GitHub). Este es un dolor que ocurre una sola vez o una vez por computadora.\nPara proyectos nuevos o existentes, usted:\n\nDedícale un directorio (también conocido como “carpeta”).\nConviértalo en un proyecto RStudio.\nConviértalo en un repositorio Git.\nContinúe con sus asuntos habituales. Pero en lugar de solo guardar archivos individuales, periódicamente realiza una confirmación(commit), que toma una instantánea de varios archivos de todo el proyecto.\n\n¿Alguna vez ha versionado un archivo agregando sus iniciales o la fecha? Eso es efectivamente un commit, aunque solo para un único archivo: es una versión que es importante para usted y que quizás desee inspeccionar o volver a consultar más adelante.\n\nEnvíe (push) comits a GitHub periódicamente.\n\nEsto es como compartir un documento con colegas en DropBox o enviarlo como archivo adjunto de correo electrónico. Indica que estás listo para hacer que tu trabajo sea visible para otros e invitar a comentar o editar.\n\n\nEste es un cambio en su flujo de trabajo diario normal. Al principio se siente extraño, pero rápidamente se convierte en algo natural. FWIW, STAT 545 los estudiantes deben enviar todos los trabajos del curso a través de GitHub. Este es un tema importante en las horas de clase y de oficina durante las primeras dos semanas. Luego prácticamente nunca volvemos a hablar de ello.\nMás malas noticias. El dolor de STAT 545 dura poco porque los estudiantes trabajan principalmente en sus propios repositorios. ¿Utilizas GitHub para trabajar con otras personas o para coordinar tu propio trabajo desde varias computadoras? Si es así, después de que te recuperes de la configuración inicial, Git te aplastará nuevamente con conflictos de fusión. Y este no es un dolor que ocurre una sola vez, sino que puede ser un dolor sordo que dure mucho tiempo. El mejor remedio es la prevención, pero también comprender cómo salir de situaciones difíciles y abordarlas en sus propios términos.\nEl resto de este sitio está dedicado a guiarlo a través de la configuración necesaria y a crear sus primeros proyectos Git. Concluimos con indicaciones que lo guiarán a través de algunos de los usos más avanzados que hacen que todo este dolor inicial valga la pena.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>¿Por qué Git? ¿Por qué GitHub?</span>"
    ]
  },
  {
    "objectID": "overview.html#cuál-es-la-recompensa",
    "href": "overview.html#cuál-es-la-recompensa",
    "title": "1  ¿Por qué Git? ¿Por qué GitHub?",
    "section": "1.4 ¿Cuál es la recompensa?",
    "text": "1.4 ¿Cuál es la recompensa?\nExposición: si alguien necesita ver tu trabajo o si quieres que pruebe tu código, puede obtenerlo fácilmente desde GitHub. Si usan Git, pueden clonar o bifurcar su repositorio. Si no usan Git, aún pueden explorar su proyecto en GitHub como un sitio web normal e incluso obtener todo descargando un archivo zip.\n¡Sea más entusiasta! Si le importa mucho el proyecto de otra persona, como un paquete R que usa mucho, puede realizar un seguimiento de su desarrollo en GitHub. Puede ver el repositorio para recibir notificaciones sobre actividades importantes. Puedes bifurcarlo para conservar tu propia copia. Puede modificar su bifurcación para agregar características o corregir errores y enviarlos de regreso al propietario como una propuesta de cambio.\nColaboración: si necesita colaborar en el análisis de datos o el desarrollo de código, todos deberían usar Git. Utilice GitHub como su centro de compensación: las personas trabajan de forma independiente y luego envían el trabajo a GitHub para su conciliación y transmisión al resto del equipo. La ventaja de Git/GitHub se destaca al comparar estas dos formas de colaborar en un documento:\n\nEditar, guardar, adjuntar. En este flujo de trabajo, todos tienen una (¡o más!) copias del documento y circulan como archivo adjunto por correo electrónico. ¿Cuál es “maestro”? ¿Es siquiera posible decirlo? ¿Cómo se relacionan las diferentes versiones entre sí? ¿Cómo deben conciliarse las versiones? Si quieres ver la mejor versión actual, ¿cómo la consigues? Todo esto normalmente se soluciona mediante un contrato social y un proceso bastante manual.\nGoogle Doc. En este flujo de trabajo, solo hay una copia del documento y se encuentra en la nube. Cualquiera puede acceder a la versión más reciente bajo demanda. Cualquiera puede editar, comentar o proponer un cambio y esto estará inmediatamente disponible para todos los demás. Cualquiera puede ver quién ha estado editando el documento y, si ocurre un desastre, puede volver a una versión anterior. Se ha eliminado una gran cantidad de ambigüedades y molestos trabajos de reconciliación.\n\nGestionar un proyecto a través de Git/GitHub se parece mucho más al escenario de Google Doc y disfruta de muchas de las mismas ventajas. Definitivamente es más complicado que colaborar en un documento de Google, pero esto te pone en la mentalidad correcta.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>¿Por qué Git? ¿Por qué GitHub?</span>"
    ]
  },
  {
    "objectID": "overview.html#quién-puede-hacer-qué",
    "href": "overview.html#quién-puede-hacer-qué",
    "title": "1  ¿Por qué Git? ¿Por qué GitHub?",
    "section": "1.5 ¿Quién puede hacer qué?",
    "text": "1.5 ¿Quién puede hacer qué?\nUn repositorio público es legible por todo el mundo. El propietario puede otorgar niveles más altos de permiso a otros, como la capacidad de push commits.\nUn repositorio privado es invisible para el mundo. El propietario puede otorgar acceso de lectura, escritura (push) o administrador a otras personas.\nTambién existe una noción formal de organización, que puede resultar útil para gestionar permisos de repositorio para equipos completos de personas.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>¿Por qué Git? ¿Por qué GitHub?</span>"
    ]
  },
  {
    "objectID": "overview.html#características-especiales-de-github",
    "href": "overview.html#características-especiales-de-github",
    "title": "1  ¿Por qué Git? ¿Por qué GitHub?",
    "section": "1.6 Características especiales de GitHub",
    "text": "1.6 Características especiales de GitHub\nesto quizás sea demasiado detallado… ¿punto final? ¿o pertenece a otra parte?\nAdemás de una interfaz de usuario bien diseñada, GitHub ofrece dos características especialmente importantes:\n\nProblemas(Issues). ¿Recuerda que estamos secuestrando herramientas de desarrollo de software? Bueno, este es el rastreador de errores. Es una lista de cosas… errores, solicitudes de funciones, tareas pendientes, lo que sea.\n\nLos problemas están estrechamente integrados con el correo electrónico y, por lo tanto, le permiten copiar/incrustar conversaciones importantes en el repositorio asociado.\nLos problemas se pueden asignar a personas (por ejemplo, para hacer) y etiquetarlos (“error” o “informe de progreso”).\nLos problemas están estrechamente integrados con las confirmaciones y, por lo tanto, le permiten registrar que los cambios en esta confirmación resuelven el problema que se discutió en esa edición.\nComo nuevo usuario de GitHub, una de las cosas más productivas que puede hacer es utilizar los problemas de GitHub para proporcionar un informe de error claro o una solicitud de función para un paquete que utiliza.\n\nSolicitudes de extracción (Pull request). Git permite que un proyecto tenga múltiples ramas de desarrollo independientes, con la idea de que algunas eventualmente deberían fusionarse nuevamente en la rama de desarrollo principal. Estos son términos técnicos de Git, pero es de esperar que también tengan sentido por sí solos. Una solicitud de extracción es una propuesta formal que dice: “Aquí hay algunos cambios que me gustaría realizar”. Podría estar vinculado a un problema específico: “Relacionado con el n.º 14”. o “Soluciona n.º 56”. GitHub facilita y preserva la discusión de la propuesta, de manera integral y línea por línea.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>¿Por qué Git? ¿Por qué GitHub?</span>"
    ]
  },
  {
    "objectID": "overview.html#qué-tiene-de-especial-usar-r-con-git-y-github",
    "href": "overview.html#qué-tiene-de-especial-usar-r-con-git-y-github",
    "title": "1  ¿Por qué Git? ¿Por qué GitHub?",
    "section": "1.7 ¿Qué tiene de especial usar R con Git y GitHub?",
    "text": "1.7 ¿Qué tiene de especial usar R con Git y GitHub?\n\nLa comunidad activa de desarrollo de paquetes R en GitHub. Lea acerca de las búsquedas y los recursos de GitHub específicos de R aquí.\nLos flujos de trabajo específicos hacen que sea gratificante compartir código fuente, informes renderizados y proyectos completos. Leer más sobre R Markdown, R scripts, y R-heavy projects.\nFunciones relacionadas con Git y GitHub de RStudio IDE. Este aspecto se cubre a lo largo del libro.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>¿Por qué Git? ¿Por qué GitHub?</span>"
    ]
  },
  {
    "objectID": "overview.html#audiencia-y-requisitos-previos",
    "href": "overview.html#audiencia-y-requisitos-previos",
    "title": "1  ¿Por qué Git? ¿Por qué GitHub?",
    "section": "1.8 Audiencia y requisitos previos",
    "text": "1.8 Audiencia y requisitos previos\nEl público objetivo de este sitio es alguien que analiza datos, probablemente con R, aunque parte del contenido puede ser útil para analistas que utilizan otros lenguajes. El desarrollo de paquetes R con Git(Hub) está absolutamente dentro del alcance, pero no es un enfoque o requisito explícito.\nEl sitio está dirigido a usuarios de R de nivel intermedio a avanzado, que se sienten cómodos escribiendo scripts de R y gestionando proyectos de R. Debe tener un buen conocimiento de los archivos y directorios y, en general, tener conocimientos sobre dónde se encuentran las cosas en su computadora.\nAunque mostraremos alternativas para la mayoría de las operaciones de Git, inevitablemente pasaremos algún tiempo en el shell y asumimos cierta experiencia previa. Por ejemplo, debe saber cómo abrir un shell, navegar a un directorio determinado y enumerar los archivos allí. Debería sentirse cómodo usando comandos de shell para ver/mover/renombrar archivos y trabajar con su historial de comandos.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>¿Por qué Git? ¿Por qué GitHub?</span>"
    ]
  },
  {
    "objectID": "overview.html#lo-que-esto-no-es",
    "href": "overview.html#lo-que-esto-no-es",
    "title": "1  ¿Por qué Git? ¿Por qué GitHub?",
    "section": "1.9 Lo que esto NO es",
    "text": "1.9 Lo que esto NO es\nNuestro objetivo es enseñar a los principiantes sobre Git basándose estrictamente en la “necesidad de saberlo”. Git fue creado para gestionar el desarrollo del kernel de Linux, que probablemente sea muy diferente de lo que hace usted. La mayoría de la gente necesita un pequeño subconjunto de la funcionalidad de Git y ese será nuestro enfoque. Si desea una exposición completa de Git como un gráfico acíclico dirigido o un tratado sobre la estrategia de ramificación Git-Flow, no lo encontrará en este libro.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>¿Por qué Git? ¿Por qué GitHub?</span>"
    ]
  },
  {
    "objectID": "contributors.html",
    "href": "contributors.html",
    "title": "2  Colaboradores",
    "section": "",
    "text": "Jenny Bryan (jennybryan.org), Ingeniera de Software en Posit en el equipo tidyverse/r-lib. Autor principal y coordinador de contenidos.\nEl desarrollo y entrega de este material también se ha beneficiado enormemente de las contribuciones de:\n\nDean Attali (deanattali.com), consultor Shiny y alumno ayudante de STAT 545.\nBernhard Konrad, Ingeniero de Software y alumno ayudante de STAT 545.\nShaun Jackman (sjackman.ca), estudiante de Doctorado en Bioinformática de la UBC, mantenedor principal de Linuxbrew, y alumno ayudante de STAT 545.\nJim Hester (jimhester.com), Ingeniero de Software en [Posit]((https://posit.co/) en el equipo tidyverse/r-lib.\nUn número creciente de contribuyentes de GitHub",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Colaboradores</span>"
    ]
  },
  {
    "objectID": "workshops.html",
    "href": "workshops.html",
    "title": "3  Talleres de trabajo",
    "section": "",
    "text": "3.1 Configuración previa al taller\nLectura opcional sobre la motivación general: ¿Por qué Git?\nEs vital que intente configurar su sistema con anticipación. ¡No puedes presentarte al taller sin preparación y seguir al día!\nPrueba esto. En el mejor de los casos, es de aproximadamente 1 a 2 horas. Si choca contra una pared, le ayudaremos:\nSolución de problemas:\nEstas son instrucciones probadas en batalla, por lo que la mayoría tendrá éxito. ¡Creemos en ti! Si tiene problemas, busque ayuda y siga adelante. Dónde obtener ayuda:",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Talleres de trabajo</span>"
    ]
  },
  {
    "objectID": "workshops.html#configuración-previa-al-taller",
    "href": "workshops.html#configuración-previa-al-taller",
    "title": "3  Talleres de trabajo",
    "section": "",
    "text": "Registre una cuenta de GitHub gratuita.\nInstalar o actualizar R y RStudio.\nInstalar Git.\nPreséntate a Git.\nConfigurar un token de acceso personal o configure claves SSH.\nPruebe si Git local puede comunicarse con GitHub.\nPruebe que RStudio puede encontrar Git local y, por lo tanto, puede hablar con GitHub.\n\nPara su información: aquí es donde normalmente comienzan nuestras actividades prácticas. Recorremos juntos una actividad similar, con narrativa, y construimos a partir de ahí.\n\nConsidere si desea instalar un cliente Git opcional, ahora o en el futuro.\n\n\n\nA veces RStudio necesita un poco de ayuda para encontrar Git.\nSolución de problemas generales: RStudio, Git, GitHub Hell.\n\n\n\nSi está inscrito en un próximo taller, encuéntrelo a continuación para obtener detalles sobre el soporte previo al taller.\nPodríamos poder responder a un problema de GitHub aquí.\nSi hay un ángulo claro de R/RStudio, publíquelo en https://forum.posit.co/.\nConsejo general: busque en Google y en https://stackoverflow.com, consulte también https://github.community.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Talleres de trabajo</span>"
    ]
  },
  {
    "objectID": "workshops.html#positconf-2023",
    "href": "workshops.html#positconf-2023",
    "title": "3  Talleres de trabajo",
    "section": "3.2 posit::conf 2023",
    "text": "3.2 posit::conf 2023\nTaller de 1 día: Lo que olvidaron enseñarte sobre R\nTendrá cobertura de medio día de Git/GitHub el 17 de septiembre, posit.co/conference Día del taller, Chicago\nLos participantes registrados en el taller deben utilizar este hilo en forum.posit.co para analizar los problemas de preparación del sistema.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Talleres de trabajo</span>"
    ]
  },
  {
    "objectID": "workshops.html#talleres-anteriores",
    "href": "workshops.html#talleres-anteriores",
    "title": "3  Talleres de trabajo",
    "section": "3.3 Talleres anteriores",
    "text": "3.3 Talleres anteriores\n\nrstudio::conf 2022\nTaller de 2 días: Lo que olvidaron enseñarte sobre R\n\n~25% del contenido era Git/GitHub\n25 y 26 de julio de 2022, Washington, D.C.\nRaukR: Escuela de Verano de R Avanzado para Bioinformática\n\n13 de junio de 2022, en línea\n\nrstudio::conf 2020\n\nTaller de 2 días: Lo que olvidaron enseñarte sobre R\n\n~25% del contenido era Git/GitHub + R/Rmd/RStudio\n\n27 y 28 de enero de 2020, San Francisco, California\n\nUBC Programa de Maestría en Ciencia de Datos\n\nConferencia invitada sobre los flujos de trabajo diarios de Git/GitHub\n9 de enero de 2020\n\nRaukR: Escuela de verano de R avanzado para bioinformática\n\n10-20 de junio de 2019, Visby, Suecia\n\nrstudio::conf 2019\n\nTaller de 2 días: Lo que olvidaron enseñarte sobre R\n\n~25% del contenido era Git/GitHub + R/Rmd/RStudio\n\n15 y 16 de enero de 2019, Austin, TX\n\nSeattle Octubre 2018\n\nTaller de 2 días: Lo que olvidaron enseñarte sobre R\n\n3 de 8 unidades en Git/GitHub + R/Rmd/RStudio\n\n4 y 5 de octubre de 2018, The Westin Seattle\n\nrstudio::conf 2018\n\nTaller de 2 días: Lo que olvidaron enseñarte sobre R\n\n~25% del contenido era Git/GitHub + R/Rmd/RStudio\n\n31 de enero y 1 de febrero de 2018, San Diego, CA\n\nCSAMA 2017: Análisis de datos estadísticos para la biología del genoma\n\nhttp://www.huber.embl.de/csama2017/\n\n11-16 de junio de 2017, Bressanone-Brixen, Italia\n\n\nCiudad del Cabo 2017\n\nhttp://capetown2017.satrdays.org\n\n16 al 18 de febrero de 2017, Ciudad del Cabo, Sudáfrica\n\nrstudio::conf 2017\n\nhttps://posit.co/conference/\n\n13 - 14 de enero de 2017, Orlando, FL\n\nSábado 14 de enero de 10:15 a 12:30\n\nCSAMA 2016: Análisis de datos estadísticos para la biología del genoma\n\nhttp://www.huber.embl.de/csama2016/\n\n10 - 15 de julio de 2016, Bressanone-Brixen, Italia\n\n\nuseR! 2016 Stanford\n\nhttp://user2016.r-project.org\n\nLunes, 27 de junio de 2016\n\nUsing Git and GitHub with R, RStudio, and R Markdown",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Talleres de trabajo</span>"
    ]
  },
  {
    "objectID": "install-intro.html",
    "href": "install-intro.html",
    "title": "La mitad de la batalla",
    "section": "",
    "text": "Éxito y sistemas operativos.\nNuestras instrucciones de instalación han sido forjadas en los fuegos de STAT 545, STAT 540, y talleres variados, durante varios años. Regularmente escuchamos de almas agradecidas en internet que también han tenido éxito.\nAquí hay datos sobre los sistemas operativos que encontramos en STAT 545 y otros talleres: en general, la mayor parte se divide en partes iguales entre Mac y Windows (varios sabores), con una pizca de Linux. Excepto en el contexto de BioConductor (CSAMA), que está dominado por Mac o Linux.\n* Windows 10 es el cajón de sastre de Windows, cuando no tengo información más específica.",
    "crumbs": [
      "Instalación",
      "La mitad de la batalla"
    ]
  },
  {
    "objectID": "install-intro.html#éxito-y-sistemas-operativos.",
    "href": "install-intro.html#éxito-y-sistemas-operativos.",
    "title": "La mitad de la batalla",
    "section": "",
    "text": "2014\n2015\n2016\nuseR! 2016\nCSAMA 2016\nCSAMA 2017\nr::c 2018\nseattle 2018\n\n\n\n\nMac\n16 (41%)\n38 (52%)\n37 (45%)\n28 (44%)\n25 (58%)\n23 (56%)\n51 (57%)\n16 (49%)\n\n\nWindows 10*\n0 (0%)\n8 (11%)\n30 (36%)\n27 (43%)\n6 (14%)\n8 (20%)\n19 (21%)\n12 (36%)\n\n\nWindows 8\n12 (31%)\n9 (12%)\n4 (5%)\n\n\n1 ( 2%)\n2 (2%)\n\n\n\nWindows 7\n9 (23%)\n13 (18%)\n10 (12%)\n\n\n1 ( 2%)\n13 (14%)\n4 (12%)\n\n\nLinux\n2 (5%)\n5 (7%)\n2 (2%)\n8 (13%)\n12 (28%)\n9 (20%)\n5 (6%)\n1 (3%)",
    "crumbs": [
      "Instalación",
      "La mitad de la batalla"
    ]
  },
  {
    "objectID": "install-github-acct.html",
    "href": "install-github-acct.html",
    "title": "4  Crear una cuenta de GitHub",
    "section": "",
    "text": "4.1 Consejos de nombre de usuario\nPodrás actualizar a un nivel de servicio pago, aplicar descuentos, unirte a organizaciones, etc. en el futuro, así que no te preocupes por nada de eso ahora. Excepto tu nombre de usuario. Tal vez quieras pensarlo un poco.\nAlgunos consejos que lamentablemente tienden a contradecirse:\nPuedes cambiar tu nombre de usuario más tarde, pero es mejor hacerlo bien la primera vez.",
    "crumbs": [
      "Instalación",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Crear una cuenta de GitHub</span>"
    ]
  },
  {
    "objectID": "install-github-acct.html#consejos-de-nombre-de-usuario",
    "href": "install-github-acct.html#consejos-de-nombre-de-usuario",
    "title": "4  Crear una cuenta de GitHub",
    "section": "",
    "text": "¡Incorpora tu nombre real! A la gente le gusta saber con quién están tratando. También hace que su nombre de usuario sea más fácil de adivinar o recordar.\nReutiliza tu nombre de usuario de otros contextos, por ejemplo, Twitter o Slack. Pero, por supuesto, alguien sin actividad en GitHub probablemente estará ocupado con eso.\nElija un nombre de usuario que le resulte cómodo revelarle a su futuro jefe.\nMás corto es mejor que más largo.\nSer lo más único posible en la menor cantidad de caracteres posible. En algunas configuraciones, GitHub completa automáticamente o sugiere nombres de usuario.\nHazlo atemporal. No resalte su universidad, empleador o lugar de residencia actual, p.ejemplo JennySeLaCuadra.\nEvite palabras cargadas de significado especial en programación. En mis primeros esfuerzos ineptos para crear scripts en torno a la API de GitHub, le asigné muchos problemas a el tipo con el nombre de usuario NA porque mi vector de nombres de usuarios de GitHub contenía valores faltantes. Una variante de Little Bobby Tables.\nEvite el uso de mayúsculas y minúsculas para separar palabras. Recomendamos encarecidamente todo en minúsculas. GitHub trata los nombres de usuario sin distinguir entre mayúsculas y minúsculas, pero usar todas las minúsculas es más amable con las personas que realizan trabajos de expresión regular posteriores con nombres de usuarios, en varios idiomas. Una mejor estrategia para la separación de palabras es utilizar un guión -.\n\n\n\nhttps://help.github.com/articles/changing-your-github-username/\nhttps://help.github.com/articles/what-happens-when-i-change-my-username/",
    "crumbs": [
      "Instalación",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Crear una cuenta de GitHub</span>"
    ]
  },
  {
    "objectID": "install-github-acct.html#repositorios-privados-gratuitos",
    "href": "install-github-acct.html#repositorios-privados-gratuitos",
    "title": "4  Crear una cuenta de GitHub",
    "section": "4.2 Repositorios privados gratuitos",
    "text": "4.2 Repositorios privados gratuitos\nGitHub ofrece repositorios privados ilimitados y gratuitos para todos los usuarios. Estos repositorios privados gratuitos admiten hasta tres colaboradores externos, lo que los convierte en un lugar perfecto para sus proyectos personales, para solicitudes de empleo y para probar cosas antes de convertir su proyecto en código abierto.\nContinúe y registre su cuenta gratuita AHORA y luego busque cualquier oferta especial que se aplique a usted:\n\nEstudiantes, profesores y personal educativo/investigador: GitHub Education.\n\nGitHub “Organizations” puede ser extremadamente útil para cursos o grupos de investigación/laboratorio, donde se necesita cierta coordinación entre un conjunto de repositorios y usuarios.\n\nOrganizaciones oficiales sin fines de lucro y organizaciones benéficas: GitHub for Good",
    "crumbs": [
      "Instalación",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Crear una cuenta de GitHub</span>"
    ]
  },
  {
    "objectID": "install-github-acct.html#pagar-por-repositorios-privados",
    "href": "install-github-acct.html#pagar-por-repositorios-privados",
    "title": "4  Crear una cuenta de GitHub",
    "section": "4.3 Pagar por repositorios privados",
    "text": "4.3 Pagar por repositorios privados\nCualquiera puede pagar para tener repositorios privados con soporte para colaboradores ilimitados. Un plan personal con repositorios privados que admite colaboradores ilimitados cuesta $ 7 por mes al momento de escribir este artículo e incluye varias [funciones avanzadas] (https://help.github.com/articles/github-s-products/#github-pro ). Vea los planes y precios actuales aquí:\n\nhttps://github.com/pricing\n\nContinúe y registre su cuenta gratuita AHORA. Podrás decidir más adelante si deseas actualizar a un plan pago.",
    "crumbs": [
      "Instalación",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Crear una cuenta de GitHub</span>"
    ]
  },
  {
    "objectID": "install-r-rstudio.html",
    "href": "install-r-rstudio.html",
    "title": "5  Instalar o actualizar R y RStudio",
    "section": "",
    "text": "5.1 Cómo pensar en actualizar R y RStudio\nManténgase actualizado, gente. No querrás adoptar cosas nuevas desde el primer día. Pero en algún momento, ejecutar versiones antiguas de software añade dificultades innecesarias.\nEn los talleres en vivo, hay un límite en cuanto a cuánto podemos ayudar con versiones antiguas de R o RStudio. Además, francamente, nuestra motivación tiene un límite. Por definición, estos problemas van a desaparecer y preferimos centrarnos en los casos extremos con las versiones actuales, que afectan a mucha gente.\n¿Su versión R es “antigua”? R tuvo un cambio de versión importante en abril de 2020, con el lanzamiento de 4.0.0. Es una buena idea estar en la versión principal actual, es decir, algo en este momento, especialmente si desea aprovechar al máximo un taller.\nA cada versión principal le siguen varios años de versiones más pequeñas (versiones menores y de parches). Puede estar más relajado acerca de la actualización de versiones menores, pero aun así desea mantenerse razonablemente actualizado. A medida que se desarrolla la serie 4.algo, te aconsejo que nunca te quedes atrás más de una versión menor.\nEjemplo concreto: digamos que la versión publicada de R es 4.7.1, que es totalmente ficticia y va mucho más allá de la versión actual de R en el momento de escribir este artículo. Probablemente esté bien si todavía estás en 4.6.lo que sea, que es una versión menor detrás y se llama “r-oldrel”. Estar una versión menor por detrás no suele causar problemas. Una vez que tenga 2 versiones menores detrás (4.5.lo que sea o anterior en este ejemplo), comenzará a sufrir. En particular, ya no puede instalar paquetes complementarios binarios prediseñados desde CRAN.\n¿Su RStudio es “viejo”? A menos que tenga una razón específica para preferir la versión publicada, pruebe la Vista previa. La versión preliminar suele ser la misma que la versión general. Pero en la preparación para una nueva versión general, la versión preliminar se utiliza para las versiones candidatas. La versión preliminar incluye funciones nuevas (próximas), pero en general también es muy estable y muy utilizable. Puede esperar actualizar RStudio con mucha más frecuencia que el propio R. Por ejemplo, actualizo RStudio aproximadamente cada mes, mientras que actualizo R 1 o 2 veces al año.",
    "crumbs": [
      "Instalación",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Instalar o actualizar R y RStudio</span>"
    ]
  },
  {
    "objectID": "install-r-rstudio.html#cómo-pensar-en-actualizar-r-y-rstudio",
    "href": "install-r-rstudio.html#cómo-pensar-en-actualizar-r-y-rstudio",
    "title": "5  Instalar o actualizar R y RStudio",
    "section": "",
    "text": "Página principal de descarga de RStudio IDE: https://posit.co/download/rstudio-desktop/#download\n\nPágina de descarga de vista previa de RStudio IDE: https://www.rstudio.com/products/rstudio/download/preview/",
    "crumbs": [
      "Instalación",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Instalar o actualizar R y RStudio</span>"
    ]
  },
  {
    "objectID": "install-git.html",
    "href": "install-git.html",
    "title": "6  Instalar Git",
    "section": "",
    "text": "6.1 ¿Ya tiene Git instalado?\nVaya al shell (Appendix A). Ingrese which git para solicitar la ruta a su ejecutable de Git:\nwhich git\n## /usr/bin/git\ny git --version para ver su versión:\ngit --version\n## git version 2.46.0\nSi tienes éxito, ¡genial! Ya tienes Git. ¡No es necesario instalarlo! Siga adelante.\nSi, en cambio, ves algo más parecido a git: command not found, sigue leyendo.\nLos usuarios de macOS pueden recibir una oferta inmediata para instalar herramientas de desarrollo de línea de comandos. ¡Sí, deberías aceptar! Haga clic en “Instalar” y lea más a continuación.",
    "crumbs": [
      "Instalación",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Instalar Git</span>"
    ]
  },
  {
    "objectID": "install-git.html#sec-install-git-windows",
    "href": "install-git.html#sec-install-git-windows",
    "title": "6  Instalar Git",
    "section": "\n6.2 Windows",
    "text": "6.2 Windows\nOpción 1 (muy recomendable): Instalar Git para Windows, también conocido como msysgit o “Git Bash”, para obtener Git además de otras herramientas útiles, como el shell Bash. Sí, todos esos nombres son totalmente confusos, pero es posible que los encuentres en otros lugares y quiero que estés bien informado.\nNos gusta esto porque Git para Windows deja el ejecutable de Git en una ubicación convencional, lo que le ayudará a usted y a otros programas, por ejemplo. RStudio, encontrarlo y usarlo. Esto también admite una transición a un uso más experto, porque el shell “Git Bash” será útil cuando se aventure fuera de R/RStudio.\n\n\nNOTA: Cuando se le pregunte acerca de “Ajustar su entorno PATH”, asegúrese de seleccionar “Git desde la línea de comandos y también desde software de terceros”. De lo contrario, creemos que es bueno aceptar los valores predeterminados.\nTenga en cuenta que RStudio para Windows prefiere que Git se instale debajo de C:/Program Files y este parece ser el valor predeterminado. Esto implica, por ejemplo, que el ejecutable de Git en mi sistema Windows se encuentra en C:/Program Files/Git/bin/git.exe. A menos que tenga motivos específicos para lo contrario, siga esta convención.\n\nEsto también te deja con un cliente Git, aunque no muy bueno. Así que consulte los clientes de Git que recomendamos (Chapter 8).\nPara su información, esto parece ser equivalente a lo que descargaría desde aquí: https://git-scm.com/download/.\nOpción 2 (recomendado): Instalar Git para Windows a través del administrador de paquetes Chocolatey. Si esto significa algo para ti, Chocolatey es como apt-get o Homebrew, pero para Windows en lugar de Debian/Ubuntu Linux o macOS. Hasta donde puedo decir, usar Chocolatey para instalar Git para Windows da el mismo resultado que instalarlo usted mismo (opción 1).\nObviamente, esto requiere que ya tengas Chocolatey instalado o que estés listo para instalarlo. No es difícil y las instrucciones están aquí. Esto puede valer la pena si parece probable que instale más software de código abierto en el futuro.\nDespués de instalar Chocolatey, en un shell (Appendix A), haga:\nchoco install git.install\nEsto instala el paquete Chocolatey Git (Install) X.Y.Z más actual. Al momento de escribir este artículo, es “Git (Install) 2.33.1”, pero ese número de versión aumentará con el tiempo.\n\n6.2.1 Actualización de Git para Windows\nSi ya tienes Git para Windows, pero no es la última versión, es una buena idea actualizarla. Puedes actualizar así desde la línea de comando:\ngit update-git-for-windows",
    "crumbs": [
      "Instalación",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Instalar Git</span>"
    ]
  },
  {
    "objectID": "install-git.html#macos",
    "href": "install-git.html#macos",
    "title": "6  Instalar Git",
    "section": "\n6.3 macOS",
    "text": "6.3 macOS\nOpción 1 (muy recomendable): Instale las herramientas de línea de comandos de Xcode (no todas las de Xcode), que incluyen Git.\nVaya al shell e ingrese uno de estos comandos para obtener una oferta para instalar herramientas de línea de comandos para desarrolladores:\ngit --version\ngit config\n¡Acepto la oferta! Haga clic en “Instalar”.\nAquí tienes otra forma de solicitar esta instalación, más directamente:\nxcode-select --install\nResulta que encontramos apropiado este activador basado en Git.\nTenga en cuenta también que, después de actualizar macOS, es posible que deba volver a hacer lo anterior y/o volver a aceptar el acuerdo de licencia de Xcode. Hemos visto que esto hace que el panel RStudio Git desaparezca en un sistema donde estaba funcionando anteriormente. Utilice comandos como los anteriores para hacerle cosquillas a Xcode para que le solicite lo que necesita y luego reinicie RStudio.\nOpción 2 (recomendado): Instale Git desde aquí: http://git-scm.com/downloads.\n\nPodría decirse que esto le prepara lo mejor para el futuro. Sin duda, obtendrá la última versión de Git de todos los enfoques descritos aquí.\nEl inicio de GitHub para el instalador de macOS está aquí: https://github.com/timcharper/git_osx_installer.\n\nEn ese enlace, puedes encontrar más información si algo sale mal o si estás trabajando en una versión anterior de macOS.\n\n\n\nOpción 3 (recomendada): si prevé dedicarse mucho a la informática científica, instalará y actualizará una gran cantidad de software. Deberías consultar Homebrew, “el administrador de paquetes que falta para OS X”. Entre muchas otras cosas, puede instalar Git por ti. Una vez que haya instalado Homebrew, haga esto en el shell:\nbrew install git",
    "crumbs": [
      "Instalación",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Instalar Git</span>"
    ]
  },
  {
    "objectID": "install-git.html#linux",
    "href": "install-git.html#linux",
    "title": "6  Instalar Git",
    "section": "\n6.4 Linux",
    "text": "6.4 Linux\nInstale Git a través del administrador de paquetes de su distribución.\nUbuntu o Debian Linux:\nsudo apt-get install git\nFedora o RedHat Linux:\nsudo yum install git\nUna lista completa de varios administradores de paquetes de Linux y Unix:\nhttps://git-scm.com/download/linux",
    "crumbs": [
      "Instalación",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Instalar Git</span>"
    ]
  },
  {
    "objectID": "install-introduce-self-git.html",
    "href": "install-introduce-self-git.html",
    "title": "7  Preséntate a Git",
    "section": "",
    "text": "7.1 Más sobre git config\nUna manera fácil de acceder a un shell desde RStudio es Tools &gt; Terminal or Tools &gt; Shell. Más sobre el shell en el Appendix A.\nProblemas especiales de Windows: si tiene problemas con Windows, considere que existen diferentes tipos de shell y es posible que esté en el equivocado. Desea estar en un shell “Git Bash”, a diferencia de Power Shell o el símbolo del sistema heredado cmd.exe. Lea más en el Apéndice. Esta también podría ser una razón para realizar esta configuración a través del paquete usethis en R.\n¿Qué nombre de usuario deberías darle a Git? No es necesario que sea su nombre de usuario de GitHub, aunque puede serlo. Otra buena opción es su nombre y apellido reales. Si realiza commits desde diferentes máquinas, a veces las personas introducen esa información en el nombre de usuario. Sus commits estarán etiquetadas con este nombre de usuario, así que hágalo informativo para los colaboradores potenciales y para usted en el futuro.\n¿Qué correo electrónico deberías darle a Git? Este debe ser el correo electrónico asociado con su cuenta de GitHub.\nLos primeros dos comandos utilizados en el shell que comienzan con git config --global no devuelve nada en la terminal. Puedes comprobar que Git entendió lo que escribiste mirando el resultado del tercero de git config --global --list.",
    "crumbs": [
      "Instalación",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Preséntate a Git</span>"
    ]
  },
  {
    "objectID": "install-introduce-self-git.html#más-sobre-git-config",
    "href": "install-introduce-self-git.html#más-sobre-git-config",
    "title": "7  Preséntate a Git",
    "section": "",
    "text": "7.1.1 Configurar el editor Git\nOtra opción de Git que mucha gente acaba configurando es el editor. En algún momento, no podrás darle a Git lo que quiere en términos de un mensaje de commit y te enviará a un editor. Esto puede ser angustioso si no es su editor preferido y ni siquiera sabe cómo guardar y salir. Puedes hacer cumplir tu voluntad con algo como esto:\ngit config --global core.editor \"emacs\"\nSustituya aquí su editor preferido por \"emacs\". La lección de Git de Software Carpentry tiene una lista completa del comando exacto git config necesario para muchas combinaciones de sistema operativo y editor.\n\n7.1.2 Configurar el nombre predeterminado para una rama inicial\nEs posible que también desee configurar el nombre predeterminado para la rama inicial en un nuevo repositorio. Históricamente, esto ha sido master, ya que estaba integrado en el propio Git. Es cada vez más común usar main en su lugar, pero debes aceptarlo.\nEn 2020, se introdujo la configuración init.defaultBranch para que el usuario pueda configurarla. Poco después, los principales hosts de Git como GitHub y GitLab hicieron de main el nombre de rama inicial predeterminado para los repositorios creados en sus plataformas y también brindaron un soporte considerable para cambiar el nombre de las ramas predeterminadas existentes.\nPuede configurar su nombre de rama inicial predeterminado en main así, en el shell:\ngit config --global init.defaultBranch main\no desde R (el valor predeterminado para name es \"main\"):\n\nusethis::git_default_branch_configure()",
    "crumbs": [
      "Instalación",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Preséntate a Git</span>"
    ]
  },
  {
    "objectID": "install-git-client.html",
    "href": "install-git-client.html",
    "title": "8  Instalar un cliente Git",
    "section": "",
    "text": "8.1 ¿Qué es un cliente Git? ¿Por qué querrías uno?\n“Git” es en realidad solo una colección de comandos individuales que se ejecutan en el shell (Appendix A). Esta interfaz no es atractiva para todos. Es posible que algunos prefieran realizar operaciones de Git a través de un cliente con una interfaz gráfica.\nGit y su cliente Git no son lo mismo, al igual que R y RStudio no son lo mismo. Un cliente Git y un entorno de desarrollo integrado, como RStudio, no son necesarios para usar Git o R, respectivamente. Pero hacen que la experiencia sea más placentera porque reducen la cantidad de “tonterías en la línea de comandos”1 y brindan una representación visual más rica del estado actual.\nRStudio ofrece un cliente Git muy básico a través de su panel Git. Lo uso a menudo para operaciones simples, pero probablemente también quieras otro más potente.\nAdvertencia justa: para algunas tareas, debes usar la línea de comando. Pero cuanto más poderoso sea su cliente Git, menos frecuente será que esto suceda. La descripción visual proporcionada por su cliente Git también puede ser invaluable para comprender el estado actual de las cosas, incluso al preparar llamadas a la línea de comandos de Git.\nFantásticas noticias: debido a que todos los clientes simplemente están formando y ejecutando comandos de Git en su nombre, no es necesario que elija uno. Literalmente puedes hacer una operación desde la línea de comando, hacer otra desde RStudio y otra desde GitKraken, una tras otra, y simplemente funciona. Muy raramente, ambos clientes escanearán el repositorio al mismo tiempo y recibirás un mensaje de error sobre .git/index.lock. Intente la operación nuevamente al menos una vez antes de seguir solucionando el problema.",
    "crumbs": [
      "Instalación",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Instalar un cliente Git</span>"
    ]
  },
  {
    "objectID": "install-git-client.html#una-imagen-vale-mas-que-mil-palabras",
    "href": "install-git-client.html#una-imagen-vale-mas-que-mil-palabras",
    "title": "8  Instalar un cliente Git",
    "section": "8.2 Una imagen vale mas que mil palabras",
    "text": "8.2 Una imagen vale mas que mil palabras\nAquí hay una captura de pantalla de GitKraken (ver más abajo) abierta en el repositorio del paquete R pkgdown. Obtiene una buena descripción gráfica del historial de commits recientes, ramas y diferencias, así como una GUI que facilita las operaciones de Git más comunes.\n\n\n\n\n\nEn contraste, aquí hay una sesión de shell en la que utilicé la línea de comando Git para acceder a parte de la misma información.\njenny@jennys-MacBook-Pro pkgdown % git log --oneline -n 10\ncd888bed (HEAD -&gt; master, upstream/master, upstream/HEAD, r-lib/master, r-lib/HEAD) Remove accidentally committed snapshot\nca01d386 Add a skip link (#1833)\n1f07a145 Include section class in generated subsection divs\n26e1dcf2 Restore code colouring\n77503979 Working on docs (#1828)\n3c805e1a Make anchor tweaking stricter\na6ae3ca4 use_tidy_description()\nd43260fb Tweak authors order\n41c855df Tweak details styling\n7d3c484c Anchor & news tweaks (#1830)\n¿Cual prefieres?",
    "crumbs": [
      "Instalación",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Instalar un cliente Git</span>"
    ]
  },
  {
    "objectID": "install-git-client.html#nadie-está-entregando-insignias-de-mérito-de-git-nerd",
    "href": "install-git-client.html#nadie-está-entregando-insignias-de-mérito-de-git-nerd",
    "title": "8  Instalar un cliente Git",
    "section": "8.3 Nadie está entregando insignias de mérito de Git Nerd",
    "text": "8.3 Nadie está entregando insignias de mérito de Git Nerd\nTrabaja con Git de la forma que te haga más eficaz. Siéntase libre de revisar su enfoque con el tiempo o de utilizar diferentes enfoques para diferentes tareas o en diferentes entornos. Nadie puede saber si usa la línea de comando o una GUI cuando miran su historial de Git o su repositorio de GitHub.\nA veces me encuentro con personas que sienten que es “mejor” usar la línea de comandos de Git, pero por razones muy mal definidas. Estas personas pueden sentir que deberían trabajar en el shell, incluso si eso les lleva a evitar Git, cometer errores frecuentes o limitarse a un pequeño conjunto de ~3 comandos de Git. Esto es contraproducente.\nTuve dos comienzos en falso con Git, en los que no logré dominar lo suficiente ni lo suficientemente rápido como para incorporar realmente el control de versiones en mi trabajo diario. Encontré un cliente visual de Git invaluable. Me hizo querer usar Git varias veces al día, durante un período de tiempo prolongado. Esto me ayudó a construir el modelo mental necesario para operaciones de Git más avanzadas, como cambiar la base, seleccionar y restablecer.\nSi tu vida con Git ocurre en tu propia computadora, no hay razón para negarte una GUI si eso es lo que te gusta. Si prefiere trabajar en el shell o si inicia sesión con frecuencia en un servidor remoto, entonces tiene sentido priorizar el desarrollo de habilidades de Git en la línea de comandos. Haz lo que funcione para ti, pero no hagas nada por el bien de la pureza o el heroísmo.",
    "crumbs": [
      "Instalación",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Instalar un cliente Git</span>"
    ]
  },
  {
    "objectID": "install-git-client.html#clientes-git-recomendados",
    "href": "install-git-client.html#clientes-git-recomendados",
    "title": "8  Instalar un cliente Git",
    "section": "8.4 Clientes Git recomendados",
    "text": "8.4 Clientes Git recomendados\n\nGitKraken es un potente y gratuito cliente Git(Hub) que es mi favorito actualmente. Es especialmente interesante porque funciona en Windows, macOS y Linux. Esta es una gran noticia, especialmente para los sufridos usuarios de Linux que antes tenían muy pocas opciones. Utilicé la versión gratuita durante años, que funciona muy bien, pero ahora pago felizmente por la versión pro.\nSourceTree es otro cliente gratuito que solía recomendar encarecidamente. Fue mi primer cliente Git querido, pero finalmente tuve que abandonarlo debido a errores/deficiencias de larga data que parecían que nunca se solucionarían (error de macOS con respecto a identificadores de archivos filtrados, sin posibilidad de controlar el tamaño de fuente). GitKraken se siente mucho más desarrollado activamente y para mí ha suplantado por completo a SourceTree.\nGitHub ofrece un cliente Git(Hub) gratuito, GitHub Desktop, para Windows y macOS. Aunque anteriormente desalentamos su uso, desde entonces el cliente de GitHub ha recibido una renovación completa que elimina varias de nuestras preocupaciones, por lo que somos cautelosamente optimistas. GitHub Desktop está dirigido a principiantes que desean las funciones más útiles de Git al frente y al centro. La otra cara es que es posible que no admita algunos de los flujos de trabajo más avanzados expuestos por los clientes anteriores y, en consecuencia, es posible que no desarrolle su modelo mental de Git tan a fondo.\nExplorar aún más clientes Git(Hub).",
    "crumbs": [
      "Instalación",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Instalar un cliente Git</span>"
    ]
  },
  {
    "objectID": "install-git-client.html#footnotes",
    "href": "install-git-client.html#footnotes",
    "title": "8  Instalar un cliente Git",
    "section": "",
    "text": "Esta evocadora frase apareció originalmente en una publicación de blog de Philip Guo, que posteriormente fue eliminada de Internet.↩︎",
    "crumbs": [
      "Instalación",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Instalar un cliente Git</span>"
    ]
  },
  {
    "objectID": "connect-intro.html",
    "href": "connect-intro.html",
    "title": "¿Puedes escucharme ahora?",
    "section": "",
    "text": "Los siguientes capítulos repasan algunas operaciones básicas para confirmar que ha instalado el software necesario y que se están realizando las conexiones necesarias, entre las herramientas de su computadora y entre su computadora y GitHub.\nEsto se superpone mucho con algunos flujos de trabajo básicos que revisaremos más adelante, pero la segunda vez (o en un taller en vivo), dedicaremos más tiempo a explicar qué está sucediendo y por qué.\nDesafortunadamente, tenemos que adelantar una tarea bastante complicada, que es decidir si comunicarnos con GitHub a través de HTTPS o SSH y configurar algunas credenciales en consecuencia. En Token de acceso personal para HTTPS analizamos cómo elegir entre HTTPS y SSH y luego explicamos cómo obtener un token de acceso personal, que se usa con HTTPS. O, alternativamente, te ayudaremos a Configurar claves para SSH.\nUna vez que tenemos nuestras credenciales ordenadas, en Conectar a GitHub, usamos Git en el shell para asegurarnos de que pueda clonar un repositorio desde GitHub y establecer comunicaciones bidireccionales, es decir, extraer y enviar.\nEn Conectar RStudio a Git y GitHub confirmamos que RStudio puede trabajar con su instalación de Git para realizar operaciones locales y comunicarse con GitHub.\nEsperemos que no lo necesites, pero esta parte concluye con dos capítulos de solución de problemas: Detectar Git desde RStudio y RStudio, Git, GitHub Hell.",
    "crumbs": [
      "Conectar Git, GitHub, RStudio",
      "¿Puedes escucharme ahora?"
    ]
  },
  {
    "objectID": "connect-https-pat.html",
    "href": "connect-https-pat.html",
    "title": "9  Token de acceso personal para HTTPS",
    "section": "",
    "text": "9.1 TL;DR\nEsta es una descripción mínima de cómo obtener y almacenar un PAT. Esto podría ser todo lo que necesita cuando se esté configurando por primera vez. Siempre puedes volver más tarde y leer otras partes de este capítulo.\nVaya a https://github.com/settings/tokens y haga clic en “Generar token”.\nO, desde R, ejecute:\nusethis::create_github_token()\nMire los ámbitos; Recomiendo encarecidamente seleccionar “repo”, “user” y “workflow”. Los alcances recomendados serán preseleccionados si utilizó create_github_token().\nHaga click en “Generar token”.\nCCopie el PAT generado a su portapapeles. O deje la ventana del navegador abierta y disponible por un momento, para que pueda volver a copiar el PAT.\nProporcione esta PAT la próxima vez que una operación de Git solicite su contraseña1.\nIncluso podrías adelantarte a esto y almacenar el PAT explícitamente ahora mismo. En R, llame gitcreds::gitcreds_set() para recibir un mensaje donde puedes pegar tu PAT:\n&gt; gitcreds::gitcreds_set()\n\n? Enter password or token: ghp_xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\n-&gt; Adding new credentials...\n-&gt; Removing credentials from cache...\n-&gt; Done.\nDebería poder trabajar con GitHub ahora. Si todavía estás realizando la configuración inicial, ahora es un buen momento para pasar a Conectarse a GitHub.\nContinúe leyendo para obtener más información sobre:",
    "crumbs": [
      "Conectar Git, GitHub, RStudio",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Token de acceso personal para HTTPS</span>"
    ]
  },
  {
    "objectID": "connect-https-pat.html#tldr",
    "href": "connect-https-pat.html#tldr",
    "title": "9  Token de acceso personal para HTTPS",
    "section": "",
    "text": "Cómo decidir entre los protocolos HTTPS y SSH\nAlcances, nombres y caducidad de PAT\nGuarde su PATT\nSolución de problemas",
    "crumbs": [
      "Conectar Git, GitHub, RStudio",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Token de acceso personal para HTTPS</span>"
    ]
  },
  {
    "objectID": "connect-https-pat.html#sec-https-vs-ssh",
    "href": "connect-https-pat.html#sec-https-vs-ssh",
    "title": "9  Token de acceso personal para HTTPS",
    "section": "\n9.2 HTTPS contra SSH",
    "text": "9.2 HTTPS contra SSH\nEncuentro que HTTPS es más fácil de hacer funcionar rápidamente y lo recomiendo encarecidamente cuando comienzas a trabajar con Git/GitHub. HTTPS es lo que recomienda GitHub, presumiblemente exactamente por las mismas razones. El argumento de la “facilidad de uso” a favor de HTTPS es especialmente cierto para los usuarios de Windows. Comencé con HTTPS, preferí SSH por un tiempo y volví a HTTPS. Lo principal que debe saber es que esta no es una decisión de todo o nada y es una decisión relativamente fácil de revisar más adelante.\nOtra ventaja de HTTPS es que el PAT que configuraremos también se puede usar con la API REST de GitHub. Puede que eso no signifique nada para usted (todavía), pero hay muchos paquetes R que llaman a la API de GitHub en su nombre (devtools+usethis, remotes, pak, gh, etc.). Configurar su PAT mata dos pájaros de un tiro: esta credencial única se puede usar para autenticarse en GitHub como un servidor Git normal y para su API REST. Si se autentica a través de SSH para el trabajo “normal” de Git, aún tendrá que configurar un PAT para el trabajo que utiliza la API REST.\n\n\n\n\nUn PAT configurada correctamente significa que todo esto “simplemente funcionará”:\n\nOperaciones HTTPS remotas a través de la línea de comandos de Git y, por tanto, a través de RStudio\nOperaciones HTTPS remotas a través del paquete gert R y, por lo tanto, usethis\nOperaciones de API de GitHub a través del paquete gh R y, por lo tanto, usethis\n\n\n9.2.1 La URL determina el protocolo\nAunque sugiero que adoptes HTTPS como estilo de vida, es bueno saber que en realidad tienes un control muy granular sobre el protocolo. Está determinado por la URL utilizada para acceder a un repositorio remoto. No dudes en saltarte esta sección si eres nuevo en Git (mencionamos algunos conceptos y comandos que no tendrán mucho sentido hasta que hayas usado un poco Git).\nLas URL remotas HTTPS se ven así https://github.com/&lt;OWNER&gt;/&lt;REPO&gt;.git.\nLas URL remotas SSH se ven así git@github.com:&lt;OWNER&gt;/&lt;REPO&gt;.git.\n\n\n\n\n\n\n\n\n\n\n\n\n\nCuando ejecutas un comando como git push origin my-cool-feature-branch, Git busca la URL que has almacenado para el control remoto origin y usa el protocolo implícito en el formato de la URL. El protocolo es una decisión en el momento del juego.\nEsto implica que:\n\nEstá bien usar HTTPS para un control remoto en un repositorio y SSH para otro.\n\nEstá bien usar HTTPS en un repositorio y SSH en otro.\n\nEstá bien interactuar con un repositorio de GitHub mediante HTTPS desde una computadora y mediante SSH desde otra.\n\nEstá bien adoptar HTTPS para trabajos nuevos, incluso si algunos de sus repositorios preexistentes usan SSH.\n\nSólo debes tener en cuenta que el uso mixto de HTTPS y SSH significa que tendrás que configurar ambos tipos de credenciales.\nCambiar un control remoto específico de HTTPS a SSH (y viceversa) es una operación sencilla con git remote set-url REMOTE_NAME DESIRED_URL:\n~/rrr/happy-git-with-r % git remote -v\norigin  https://github.com/jennybc/happy-git-with-r.git (fetch)\norigin  https://github.com/jennybc/happy-git-with-r.git (push)\n\n~/rrr/happy-git-with-r % git remote set-url origin git@github.com:jennybc/happy-git-with-r.git\n\n~/rrr/happy-git-with-r % git remote -v\norigin  git@github.com:jennybc/happy-git-with-r.git (fetch)\norigin  git@github.com:jennybc/happy-git-with-r.git (push)\n\n~/rrr/happy-git-with-r % git remote set-url origin https://github.com/jennybc/happy-git-with-r.git\nPodemos hacer lo mismo desde R usando las funciones de usethis:\n\nusethis::git_remotes()\n#&gt; $origin\n#&gt; [1] \"https://github.com/jennybc/happy-git-with-r.git\"\n\nusethis::use_git_remote(\n  \"origin\",\n  \"git@github.com:jennybc/happy-git-with-r.git\",\n  overwrite = TRUE\n)\n\nusethis::git_remotes()\n#&gt; $origin\n#&gt; [1] \"git@github.com:jennybc/happy-git-with-r.git\"\n\nusethis::use_git_remote(\n  \"origin\",\n  \"https://github.com/jennybc/happy-git-with-r.git\",\n  overwrite = TRUE\n)",
    "crumbs": [
      "Conectar Git, GitHub, RStudio",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Token de acceso personal para HTTPS</span>"
    ]
  },
  {
    "objectID": "connect-https-pat.html#sec-get-a-pat",
    "href": "connect-https-pat.html#sec-get-a-pat",
    "title": "9  Token de acceso personal para HTTPS",
    "section": "\n9.3 Generar un token de acceso personal (PAT)",
    "text": "9.3 Generar un token de acceso personal (PAT)\nEn github.com, suponiendo que haya iniciado sesión, puede administrar sus tokens de acceso personales desde https://github.com/settings/tokens, también accesible a través de Configuración &gt; Configuración de desarrollador &gt; Tokens de acceso personal. Puedes hacer clic en “Generar nuevo token” aquí o, quizás incluso mejor, puedes ejecutar en R el siguiente código usethis::create_github_token():\n\nusethis::create_github_token()\n\nEl usethis enfoque lo lleva a un formulario precargado donde hemos preseleccionado algunos alcances recomendados, que puede revisar y ajustar antes de hacer clic en “Generar token”. Al momento de escribir este artículo, los alcances recomendados por este uso son “repo”, “user”, “gist” y “workflow”.\n\n\n\n\nEs una muy buena idea describir el propósito del token en el campo Note, porque algún día podría tener varios PAT. Recomendamos nombrar cada token según su caso de uso, como la computadora o el proyecto para el que lo está usando, por ejemplo. “personal-macbook-air” o “vm-for-project-xyz”. En el futuro, te encontrarás mirando esta lista de tokens, porque inevitablemente necesitarás volver a generar o eliminar uno de ellos. Haz que sea fácil descubrir con qué token has venido a jugar.\nGitHub fomenta el uso de tokens perecederos, con un período de Caducidad predeterminado de 30 días. A menos que tenga una razón específica para luchar contra esto, le recomiendo aceptar este valor predeterminado. Supongo que la gente de seguridad de GitHub tiene buenas razones para su recomendación. Pero, por supuesto, puede ajustar el comportamiento de Vencimiento como mejor le parezca, incluido “Sin vencimiento”.\nUna vez que esté satisfecho con la Note, Expiration y Scope del token, haga clic en “Generar token”.\nNo podrá volver a ver este token, así que no cierre ni salga de esta ventana del navegador hasta que almacene el PAT localmente. Copie el PAT al portapapeles, anticipando lo que haremos a continuación: activar un mensaje que nos permita almacenar el PAT en el almacén de credenciales de Git.\n¡Trate este PAT como una contraseña! ¡Nunca conectes tu PAT a tu código! Una PAT siempre debe recuperarse implícitamente, por ejemplo, del almacén de credenciales de Git. Estamos a punto de ayudarle a almacenar el PAT en un lugar seguro, donde los paquetes de línea de comandos Git, RStudio y R puedan descubrirlo.\nSi usa una aplicación de administración de contraseñas, como 1Password o LastPass (¡muy recomendable!), es posible que desee agregar también esta PAT (y su Nota) a la entrada de GitHub, donde ya está almacenando su nombre de usuario y contraseña. . Almacenar su PAT en el almacén de credenciales de Git es una conveniencia semipersistente, algo así como un caché del navegador o “recordarme” en un sitio web2 y es posible que necesite volver a ingresar su PAT en el futuro. Podrías decidir aceptar la impermanencia de tu PAT y, si de alguna manera se pierde, simplemente regenerarás el PAT y lo restaurarás. Si acepta el período de vencimiento predeterminado de 30 días, este es un flujo de trabajo que utilizará con frecuencia de todos modos. Pero si crea tokens duraderos o quiere jugar con las funciones para configurar o borrar sus credenciales de Git, puede resultar útil tener su propio registro de su PAT en un lugar seguro, como 1Password o LastPass.",
    "crumbs": [
      "Conectar Git, GitHub, RStudio",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Token de acceso personal para HTTPS</span>"
    ]
  },
  {
    "objectID": "connect-https-pat.html#sec-store-pat",
    "href": "connect-https-pat.html#sec-store-pat",
    "title": "9  Token de acceso personal para HTTPS",
    "section": "\n9.4 Guarde su PAT",
    "text": "9.4 Guarde su PAT\nEn este punto, asumo que generó una PAT y la tiene disponible, en una o ambas de estas maneras:\n\nEn un sistema seguro y a largo plazo para almacenar secretos, como 1Password o LastPass\nDurante los próximos minutos, en una ventana del navegador o en el portapapeles\n\nHay un par de formas de ingresar su PAT en la tienda de credenciales de Git:\n\nLlame a una función de R para almacenar (o actualizar) explícitamente sus credenciales.\nHaga algo en la línea de comando de Git o RStudio que desencadene un desafío de credenciales.\n\n\n9.4.1 Llame a una función R para almacenar sus credenciales\nHay dos paquetes de R para acceder al almacén de credenciales de Git:\n\ngitcreds\ncredentials\n\nEs probable que estos paquetes eventualmente se combinen en uno solo e, incluso ahora, son en gran medida interoperables. No es necesario que sigas las instrucciones de ambos paquetes: ¡elige uno!\n\n9.4.1.1 Paquete gitcreds\nSi no tiene gitcreds instalado, instálelo a través de install.packages(\"gitcreds\"). Si ha instalado usethis, ya tendrá gitcreds, porque usethis usa gh y gh usa gitcreds.\nLlame a gitcreds::gitcreds_set(). Si aún no tiene una PAT almacenada, se le pedirá que la ingrese. ¡Pegar!\n\n&gt; gitcreds::gitcreds_set()\n\n? Enter password or token: ghp_xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\n-&gt; Adding new credentials...\n-&gt; Removing credentials from cache...\n-&gt; Done.\n\nSi ya tiene una credencial almacenada, gitcreds::gitcreds_set() la revela e incluso le permitirá inspeccionarla. Esto le ayuda a decidir si desea conservar la credencial existente o reemplazarla. En caso de duda, opte por una credencial nueva y de buena reputación en lugar de una antigua de origen dudoso.\n\n&gt; gitcreds::gitcreds_set()\n\n-&gt; Your current credentials for 'https://github.com':\n\n  protocol: https\n  host    : github.com\n  username: PersonalAccessToken\n  password: &lt;-- hidden --&gt;\n\n-&gt; What would you like to do? \n\n1: Keep these credentials\n2: Replace these credentials\n3: See the password / token\n\nSelection: 2\n\n-&gt; Removing current credentials...\n\n? Enter new password or token: ghp_xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\n-&gt; Adding new credentials...\n-&gt; Removing credentials from cache...\n-&gt; Done.\n\nPuede comprobar que ha almacenado una credencial con gitcreds_get():\n\ngitcreds_get()\n#&gt; &lt;gitcreds&gt;\n#&gt;   protocol: https\n#&gt;   host    : github.com\n#&gt;   username: PersonalAccessToken\n#&gt;   password: &lt;-- hidden --&gt;\n\nOtras funciones que pueden ayudarle a sentirse seguro acerca de su configuración PAT incluyen:\n\nusethis::gh_token_help()\n\nusethis::git_sitrep()\n\ngh::gh_whoami()\n\n\n9.4.1.2 Paquete credentials\nSi no tiene las credenciales instaladas, instálelas a través de install.packages(\"credentials\"). Si ha instalado usethis, ya tendrá credenciales, porque usethis usa gert y gert usa credenciales.\nLlame a set_github_pat(). Si aún no tiene una PAT almacenada, se le pedirá que la ingrese. ¡Pegar!\n\ncredentials::set_github_pat()\n\nSi tiene éxito, sus llamadas iniciales (y posteriores) se verán así:\n\ncredentials::set_github_pat()\n#&gt; If prompted for GitHub credentials, enter your PAT in the password field\n#&gt; Using GITHUB_PAT from Jennifer (Jenny) Bryan (credential helper: osxkeychain)\n\nOtras funciones que pueden ayudarle a sentirse seguro acerca de su configuración PAT incluyen:\n\nusethis::gh_token_help()\n\nusethis::git_sitrep()\n\ngh::gh_whoami()\n\n\n9.4.2 Almacene credenciales mediante el uso orgánico de Git\nAntes de que existieran gitcreds y credenciales (ver arriba), teníamos que orquestar un desafío de credenciales configurando (y luego derribando) un repositorio de juguetes. Esto todavía ocurre naturalmente en el ejercicio guiado en Conectarse a GitHub. Pero recomiendo encarecidamente administrar su PAT de manera más directa y explícita con gitcreds::gitcreds_set() y funciones relacionadas en gitcreds.",
    "crumbs": [
      "Conectar Git, GitHub, RStudio",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Token de acceso personal para HTTPS</span>"
    ]
  },
  {
    "objectID": "connect-https-pat.html#sec-pat-troubleshooting",
    "href": "connect-https-pat.html#sec-pat-troubleshooting",
    "title": "9  Token de acceso personal para HTTPS",
    "section": "\n9.5 Problemas y soluciones de HTTPS PAT",
    "text": "9.5 Problemas y soluciones de HTTPS PAT\nEsta sección es para personas que necesitan saber aún más sobre la administración de PAT porque se encuentran en una situación no estándar o sobre la resolución de problemas.\n\n9.5.1 Se almacena el PAT válido, pero luego se le dice que el PAT no es válido\nSupongamos que genera un PAT nuevo y lo almacena correctamente como se describe anteriormente. Quizás incluso lo uses con éxito. ¡Pero luego te dicen que tu PAT no es válido! ¿Cómo puede ser esto?\nAquí hay algunas explicaciones probables:\n\nSu PAT realmente no es válido. De forma predeterminada, los PAT ahora tienen una fecha de vencimiento. Un día realmente te despertarás y descubrirás que el PAT se ha estropeado durante la noche y necesitas volver a generarlo y almacenarlo.\nTienes un PAT no válido almacenado en otro lugar, que has olvidado, probablemente en .Renviron. Esta PAT antiguo e inválido impide que los paquetes R incluso descubran su PAT nuevo y válido.\n\n\n9.5.1.1 PAT ha expirado\nVas a regenerar y restaurar tu PAT según un cronograma dictado por su período de vencimiento. Por defecto, una vez al mes.\nCuando el PAT caduque, regrese a https://github.com/settings/tokens y haga clic en su Nota. (Etiquetas muy bien tus tokens por caso de uso, ¿verdad? ¿Verdad?) En este punto, opcionalmente puedes ajustar los alcances y luego hacer clic en “Regenerar token”. Opcionalmente, puedes modificar su Caducidad y luego hacer clic en “Regenerar token” (nuevamente). Como antes, copie el PAT al portapapeles, llame a gitcreds::gitcreds_set() y péguelo.\nCon suerte, cada vez está más claro por qué la Nota de cada token es tan importante. El token real puede cambiar, por ejemplo, una vez al mes, pero su caso de uso (y alcances) son mucho más persistentes y estables.\n\n9.5.1.2 GITHUB_PAT antiguo en .Renviron\n\nEstas funciones de usethis diagnosticarán este problema:\n\nusethis::gh_token_help()\n\nusethis::git_sitrep()\n\nEn el pasado, era común almacenar un PAT como la variable de entorno GITHUB_PAT en .Renviron. Pero ahora, gracias a gitcreds y credenciales, podemos almacenar y recuperar un PAT, desde R, de la misma manera que lo hace la línea de comandos Git.\nSi tiene alguna duda sobre sus prácticas anteriores, abra .Renviron, busque una línea que configure la variable de entorno GITHUB_PAT y elimínela. usethis::edit_r_environ() puede ser útil para abrir .Renviron para editarlo. No olvide reiniciar R para que este cambio surta efecto.\n\n9.5.2 PAT no persiste en macOS o Windows\nLos asistentes de credenciales utilizados por Git aprovechan los almacenes de credenciales oficiales proporcionados por el sistema operativo, siempre que sea posible, como macOS Keychain y Windows Credential Manager.\nSi está intentando seguir los consejos aquí y su PAT nunca persiste, considere que es posible que necesite actualizar Git para obtener sus asistentes de credenciales más modernos. Esta es absolutamente un área de Git que ha mejorado rápidamente en los últimos años y el paquete gitcreds y credentials funcionan mejor con las versiones recientes de Git. No he necesitado activar explícitamente un asistente de credenciales en macOS o Windows con ninguna versión reciente de Git.\nAquí hay un comando para revelar el asistente de credenciales actual y lo que veo estos días.\nmacOS\n$ git config --show-origin --get credential.helper\nfile:/Users/jenny/.gitconfig    osxkeychain\nWindows\n$ git config --show-origin --get credential.helper\nfile:C:/Program Files/Git/mingw64/etc/gitconfig manager\nSi desea saber más sobre cómo gitcreds y credenciales administran su PAT, obtenga información sobre git credential &lt;fill|approve|reject&gt;. Para los entusiastas, esa documentación les brinda detalles sobre cómo se almacenan y recuperan las credenciales:\n\nGit tiene una interfaz interna para almacenar y recuperar credenciales de ayudantes específicos del sistema, además de solicitar al usuario nombres de usuario y contraseñas. El comando git-credential expone esta interfaz a scripts que pueden querer recuperar, almacenar o solicitar credenciales de la misma manera que Git.\n\nEn Windows, sus credenciales de Git probablemente se almacenen a través del Administrador de credenciales.\nEn macOS, sus credenciales de Git probablemente estén almacenadas en el Keychain.\nSi realmente desea husmear directamente para explorar o limpiar sus credenciales de GitHub, inicie Credential Manager (Windows) o Keychain Access (macOS) y busque “github.com”.\n\n9.5.3 PAT no persiste en Linux\nLos asistentes de credenciales utilizados por Git aprovechan los almacenes de credenciales oficiales proporcionados por el sistema operativo en macOS y Windows, pero lamentablemente no existe un equivalente exacto en Linux.\nLo más fácil es configurar Git para “almacenar en caché” sus credenciales (frente a “almacenar”), que tiene un tiempo más limitado. Luego establezca el tiempo de espera de la caché en un período de tiempo suficientemente largo. Aquí fijamos el tiempo de espera en diez millones de segundos o alrededor de 16 semanas, suficiente para un semestre.\ngit config --global credential.helper 'cache --timeout=10000000'\nEs posible que esto aún no haga que su PAT esté disponible para los paquetes R. En este caso, es posible que necesite utilizar el método más antiguo y menos seguro de almacenar su PAT en .Renviron. usethis::edit_r_environ() abre ese archivo para editarlo.\n\nusethis::edit_r_environ()\n\nAgrega una línea como esta, pero sustituye tu PAT:\n\nGITHUB_PAT=ghp_xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\n\n¡Asegúrese de que este archivo termine en una nueva línea! La falta de una nueva línea puede provocar una falla silenciosa al cargar los archivos de inicio, lo que puede ser complicado de depurar. Tenga cuidado de que este archivo no se envíe accidentalmente a la nube, p. Google Drive o GitHub.\nReinicie R para que los cambios en .Renviron surtan efecto.",
    "crumbs": [
      "Conectar Git, GitHub, RStudio",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Token de acceso personal para HTTPS</span>"
    ]
  },
  {
    "objectID": "connect-https-pat.html#footnotes",
    "href": "connect-https-pat.html#footnotes",
    "title": "9  Token de acceso personal para HTTPS",
    "section": "",
    "text": "Sí, es confuso que se le solicite una contraseña, pero debe ingresar su PAT. GitHub ya no permite contraseñas en este contexto, pero la mayoría de las herramientas básicas de Git aún enmarcan la tarea de autenticación con este lenguaje.↩︎\n¡Ja ja! Todos sabemos lo bien que funciona “recuérdame”.↩︎",
    "crumbs": [
      "Conectar Git, GitHub, RStudio",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Token de acceso personal para HTTPS</span>"
    ]
  },
  {
    "objectID": "connect-ssh-keys.html",
    "href": "connect-ssh-keys.html",
    "title": "10  Configurar claves para SSH",
    "section": "",
    "text": "10.1 Claves SSH\nLas claves SSH proporcionan una forma más segura de iniciar sesión en un servidor que usar únicamente una contraseña. Si bien una contraseña puede eventualmente descifrarse con un ataque de fuerza bruta, las claves SSH son casi imposibles de descifrar solo con fuerza bruta. La generación de un par de claves le proporciona dos largas cadenas de caracteres: una clave pública y una privada. Puede colocar la clave pública en cualquier servidor (¡como GitHub!) y luego desbloquearla conectándose con un cliente que ya tenga la clave privada (¡su computadora!). Cuando los dos coinciden, el sistema se desbloquea sin necesidad de contraseña. Puede aumentar aún más la seguridad protegiendo la clave privada con una frase de contraseña.\nAdaptado de las instrucciones proporcionadas por GitHub y Digital Ocean.",
    "crumbs": [
      "Conectar Git, GitHub, RStudio",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Configurar claves para SSH</span>"
    ]
  },
  {
    "objectID": "connect-ssh-keys.html#ssh-esquema-y-consejo",
    "href": "connect-ssh-keys.html#ssh-esquema-y-consejo",
    "title": "10  Configurar claves para SSH",
    "section": "\n10.2 SSH esquema y consejo",
    "text": "10.2 SSH esquema y consejo\nDescripción general de alto nivel de lo que debe suceder:\n\nCree un par de claves SSH pública-privada. Literalmente, 2 archivos especiales, en un lugar especial. Opcionalmente, cifre la clave privada con una frase de contraseña (práctica recomendada).\nAgregue la clave privada a su agente ssh. Si lo protegiste con una frase de contraseña, es posible que tengas una configuración adicional.\nAgrega tu clave pública a tu perfil de GitHub.\n\nConsejo:\n\nSi es nuevo en la programación y el shell, probablemente le resulte más fácil HTTPS al principio (Chapter 9). Siempre puedes cambiar a SSH más tarde. Puede utilizar un método desde la computadora A y el otro desde la computadora B.\nDebes cambiar tus claves SSH periódicamente. Algo así como una vez al año.\nEs una buena práctica proteger su clave privada con una frase de contraseña. Esto puede dificultar la configuración y el uso, por lo que si no estás preparado para ello (todavía), no uses una frase de contraseña o considera seriamente usar HTTPS en su lugar.\nNo hagas ejercicios extraños para tener un solo par de claves, reutilizadas en varias computadoras. Probablemente deberías tener una clave por computadora (yo hago esto). Algunas personas incluso tienen una clave por computadora, por servicio (yo no hago esto).\nEs normal asociar varias claves públicas con tu cuenta de GitHub. Por ejemplo, una clave pública para cada computadora a la que se conecte.",
    "crumbs": [
      "Conectar Git, GitHub, RStudio",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Configurar claves para SSH</span>"
    ]
  },
  {
    "objectID": "connect-ssh-keys.html#ya-tienes-claves",
    "href": "connect-ssh-keys.html#ya-tienes-claves",
    "title": "10  Configurar claves para SSH",
    "section": "\n10.3 ¿Ya tienes claves?",
    "text": "10.3 ¿Ya tienes claves?\nPuede comprobar esto desde RStudio o desde el shell.\nConsejo global: si tiene claves existentes, pero no tiene idea de dónde provienen o por qué las creó, debería considerar seriamente la posibilidad de crear un nuevo par de claves SSH. Depende de usted decidir si eliminar las antiguas y cómo hacerlo. Pero no permita que eso le impida crear nuevas claves y seguir adelante.\n\n10.3.1 Desde RStudio\nVaya a Tools &gt; Global Options…&gt; Git/SVN. Si ve algo como ~/.ssh/id_rsa en el cuadro Clave SSH RSA, definitivamente tiene claves existentes.\nAdvertencia: RStudio solo busca un par de claves llamado id_rsa e id_rsa.pub. Esto tiene sentido, porque históricamente ha sido lo más común.\nSin embargo, hoy en día tanto GitHub como GitLab alientan a los usuarios a generar claves SSH con el algoritmo Ed25519, lo que da como resultado un par de claves llamado id_ed25519 e id_ed25519.pub. En el momento de escribir este artículo, RStudio no mostrará dicho par de claves, lo que puede resultar confuso. Por lo tanto, probablemente sea una buena idea comprobar también las claves existentes en el shell.\n\n10.3.2 Desde el shell\nVaya al shell (Appendix A).\nListe las claves existentes:\nls -al ~/.ssh/\nSi le dicen que ~/.ssh/ no existe, ¡no tiene claves SSH!\nSi ve un par de archivos como id_rsa.pub e id_rsa o id_ed25519 y id_ed25519.pub, ya tiene un par de claves. El patrón típico es id_FOO.pub (la clave pública) e id_FOO (la clave privada), donde FOO refleja el tipo de clave. Si está satisfecho con seguir con sus claves existentes, salte a las secciones sobre cómo agregar una clave al ssh-agent y GitHub.",
    "crumbs": [
      "Conectar Git, GitHub, RStudio",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Configurar claves para SSH</span>"
    ]
  },
  {
    "objectID": "connect-ssh-keys.html#crear-un-par-de-claves-ssh",
    "href": "connect-ssh-keys.html#crear-un-par-de-claves-ssh",
    "title": "10  Configurar claves para SSH",
    "section": "\n10.4 Crear un par de claves SSH",
    "text": "10.4 Crear un par de claves SSH\n\n10.4.1 Opción 1: configurar desde RStudio\nVaya a Tools &gt; Global Options…&gt; Git/SVN &gt; Create RSA Key….\nRStudio le solicita una frase de contraseña. Es opcional, pero también una buena práctica. Configurar su sistema para un funcionamiento fluido con una clave protegida con contraseña introduce más partes móviles. Si es completamente nuevo en esto, omita la frase de contraseña (¡o use HTTPS!) e impleméntela la próxima vez, cuando se sienta más cómodo con la configuración del sistema. Al principio no usaba una frase de contraseña, pero ahora la uso y la registro en un administrador de contraseñas.\nHaga clic en “Crear” y RStudio generará un par de claves SSH, almacenadas en los archivos ~/.ssh/id_rsa y ~/.ssh/id_rsa.pub.\nTenga en cuenta que actualmente RStudio solo genera claves RSA, mientras que la recomendación estándar de GitHub y GitLab es utilizar claves Ed25519. Si desea seguir ese consejo, genere sus claves en el shell por ahora.\n\n10.4.2 Opción 2: configurar desde el shell\nCree el par de claves así, pero sustitúyalo por un comentario que signifique algo para usted, especialmente si tendrá varias claves SSH en su vida. Considere el correo electrónico asociado con su cuenta de GitHub o el nombre de su computadora o alguna combinación, p.e. your_email@example.com or macbook-pro or jane-2020-macbook-pro.\nssh-keygen -t ed25519 -C \"DESCRIPTIVE-COMMENT\"\nSi parece que su sistema es demasiado antiguo para admitir el algoritmo Ed25519, haga lo siguiente:\nssh-keygen -t rsa -b 4096 -C \"DESCRIPTIVE-COMMENT\"\nAcepte la propuesta de guardar la clave en la ubicación predeterminada. Simplemente presione Enter aquí:\nEnter file in which to save the key (/Users/jenny/.ssh/id_ed25519):\nTiene la opción de proteger la clave con una frase de contraseña. Es opcional, pero también una buena práctica. Configurar su sistema para un funcionamiento fluido con una clave protegida con contraseña introduce más partes móviles. Si es completamente nuevo en esto, omita la frase de contraseña e impleméntela la próxima vez, cuando se sienta más cómodo con la configuración del sistema. Al principio no usaba una frase de contraseña, pero ahora la uso y la registro en un administrador de contraseñas.\nEnter passphrase (empty for no passphrase):\nEnter same passphrase again: \nEl proceso debería completarse ahora y debería haberse visto así:\n~ % ssh-keygen -t ed25519 -C \"jenny-2020-mbp\"        \nGenerating public/private ed25519 key pair.\nEnter file in which to save the key (/Users/jenny/.ssh/id_ed25519): \nEnter passphrase (empty for no passphrase): \nEnter same passphrase again: \nYour identification has been saved in /Users/jenny/.ssh/id_ed25519.\nYour public key has been saved in /Users/jenny/.ssh/id_ed25519.pub.\nThe key fingerprint is:\nSHA256:XUEaY/elhcQJz3M9jx/SdC0zh10lCA7uNpqgkm5G/R0 jenny-2020-mbp\nThe key's randomart image is:\n+--[ED25519 256]--+\n|        . =o==oo*|\n|       . + =.=+B+|\n|        . o . @oB|\n|       . . .  oO+|\n|  . .   S .  ..o.|\n| o o . E .    ...|\n|+ . . + .       .|\n|.+   . .         |\n|o.               |\n+----[SHA256]-----+\n\n10.4.3 Agregar clave al agente ssh\nInforme a su agente ssh sobre la clave y, especialmente, configúrelo para administrar la frase de contraseña, si decide establecer una.\nLas cosas se vuelven un poco específicas del sistema operativo por aquí. En caso de duda, consulte las instrucciones de GitHub para SSH, que se mantiene actualizado para Mac, Windows y Linux. También explica situaciones más inusuales que las que puedo.\n\n10.4.3.1 Mac OS\nAsegúrese de que ssh-agent esté habilitado. Así es como se ve el éxito (el pid variará):\n~ % eval \"$(ssh-agent -s)\"\nAgent pid 15360\nA veces esto falla así:\n~ % eval \"$(ssh-agent -s)\"\nmkdtemp: private socket dir: No such file or directory\nUn error similar podría informarse como “Permiso denegado”. Deberías intentarlo de nuevo, pero como superusuario. ¡No olvide utilizar exit para volver a su cuenta de usuario normal cuando haya terminado!\n~ % sudo su\nPassword:\nsh-3.2# eval \"$(ssh-agent -s)\"\nAgent pid 15385\nsh-3.2# exit\nexit\nAgregue su clave al agente ssh. Si establece una frase de contraseña, se le cuestionará aquí. Darle. La opción -K almacena su frase de contraseña en el Keychain.\n~ % ssh-add -K ~/.ssh/id_ed25519\nEnter passphrase for /Users/jenny/.ssh/id_ed25519: \nIdentity added: /Users/jenny/.ssh/id_ed25519 (jenny-2020-mbp)\nSi tienes macOS Sierra 10.12.2 y superior, debes hacer una cosa más. Cree un archivo ~/.ssh/config con este contenido:\nHost *\n  AddKeysToAgent yes\n  UseKeychain yes\n  IdentityFile ~/.ssh/id_ed25519\nPuedes omitir la línea sobre UseKeychain si no usaste una frase de contraseña. Pero si lo hizo, esto debería almacenar su contraseña persistentemente en el llavero. De lo contrario, tendrás que ingresarlo cada vez que inicies sesión. Hilo útil de StackOverflow: ¿Cómo puedo agregar permanentemente mi clave privada SSH a Keychain para que esté disponible automáticamente para ssh?.\n\n10.4.3.2 Windows\nEn un shell de Git Bash, asegúrese de que ssh-agent se esté ejecutando:\n$ eval $(ssh-agent -s)\nAgent pid 59566\nAgregue su clave, sustituyendo el nombre correcto por su clave.\n$ ssh-add ~/.ssh/id_ed25519\n\n10.4.3.3 Linux\nEn un shell, asegúrese de que ssh-agent se esté ejecutando:\n$ eval \"$(ssh-agent -s)\"\nAgent pid 59566\nAgregue su clave, sustituyendo el nombre correcto por su clave.\nssh-add ~/.ssh/id_ed25519",
    "crumbs": [
      "Conectar Git, GitHub, RStudio",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Configurar claves para SSH</span>"
    ]
  },
  {
    "objectID": "connect-ssh-keys.html#proporcionar-clave-pública-a-github",
    "href": "connect-ssh-keys.html#proporcionar-clave-pública-a-github",
    "title": "10  Configurar claves para SSH",
    "section": "\n10.5 Proporcionar clave pública a GitHub",
    "text": "10.5 Proporcionar clave pública a GitHub\nAhora almacenamos una copia de su clave pública en GitHub.\n\n10.5.1 RStudio al portapapeles\nVaya a Tools &gt; Global Options…&gt; Git/SVN. Si su par de claves tiene el nombre id_rsa.pub e id_rsa, RStudio lo verá y le ofrecerá “Ver clave pública”. Haga eso y acepte la oferta de copiar a su portapapeles.\nSi su par de claves tiene un nombre diferente, como id_ed25519.pub e id_ed25519, tendrá que copiar la clave pública de otra manera.\n\n10.5.2 Shell al portapapeles\nCopie la clave pública en su portapapeles. Por ejemplo, abra ~/.ssh/id_ed25519.pub en un editor y copie el contenido en su portapapeles. O realice una de las siguientes acciones en la línea de comando:\n\nMac OS: pbcopy &lt; ~/.ssh/id_ed25519.pub\n\nWindows: clip &lt; ~/.ssh/id_ed25519.pub\n\nLinux: xclip -sel clip &lt; ~/.ssh/id_ed25519.pub\n\n\nLinux: si es necesario, instale xclip mediante apt-get o yum. Por ejemplo, sudo apt-get install xclip.\n\n10.5.3 En GitHub\nAhora registramos la clave pública con GitHub. Haga clic en su foto de perfil en la esquina superior derecha y vaya a Configuración &gt; Claves SSH y GPG. Haga clic en “Nueva clave SSH”. Pegue su clave pública en el cuadro “Clave”. Asígnele un título informativo, probablemente repitiendo el comentario descriptivo que utilizó anteriormente durante la creación de la clave. Haga clic en “Agregar clave SSH”.\n¡En teoría, hemos terminado! Puedes usar ssh -T git@github.com para probar su conexión a GitHub. Si no está seguro de qué hacer con el resultado, consulte el enlace para obtener más detalles. Por supuesto, la mejor prueba es analizar los ejemplos de uso realistas que aparecen en otras partes de esta guía.",
    "crumbs": [
      "Conectar Git, GitHub, RStudio",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Configurar claves para SSH</span>"
    ]
  },
  {
    "objectID": "connect-ssh-keys.html#sec-ssh-troubleshooting",
    "href": "connect-ssh-keys.html#sec-ssh-troubleshooting",
    "title": "10  Configurar claves para SSH",
    "section": "\n10.6 Solución de problemas",
    "text": "10.6 Solución de problemas\n\n10.6.1 URL HTTPS cuando pretendías usar SSH\nSi cree que tiene SSH configurado correctamente y aún así se le solicitan credenciales, considere esto: para el repositorio en cuestión, ¿es posible que haya configurado GitHub, probablemente llamado origin, como un control remoto HTTPS, en lugar de SSH?\nCómo ver las URL remotas asociadas con el repositorio actual en el shell:\ngit remote -v\nUn control remoto SSH se verá así:\ngit@github.com:USERNAME/REPOSITORY.git\nmientras que un control remoto HTTPS se verá así:\nhttps://github.com/USERNAME/REPOSITORY.git\nPuedes solucionar este problema con git remoto set-url, que se demuestra en La URL determina el protocolo.\n\n10.6.2 git2r, o alguna otra herramienta, no puede encontrar claves SSH en Windows\n¿Has visto este mensaje de error?\nError in .local(object, ...) : \n  Error in 'git2r_push': error authenticating: failed connecting agent\nLo hemos visto cuando trabajamos con Git/GitHub desde R a través del paquete git2r.\nLa causa principal es la confusión sobre la ubicación de .ssh/ en Windows. La idea que tiene R de su directorio de inicio en Windows a menudo difiere de la ubicación predeterminada de los archivos de configuración para Git y ssh, como .ssh/. En sistemas *nix, generalmente coinciden y no hay problema.\nDos directorios importantes en Windows son el HOME del usuario y el USERPROFILE. R generalmente asocia ~ con HOME, pero Git y ssh a menudo consultan USERPROFILE para sus archivos de configuración. En mi máquina virtual con Windows 10, veo:\n\nnormalizePath(\"~\")\n#&gt; [1] \"C:\\\\Users\\\\JennyVM\\\\Documents\"\n\nas.list(Sys.getenv(\n  c(\"HOME\", \"USERPROFILE\")\n))\n#&gt; $HOME\n#&gt; [1] \"C:/Users/JennyVM/Documents\"\n#&gt; \n#&gt; $USERPROFILE\n#&gt; [1] \"C:\\\\Users\\\\JennyVM\"\n\nlist.files(\n  Sys.getenv(\"USERPROFILE\"),\n  pattern = \"ssh|git\",\n  include.dirs = TRUE,\n  all.files = TRUE\n)\n#&gt; [1] \".gitconfig\" \".ssh\"\n\nDos soluciones:\n\n\nDígale a git2r explícitamente dónde encontrar su clave pública y privada y pase el objeto cred resultante a sus llamadas de git2r.\n\ncred &lt;- git2r::cred_ssh_key(\n  publickey = \"~/../.ssh/id_rsa.pub\",\n  privatekey = \"~/../.ssh/id_rsa\"\n)\n\n\n\nCrear un enlace simbólico para que .ssh/ en el directorio de inicio de R apunte a su directorio real .ssh/. Ejemplo aportado por Ian Lyttle en Windows 7 usando el símbolo del sistema:\nMKLINK /D \"C:\\Users\\username\\Documents\\.ssh\" \"C:\\Users\\username\\.ssh\"\n\n\nFinalmente, si git2r parece incapaz de obtener su contraseña SSH de ssh-agent, instale el paquete getPass:\n\ninstall.packages(\"getPass\")\n\ny git2r debería abrir una ventana emergente donde puede ingresar su frase de contraseña. Gracias a Ian Lyttle por este consejo.\nEste enlace proporciona una excelente explicación de la incertidumbre sobre dónde se encuentran .ssh/ y .gitconfig del usuario en Windows: git en Windows - ubicación de los archivos de configuración. En pocas palabras: coloque su configuración y claves donde su herramienta principal espera que estén y cree enlaces simbólicos para ayudar a otras herramientas a encontrar estas cosas.\n\n10.6.3 Otro\nOtras cosas para verificar dos veces:\n\n¿Agregaste SSH a tu agente ssh?\n¿Configuraste Mac OS Sierra o High Sierra para almacenar persistentemente tu frase de contraseña en el llavero?\n¿Agregaste la clave pública a GitHub?",
    "crumbs": [
      "Conectar Git, GitHub, RStudio",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Configurar claves para SSH</span>"
    ]
  },
  {
    "objectID": "connect-git-github.html",
    "href": "connect-git-github.html",
    "title": "11  Conéctate a GitHub",
    "section": "",
    "text": "11.1 Hacer un repositorio en GitHub\nVaya a https://github.com y asegúrese de haber iniciado sesión.\nCerca de “Repositorios”, haga clic en el gran botón verde “Nuevo”. O, si está en su propia página de perfil, haga clic en “Repositorios” y luego haga clic en el gran botón verde “Nuevo”.\nCómo completar esto:\nHaga clic en el gran botón verde que dice “Crear repositorio”.\nAhora haga clic en el gran botón verde que dice “&lt;&gt; Code”.\nCopie una URL clonada a su portapapeles. Si sigue nuestro consejo predeterminado, copie la URL HTTPS. Pero si opta por SSH, asegúrese de copiar la URL de SSH.",
    "crumbs": [
      "Conectar Git, GitHub, RStudio",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Conéctate a GitHub</span>"
    ]
  },
  {
    "objectID": "connect-git-github.html#hacer-un-repositorio-en-github",
    "href": "connect-git-github.html#hacer-un-repositorio-en-github",
    "title": "11  Conéctate a GitHub",
    "section": "",
    "text": "Plantilla de repositorio: sin plantilla.\nNombre del repositorio: &lt;&lt;&gt;&gt;\n\nDescripción: &lt;&lt;&gt;&gt;\n\nPúblico.\n&lt;&lt;&gt;&gt;",
    "crumbs": [
      "Conectar Git, GitHub, RStudio",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Conéctate a GitHub</span>"
    ]
  },
  {
    "objectID": "connect-git-github.html#sec-git-clone-command-line",
    "href": "connect-git-github.html#sec-git-clone-command-line",
    "title": "11  Conéctate a GitHub",
    "section": "\n11.2 Clona el repositorio en tu computadora local",
    "text": "11.2 Clona el repositorio en tu computadora local\nTenemos algunas formas de hacer esto. Aquí usamos la línea de comando Git. En (Chapter 15), mostramos otros métodos que quizás prefieras en la vida diaria: usar usethis o RStudio IDE.\nIr al shell (Appendix A).\nHazte cargo de… ¡o al menos notalo! – en qué directorio estás. pwd muestra el directorio de trabajo. cd es el comando para cambiar de directorio. Personalmente, haría este tipo de cosas en ~/tmp.\nClona myrepo de GitHub a tu computadora. Utilice la URL que acabamos de copiar de GitHub. Esta URL debe tener su nombre de usuario de GitHub y el nombre de su repositorio de práctica. Si su shell (Appendix A) coopera, debería poder pegar todo el bit https://.... que copiamos arriba. Pero algunos shells no reconocen (inmediatamente) el portapapeles. En ese triste caso, debes escribirlo. Precisamente.\ngit clone https://github.com/YOUR-USERNAME/YOUR-REPOSITORY.git\nEsto debería verse así:\n~/tmp % git clone https://github.com/jennybc/myrepo.git\nCloning into 'myrepo'...\nremote: Enumerating objects: 3, done.\nremote: Counting objects: 100% (3/3), done.\nremote: Total 3 (delta 0), reused 0 (delta 0), pack-reused 0\nReceiving objects: 100% (3/3), done.\nHaga de este nuevo repositorio su directorio de trabajo, enumere sus archivos, muestre el archivo README y obtenga información sobre su conexión a GitHub:\ncd myrepo\nls\nhead README.md\ngit remote show origin\nEsto debería verse así:\n~/tmp % cd myrepo\n\n~/tmp/myrepo % ls\nREADME.md\n\n~/tmp/myrepo % head README.md \n# myrepo\nchecking stuff for Happy Git\n\n~/tmp/myrepo % git remote show origin\n* remote origin\n  Fetch URL: https://github.com/jennybc/myrepo.git\n  Push  URL: https://github.com/jennybc/myrepo.git\n  HEAD branch: main\n  Remote branch:\n    main tracked\n  Local branch configured for 'git pull':\n    main merges with remote main\n  Local ref configured for 'git push':\n    main pushes to main (up to date)",
    "crumbs": [
      "Conectar Git, GitHub, RStudio",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Conéctate a GitHub</span>"
    ]
  },
  {
    "objectID": "connect-git-github.html#haga-un-cambio-local-comprométase-y-presione",
    "href": "connect-git-github.html#haga-un-cambio-local-comprométase-y-presione",
    "title": "11  Conéctate a GitHub",
    "section": "\n11.3 Haga un cambio local, comprométase y presione",
    "text": "11.3 Haga un cambio local, comprométase y presione\nAgregue una línea a README y verifique que Git note el cambio:\necho \"A line I wrote on my local computer  \" &gt;&gt; README.md\ngit status\nEsto debería verse así:\n~/tmp/myrepo % echo \"A line I wrote on my local computer\" &gt;&gt; README.md\n\n~/tmp/myrepo % git status\nOn branch main\nYour branch is up to date with 'origin/main'.\n\nChanges not staged for commit:\n  (use \"git add &lt;file&gt;...\" to update what will be committed)\n  (use \"git restore &lt;file&gt;...\" to discard changes in working directory)\n        modified:   README.md\n\nno changes added to commit (use \"git add\" and/or \"git commit -a\")\nPrepare (“add”), confirme este cambio y envíelo a su repositorio remoto en GitHub.\nSi es un nuevo usuario de GitHub y utiliza HTTPS, es posible que se le solicite su nombre de usuario y contraseña. Aunque GitHub ya no permite la autenticación de nombre de usuario/contraseña, muchas herramientas generales de Git todavía enmarcan la tarea de autenticación con este vocabulario. Por supuesto, proporcione su nombre de usuario de GitHub cuando se le solicite. Sin embargo, la parte más importante es proporcionar su PAT como contraseña. No introduzcas tu contraseña web. Ingrese su PAT. Si ya almacenó su PAT con gitcreds::gitcreds_set(), debería descubrirse automáticamente y no verá un desafío de credenciales.\ngit add README.md\ngit commit -m \"Una confirmación de mi computadora local\"\ngit push\nEsto debería verse así:\n~/tmp/myrepo % git add README.md\n\n~/tmp/myrepo % git commit -m \"Una confirmación de mi computadora local\"\n[main e92528c] Una confirmación de mi computadora local\n 1 file changed, 1 insertion(+)\n \n~/tmp/myrepo % git push\nEnumerating objects: 5, done.\nCounting objects: 100% (5/5), done.\nDelta compression using up to 12 threads\nCompressing objects: 100% (2/2), done.\nWriting objects: 100% (3/3), 327 bytes | 327.00 KiB/s, done.\nTotal 3 (delta 0), reused 0 (delta 0), pack-reused 0\nTo https://github.com/jennybc/myrepo.git\n   31dcaef..e92528c  main -&gt; main\n¿Ves un error como este?\n~/tmp/myrepo % git push                                                     \nremote: Support for password authentication was removed on August 13, 2021. Please use a personal access token instead.\nremote: Please see https://github.blog/2020-12-15-token-authentication-requirements-for-git-operations/ for more information.\nfatal: Authentication failed for 'https://github.com/jennybc/myrepo.git/'\nEsto significa que ha proporcionado su contraseña web de GitHub, en lugar de su token de acceso personal (PAT). Vuelva a (Chapter 9) para obtener un PAT. Intente git push nuevamente y con suerte recibirá otro mensaje que le permitirá corregir cosas y proporcionar su PAT.\nSi alguna vez siente que necesita sobrescribir una credencial incorrecta con una nueva, la forma más sencilla de hacerlo es llamar gitcreds::gitcreds_set() desde R.\n\n11.3.1 Ventanas y finales de línea.\nEn Windows, es posible que vea un mensaje que diga LF will be replaced by CRLF. Esto es normal y no requiere ninguna acción de su parte. Windows maneja los finales de línea de manera diferente a otros sistemas operativos, pero la configuración predeterminada de Git para Windows es apropiada para la mayoría de las personas y situaciones.\nAquí hay un comando para revelar la configuración de final de línea actual y algunos resultados típicos en Windows:\n$ git config --show-origin --get core.autocrlf\nfile:\"C:\\\\ProgramData/Git/config\"      true\nSi su valor se muestra como false, puede establecerlo en true con este comando:\n$ git config --global core.autocrlf true\ntrue es la configuración predeterminada actual para core.autocrlf para Git para Windows, nuestro método recomendado para instalar Git en Windows. La necesidad de configurar esto explícitamente en su configuración de usuario global sugiere que debería considerar reinstalar o actualizar Git para Windows.",
    "crumbs": [
      "Conectar Git, GitHub, RStudio",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Conéctate a GitHub</span>"
    ]
  },
  {
    "objectID": "connect-git-github.html#confirmar-el-cambio-local-propagado-al-control-remoto-de-github",
    "href": "connect-git-github.html#confirmar-el-cambio-local-propagado-al-control-remoto-de-github",
    "title": "11  Conéctate a GitHub",
    "section": "\n11.4 Confirmar el cambio local propagado al control remoto de GitHub",
    "text": "11.4 Confirmar el cambio local propagado al control remoto de GitHub\nVuelve al navegador. Supongo que todavía estamos viendo su nuevo repositorio de GitHub.\nActualizar.\nDeberías ver la nueva “Una línea que escribí en mi computadora local” en el archivo README.\nSi hace clic en “commits”, debería ver uno con el mensaje “Una confirmación desde mi computadora local”.\nSi ha llegado hasta aquí, usted y su repositorio de prueba están listos para pasar a usar Git y GitHub con RStudio.(Chapter 12).",
    "crumbs": [
      "Conectar Git, GitHub, RStudio",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Conéctate a GitHub</span>"
    ]
  },
  {
    "objectID": "connect-git-github.html#limpiar",
    "href": "connect-git-github.html#limpiar",
    "title": "11  Conéctate a GitHub",
    "section": "\n11.5 Limpiar",
    "text": "11.5 Limpiar\nSi está listo para concluir esta prueba de su instalación de Git y configuración de GitHub, podemos limpiar el repositorio de prueba ahora.\nLocal Cuando estés listo para limpiar, puedes eliminar el repositorio local como quieras. Es solo un directorio normal en su computadora.\nAquí se explica cómo hacerlo en el shell, si el directorio de trabajo actual es myrepo:\ncd ..\nrm -rf myrepo/\nGitHub En el navegador, vaya a la página de inicio de su repositorio en GitHub. Haga clic en “Configuración”.\nDesplázate hacia abajo, haz clic en “eliminar repositorio” y haz lo que te pide.",
    "crumbs": [
      "Conectar Git, GitHub, RStudio",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Conéctate a GitHub</span>"
    ]
  },
  {
    "objectID": "connect-rstudio-git-github.html",
    "href": "connect-rstudio-git-github.html",
    "title": "12  Conectar RStudio a Git y GitHub",
    "section": "",
    "text": "12.1 Requisitos previos\nSuponemos lo siguiente:\nTambién necesitarás un repositorio de prueba en GitHub. Si no tiene un repositorio de prueba adecuado en GitHub, siga las instrucciones de la siguiente sección.\nSi acaba de completar el capítulo anterior, Conectarse a GitHub, ¡ese repositorio será perfecto! Sin embargo, le recomiendo que elimine el repositorio local, para que pueda experimentar cómo usamos RStudio para clonarlo y obtener una copia local. En realidad, este es un flujo de trabajo al que nos referimos en otros lugares (ver Chapter 37) como “quemarlo todo”. Es una estrategia profundamente pragmática para afrontar la situación si su repositorio Git local está estropeado, pero la versión en GitHub es bastante actual.\nElimina la carpeta correspondiente al repositorio local como quieras. Es solo un directorio normal en su computadora. Aquí se explica cómo hacerlo en el shell, si el directorio de trabajo actual es myrepo:",
    "crumbs": [
      "Conectar Git, GitHub, RStudio",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Conectar RStudio a Git y GitHub</span>"
    ]
  },
  {
    "objectID": "connect-rstudio-git-github.html#requisitos-previos",
    "href": "connect-rstudio-git-github.html#requisitos-previos",
    "title": "12  Conectar RStudio a Git y GitHub",
    "section": "",
    "text": "Has registrado una cuenta gratuita de GitHub (Chapter 4).\nHas instalado/actualizado R y RStudio (Chapter 5).\nHas instalado Git (Chapter 6).\nTe has presentado a Git (Chapter 7).\nHas confirmado que puedes enviar/extraer desde GitHub desde la línea de comando (Chapter 11).\n\n\n\n\ncd ..\nrm -rf myrepo/",
    "crumbs": [
      "Conectar Git, GitHub, RStudio",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Conectar RStudio a Git y GitHub</span>"
    ]
  },
  {
    "objectID": "connect-rstudio-git-github.html#hacer-un-repositorio-en-github",
    "href": "connect-rstudio-git-github.html#hacer-un-repositorio-en-github",
    "title": "12  Conectar RStudio a Git y GitHub",
    "section": "\n12.2 Hacer un repositorio en GitHub",
    "text": "12.2 Hacer un repositorio en GitHub\nVaya a https://github.com y asegúrese de haber iniciado sesión.\nCerca de “Repositorios”, haga clic en el gran botón verde “Nuevo”. O, si está en su propia página de perfil, haga clic en “Repositorios” y luego haga clic en el gran botón verde “Nuevo”.\nCómo completar esto:\n\nPlantilla de repositorio: sin plantilla.\nNombre del repositorio: &lt;&lt;&gt;&gt;\n\nDescripción: &lt;&lt;&gt;&gt;\n\nPúblico.\n&lt;&lt;&gt;&gt;\n\n\nHaga clic en el gran botón verde que dice “Crear repositorio”.\nAhora haga clic en el gran botón verde que dice “&lt;&gt; Code”.\nCopie una URL clonada a su portapapeles. Si sigue nuestro consejo predeterminado, copie la URL HTTPS. Pero si opta por SSH, asegúrese de copiar la URL de SSH.",
    "crumbs": [
      "Conectar Git, GitHub, RStudio",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Conectar RStudio a Git y GitHub</span>"
    ]
  },
  {
    "objectID": "connect-rstudio-git-github.html#clona-el-repositorio-de-prueba-de-github-en-tu-computadora-a-través-de-rstudio",
    "href": "connect-rstudio-git-github.html#clona-el-repositorio-de-prueba-de-github-en-tu-computadora-a-través-de-rstudio",
    "title": "12  Conectar RStudio a Git y GitHub",
    "section": "\n12.3 Clona el repositorio de prueba de GitHub en tu computadora a través de RStudio",
    "text": "12.3 Clona el repositorio de prueba de GitHub en tu computadora a través de RStudio\nEn RStudio, inicie un nuevo proyecto:\n\n\nFile &gt; New Project &gt; Version Control &gt; Git. En “URL del repositorio”, pegue la URL de su nuevo repositorio de GitHub. será algo como esto https://github.com/jennybc/myrepo.git.\n\n¿NO ve una opción para obtener el proyecto desde el control de versiones? Reinicie RStudio y vuelva a intentarlo. ¿Aún no has tenido suerte? Vaya a Chapter 13 para obtener consejos sobre cómo ayudar a RStudio a encontrar Git.\n\n\nAcepte el nombre del directorio del proyecto predeterminado, p. myrepo, que coincide con el nombre del repositorio de GitHub.\n¡Hazte cargo de… o al menos notalo! - donde el proyecto se guardará localmente. Un error común de los novatos es no tener idea de dónde está guardando los archivos o cuál es su directorio de trabajo. Prestar atención. Sea intencional. Personalmente, haría esto en ~/tmp.\nTe sugiero que marques “Abrir en una nueva sesión”, ya que eso es lo que normalmente harás en la vida real.\nHaga clic en “Crear proyecto”.\n\nDebería encontrarse en un nuevo proyecto RStudio local que representa su repositorio de prueba en GitHub. Esto debería descargar el archivo README.md de GitHub. Busque en el panel del explorador de archivos de RStudio el archivo README.md.",
    "crumbs": [
      "Conectar Git, GitHub, RStudio",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Conectar RStudio a Git y GitHub</span>"
    ]
  },
  {
    "objectID": "connect-rstudio-git-github.html#realizar-cambios-locales-guardar-confirmar",
    "href": "connect-rstudio-git-github.html#realizar-cambios-locales-guardar-confirmar",
    "title": "12  Conectar RStudio a Git y GitHub",
    "section": "\n12.4 Realizar cambios locales, guardar, confirmar",
    "text": "12.4 Realizar cambios locales, guardar, confirmar\nDesde RStudio, modifique el archivo README.md, por ejemplo, agregando la línea “Esta es una línea de RStudio”. Guarde sus cambios.\nConfirme estos cambios en su repositorio local. ¿Cómo?\nDe RStudio:\n\nHaga clic en la pestaña “Git” en el panel superior derecho.\nMarque la casilla “Staged” para README.md.\nSi aún no estás en la ventana emergente de Git, haz clic en “Commit”.\nEscriba un mensaje en “Commit message”, como por ejemplo “Commit from RStudio”.\nHaga click en “Commit”.",
    "crumbs": [
      "Conectar Git, GitHub, RStudio",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Conectar RStudio a Git y GitHub</span>"
    ]
  },
  {
    "objectID": "connect-rstudio-git-github.html#envíe-sus-cambios-locales-en-línea-a-github",
    "href": "connect-rstudio-git-github.html#envíe-sus-cambios-locales-en-línea-a-github",
    "title": "12  Conectar RStudio a Git y GitHub",
    "section": "\n12.5 Envíe sus cambios locales en línea a GitHub",
    "text": "12.5 Envíe sus cambios locales en línea a GitHub\nHaga clic en el botón verde “Push” para enviar sus cambios locales a GitHub.\nNo debería experimentar un desafío de credenciales, ya que uno de los requisitos previos fue ingresar exitosamente a GitHub desde la línea de comando (Chapter 11). El panel Git de RStudio simplemente expone un subconjunto específico de la línea de comando Git y, por lo tanto, una vez que sus credenciales funcionen en el shell, deberían funcionar en RStudio. Si experimenta un desafío de credenciales, eso sugiere que debería echar un vistazo a las sugerencias de solución de problemas para el protocolo elegido, ya sea HTTPS o SSH.",
    "crumbs": [
      "Conectar Git, GitHub, RStudio",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Conectar RStudio a Git y GitHub</span>"
    ]
  },
  {
    "objectID": "connect-rstudio-git-github.html#confirmar-el-cambio-local-propagado-al-control-remoto-de-github",
    "href": "connect-rstudio-git-github.html#confirmar-el-cambio-local-propagado-al-control-remoto-de-github",
    "title": "12  Conectar RStudio a Git y GitHub",
    "section": "\n12.6 Confirmar el cambio local propagado al control remoto de GitHub",
    "text": "12.6 Confirmar el cambio local propagado al control remoto de GitHub\nVuelve al navegador. Supongo que todavía estamos viendo su nuevo repositorio de GitHub.\nActualizar.\nDeberías ver el nuevo “Esta es una línea de RStudio” en el archivo README.\nSi hace clic en “confirmar”, debería ver uno con el mensaje “Confirmar desde RStudio”.\nSi ha llegado hasta aquí, habrá TERMINADO la configuración. ¡Felicidades!",
    "crumbs": [
      "Conectar Git, GitHub, RStudio",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Conectar RStudio a Git y GitHub</span>"
    ]
  },
  {
    "objectID": "connect-rstudio-git-github.html#limpiar",
    "href": "connect-rstudio-git-github.html#limpiar",
    "title": "12  Conectar RStudio a Git y GitHub",
    "section": "\n12.7 Limpiar",
    "text": "12.7 Limpiar\nSalga de la instancia de RStudio que está abierta en su proyecto de prueba/repositorio Git.\nElimina el repositorio local como quieras. Es solo un directorio normal en su computadora.\nAquí se explica cómo hacerlo en el shell, si el directorio de trabajo actual es myrepo:\ncd ..\nrm -rf myrepo/\nEn el navegador, vaya a la página de inicio de su repositorio en GitHub. Haga clic en “Configuración”.\nDesplázate hacia abajo, haz clic en “eliminar repositorio” y haz lo que te pide.",
    "crumbs": [
      "Conectar Git, GitHub, RStudio",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Conectar RStudio a Git y GitHub</span>"
    ]
  },
  {
    "objectID": "connect-can-rstudio-use-git.html",
    "href": "connect-can-rstudio-use-git.html",
    "title": "13  Detectar Git desde RStudio",
    "section": "",
    "text": "13.1 ¿Tiene usted un problema?\nComprobemos si RStudio puede encontrar el ejecutable de Git.\nSigue leyendo si las cosas no van tan bien o quieres saber más.",
    "crumbs": [
      "Conectar Git, GitHub, RStudio",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Detectar Git desde RStudio</span>"
    ]
  },
  {
    "objectID": "connect-can-rstudio-use-git.html#tiene-usted-un-problema",
    "href": "connect-can-rstudio-use-git.html#tiene-usted-un-problema",
    "title": "13  Detectar Git desde RStudio",
    "section": "",
    "text": "File &gt; New Project… ¿Ves una opción para crear desde Control de versiones? Si es así, bien.\nSeleccione New Directory &gt; Empty Project. ¿Ves una casilla de verificación “Create a git repository”? Si es así, bien, SELECCIÓNELO.",
    "crumbs": [
      "Conectar Git, GitHub, RStudio",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Detectar Git desde RStudio</span>"
    ]
  },
  {
    "objectID": "connect-can-rstudio-use-git.html#encuentra-git-tú-mismo",
    "href": "connect-can-rstudio-use-git.html#encuentra-git-tú-mismo",
    "title": "13  Detectar Git desde RStudio",
    "section": "13.2 Encuentra Git tú mismo",
    "text": "13.2 Encuentra Git tú mismo\nRStudio solo puede actuar como interfaz gráfica de usuario para Git si Git se ha instalado correctamente (Chapter 6) Y RStudio puede encontrarlo.\nUna prueba básica para una instalación exitosa de Git es simplemente ingresar git en el shell (Appendix A). Si recibe una queja acerca de que no se encuentra Git, significa que la instalación no tuvo éxito o que no se encuentra, es decir, no está en su PATH.\nSi no está seguro de dónde se encuentra el ejecutable de Git, intente esto en un shell:\n\nwhich git (Mac, Linux, Git Bash shell en Windows)\nwhere git (Símbolo del sistema de Windows, es decir cmd.exe)",
    "crumbs": [
      "Conectar Git, GitHub, RStudio",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Detectar Git desde RStudio</span>"
    ]
  },
  {
    "objectID": "connect-can-rstudio-use-git.html#dile-a-rstudio-dónde-encontrar-git",
    "href": "connect-can-rstudio-use-git.html#dile-a-rstudio-dónde-encontrar-git",
    "title": "13  Detectar Git desde RStudio",
    "section": "13.3 Dile a RStudio dónde encontrar Git",
    "text": "13.3 Dile a RStudio dónde encontrar Git\nSi parece que Git está instalado y se puede encontrar, inicie RStudio. Salga y reinicie RStudio si tiene alguna duda sobre si abrió RStudio antes o después de instalar Git. No me obligues a detener este auto y reiniciar RStudio en horario de oficina. HAZLO.\nDesde RStudio, vaya a Tools &gt; Global Options &gt; Git/SVN y asegúrese de que el cuadro Git executable apunte a su ejecutable Git.\nEn macOS y Linux, la ruta suele verse así:\n/usr/bin/git\nSi necesita configurar esto en macOS, a veces puede resultar difícil navegar hasta el directorio necesario una vez que haya hecho clic en “Examinar” y esté trabajando con una ventana tipo Finder. El método abreviado de teclado “comando + mayúsculas + g” invocará “Ir a la carpeta”, donde podrá escribir o pegar cualquier ruta que desee.\nEn Windows, esta ruta debería verse así:\nC:/Program Files/Git/bin/git.exe\ny aquí hay una captura de pantalla en Windows:\n\n\n\n\n\nADVERTENCIA: En Windows, NO use C:/Program Files/Git/cmd/git.exe. bin en el camino es BUENO ¡SÍ! cmd en la ruta es MALO ¡NO!\nADVERTENCIA: En Windows, NO configure esto en git-bash.exe. Algo que termina en git.exe es BUENO ¡SÍ! git-bash.exe es MALO, ¡NO!\nReinicie RStudio si realiza algún cambio aquí. No me obligue a detener este auto nuevamente y reinicie RStudio por usted en horario de oficina. HAZLO.\nVuelva a realizar los pasos en la parte superior de la página para ver si RStudio y Git se están comunicando ahora.\n\nHe visto esta ayuda: con su proyecto abierto, vaya a Tools &gt; Project Options.... Si está disponible, haga clic en “Git/SVN” y seleccione “Git” en el menú desplegable del sistema de control de versiones. Responda “sí” a la ventana emergente “Confirmar nuevo repositorio Git”. Responda “sí” a la ventana emergente “Confirmar reinicio de RStudio”.\nSi instaló Git a través de GitHub para Windows, es posible que el ejecutable de Git esté muy bien oculto. Obtenga ayuda o utilice uno de nuestros métodos recomendados para instalar Git.\nSu PATH probablemente no esté configurada correctamente y/o debería reinstalar Git y controlar/observar hacia dónde se dirige. Lea más en Chapter 14.\nConsigue nuestra ayuda.",
    "crumbs": [
      "Conectar Git, GitHub, RStudio",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Detectar Git desde RStudio</span>"
    ]
  },
  {
    "objectID": "connect-troubleshooting.html",
    "href": "connect-troubleshooting.html",
    "title": "14  RStudio, Git, GitHub Hell",
    "section": "",
    "text": "14.1 Creo que he instalado Git pero maldita sea si puedo encontrarlo.\nCuando instales Git, intenta controlar o registrar dónde se está instalando. Tome nota mental o física de estas cosas.\nEs posible que puedas encontrar Git después del hecho con estos comandos en el shell (Appendix A):\nNo es del todo una locura simplemente reinstalar Git, usando un método que lo deje en una ubicación más convencional y prestando mucha atención a dónde se está instalando. Vive y aprende.",
    "crumbs": [
      "Conectar Git, GitHub, RStudio",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>RStudio, Git, GitHub Hell</span>"
    ]
  },
  {
    "objectID": "connect-troubleshooting.html#creo-que-he-instalado-git-pero-maldita-sea-si-puedo-encontrarlo.",
    "href": "connect-troubleshooting.html#creo-que-he-instalado-git-pero-maldita-sea-si-puedo-encontrarlo.",
    "title": "14  RStudio, Git, GitHub Hell",
    "section": "",
    "text": "which git (Mac, Linux o cualquier dispositivo que ejecute un shell bash)\nwhere git (Windows, cuando no está en un shell bash)",
    "crumbs": [
      "Conectar Git, GitHub, RStudio",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>RStudio, Git, GitHub Hell</span>"
    ]
  },
  {
    "objectID": "connect-troubleshooting.html#el-panel-rstudio-git-desaparece-en-mac-os",
    "href": "connect-troubleshooting.html#el-panel-rstudio-git-desaparece-en-mac-os",
    "title": "14  RStudio, Git, GitHub Hell",
    "section": "14.2 El panel RStudio Git desaparece en Mac OS",
    "text": "14.2 El panel RStudio Git desaparece en Mac OS\nA veces, el panel RStudio Git desaparece en un sistema donde estaba funcionando anteriormente. Esto suele sucederle a las personas que instalaron Git instalando las herramientas de línea de comandos de Xcode. Suele ser una señal de que necesita volver a aceptar el acuerdo de licencia de Xcode. Esto es necesario después de una actualización de Mac OS, la reinstalación de Xcode o incluso actualizaciones silenciosas de Xcode que a veces parecen ocurrir sin el conocimiento del usuario.\nEn el shell, puedes ejecutar git status y es posible que veas un mensaje como este:\nAgreeing to the Xcode/iOS license requires admin privileges, please run “sudo xcodebuild -license” and then retry this command.\nSi recibe instrucciones tan claras, haga lo que dice, es decir, ejecute sudo xcodebuild -license, para volver a aceptar la licencia.\nEn cualquier caso, debe hacer cosquillas a las herramientas de línea de comandos de Xcode para que le soliciten lo que necesite. Aquí hay otros comandos que, según la situación, pueden activar las indicaciones necesarias:\nxcode-select --install\no\ngit config --global --list\nEntonces reinicie RStudio.",
    "crumbs": [
      "Conectar Git, GitHub, RStudio",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>RStudio, Git, GitHub Hell</span>"
    ]
  },
  {
    "objectID": "connect-troubleshooting.html#path-disfuncional",
    "href": "connect-troubleshooting.html#path-disfuncional",
    "title": "14  RStudio, Git, GitHub Hell",
    "section": "14.3 PATH disfuncional",
    "text": "14.3 PATH disfuncional\nAlgunos casos en los que RStudio no detecta automáticamente el ejecutable de Git se deben a problemas con PATH. Este es el conjunto de directorios donde su computadora buscará ejecutables, como Git (hoy) o make. Ciertos métodos de instalación de Git, especialmente en Windows y/o sistemas operativos más antiguos, tienen una mayor tendencia a colocar Git en una ubicación no convencional o a no agregar el directorio relevante a PATH.\n¿Cómo ver PATH?\nEn el shell:\necho $PATH\nFíjate bien en esto. Vea el punto anterior sobre cómo encontrar su ejecutable Git o reinstalarlo mientras está completamente despierto. ¿Está el directorio principal del ejecutable de Git en su PATH? ¿No? Arregla eso.\nEn este punto te recomiendo que hagas una búsqueda en Google para encontrar instrucciones sobre cómo modificar PATH en tu sistema operativo específico.",
    "crumbs": [
      "Conectar Git, GitHub, RStudio",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>RStudio, Git, GitHub Hell</span>"
    ]
  },
  {
    "objectID": "connect-troubleshooting.html#botones-pushpull-atenuados-en-rstudio",
    "href": "connect-troubleshooting.html#botones-pushpull-atenuados-en-rstudio",
    "title": "14  RStudio, Git, GitHub Hell",
    "section": "14.4 Botones Push/Pull atenuados en RStudio",
    "text": "14.4 Botones Push/Pull atenuados en RStudio\n¿Está seguro de que su repositorio local está asociado con un repositorio remoto, p. ¿Un repositorio de GitHub? En un shell con el directorio de trabajo configurado en el repositorio de Git local, ingrese este comando:\n~/tmp/myrepo % git remote -v                                           \norigin  git@github.com:jennybc/myrepo.git (fetch)\norigin  git@github.com:jennybc/myrepo.git (push)\nQueremos ver que la recuperación y la inserción estén configuradas en URL remotas que apunten al repositorio remoto.\nSi descubre que aún necesita configurar un control remoto, obtenga la URL HTTPS o SSH, según corresponda, para su repositorio de GitHub. Es fácil acceder a su portapapeles desde la página de GitHub del repositorio. Haz esto en el shell:\ngit remote add origin https://github.com/jennybc/myrepo.git\nDescargue todos los archivos del repositorio en línea de GitHub y solucione cualquier conflicto (sustituyendo master por main, si corresponde).\ngit pull origin main\nLlame a git remote -v nuevamente. Una vez que esté satisfecho de que su control remoto GitHub esté configurado correctamente, puede continuar con el siguiente paso.\n¿Está seguro de que la rama actual está siguiendo una rama en el control remoto? En ese mismo shell, en tu repositorio, haz esto:\n~/tmp/myrepo % git branch -vv\n* main 2899c91 [origin/main] A commit from my local computer\nLo anterior muestra una confirmación exitosa de que la rama main local está rastreando origin/main, es decir, la rama main en GitHub. Si no ve el bit [origen/principal], eso es un problema. Por cierto, git branch -r y git remote show origin son dos comandos más que son útiles para examinar su configuración remota.\nAl conectar un repositorio local a un nuevo repositorio de GitHub, muchas personas recuerdan agregar el control remoto de GitHub, pero también se olvidan de consolidar esta relación de seguimiento para las ramas relevantes.\nSi descubre que su rama main local aún no realiza un seguimiento de main en GitHub, corríjalo de la siguiente manera:\ngit push --set-upstream origin main\nEsto es equivalente a git push -u origin main pero transmite más sobre lo que estás haciendo.\nLlame a git branch -vv o git branch -r o git remote show origin nuevamente para confirmar que la rama main en GitHub es la rama de seguimiento para la rama main local.",
    "crumbs": [
      "Conectar Git, GitHub, RStudio",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>RStudio, Git, GitHub Hell</span>"
    ]
  },
  {
    "objectID": "connect-troubleshooting.html#no-tengo-idea-si-mi-repositorio-local-y-mi-repositorio-remoto-están-conectados.",
    "href": "connect-troubleshooting.html#no-tengo-idea-si-mi-repositorio-local-y-mi-repositorio-remoto-están-conectados.",
    "title": "14  RStudio, Git, GitHub Hell",
    "section": "14.5 No tengo idea si mi repositorio local y mi repositorio remoto están conectados.",
    "text": "14.5 No tengo idea si mi repositorio local y mi repositorio remoto están conectados.\nConsulte la sección anterior sobre “Botones Push/Pull atenuados en RStudio”.",
    "crumbs": [
      "Conectar Git, GitHub, RStudio",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>RStudio, Git, GitHub Hell</span>"
    ]
  },
  {
    "objectID": "connect-troubleshooting.html#push-rechazado-es-decir-falla-en-el-nivel-de-gitgithub",
    "href": "connect-troubleshooting.html#push-rechazado-es-decir-falla-en-el-nivel-de-gitgithub",
    "title": "14  RStudio, Git, GitHub Hell",
    "section": "14.6 Push rechazado, es decir, falla en el nivel de Git/GitHub",
    "text": "14.6 Push rechazado, es decir, falla en el nivel de Git/GitHub\nEs posible que tenga cambios en el repositorio remoto Y en su repositorio local. El hecho de que no recuerde haber realizado ninguna edición en el navegador no significa que no lo haya hecho. Hazme reír.\nRealiza un pull primero. Resuelve cualquier conflicto. Luego intenta realizar un push nuevamente.",
    "crumbs": [
      "Conectar Git, GitHub, RStudio",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>RStudio, Git, GitHub Hell</span>"
    ]
  },
  {
    "objectID": "connect-troubleshooting.html#rstudio-no-pone-ciertos-archivos-a-disposición-de-stagingcommitting",
    "href": "connect-troubleshooting.html#rstudio-no-pone-ciertos-archivos-a-disposición-de-stagingcommitting",
    "title": "14  RStudio, Git, GitHub Hell",
    "section": "14.7 RStudio no pone ciertos archivos a disposición de staging/committing",
    "text": "14.7 RStudio no pone ciertos archivos a disposición de staging/committing\n¿Tiene un espacio en su directorio o nombres de archivos? Un espacio en el nombre de un archivo es un espacio en tu alma Deshazte de él.\n¿Está su repositorio Git/Proyecto RStudio dentro de una carpeta que… eventualmente se acumula en Google Drive, DropBox, Microsoft OneDrive o una unidad de red? En caso afirmativo, le recomiendo que mueva el repositorio/Proyecto a un directorio antiguo y simple que se encuentre directamente en su computadora y que no esté administrado, por ejemplo, por Google Drive.\nSi no puede abordar las dos causas fundamentales identificadas anteriormente, entonces es posible que un cliente Git más potente (Chapter 8) pueda hacer frente a estas situaciones. Pero no hago ninguna promesa. También deberías probar las operaciones de Git desde la línea de comandos.",
    "crumbs": [
      "Conectar Git, GitHub, RStudio",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>RStudio, Git, GitHub Hell</span>"
    ]
  },
  {
    "objectID": "connect-troubleshooting.html#he-oído-que-tienes-algún-repositorio-de-git-dentro-de-tu-repositorio-de-git.",
    "href": "connect-troubleshooting.html#he-oído-que-tienes-algún-repositorio-de-git-dentro-de-tu-repositorio-de-git.",
    "title": "14  RStudio, Git, GitHub Hell",
    "section": "14.8 He oído que tienes algún repositorio de Git dentro de tu repositorio de Git.",
    "text": "14.8 He oído que tienes algún repositorio de Git dentro de tu repositorio de Git.\nNo cree un repositorio Git dentro de otro repositorio Git. Simplemente no lo hagas.\nSi tiene una necesidad genuina de esto, lo cual es realmente raro, la forma correcta de hacerlo es a través de submodules.\nEn STAT 545, ciertamente no necesitamos hacer esto y cuando lo hemos visto, ha sido un error. Esto ha resultado en la pérdida completa e inesperada del repositorio interno de Git. Sin duda, hubo más cosas aquí (tos, cliente de escritorio GitHub), pero el uso no estándar de los repositorios de Git hace que sea mucho más fácil cometer errores costosos.",
    "crumbs": [
      "Conectar Git, GitHub, RStudio",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>RStudio, Git, GitHub Hell</span>"
    ]
  },
  {
    "objectID": "usage-intro.html",
    "href": "usage-intro.html",
    "title": "Comience con GitHub",
    "section": "",
    "text": "Ahora que hemos verificado su configuración de Git/GitHub/RStudio, podemos hacer una demostración de los flujos de trabajo que usará para llevar su trabajo a GitHub:\n\nNuevo proyecto, GitHub primero es la forma más fácil de conseguir un proyecto funcional.\nProyecto existente, GitHub primero es una forma profundamente pragmática de llevar trabajos preexistentes a GitHub.\nProyecto existente, GitHub último es la forma más adecuada de conectar el trabajo local existente a un control remoto en GitHub, especialmente si ya existe un historial de Git.\n\nEsta parte concluye con dos flujos de trabajo específicos de R que muestran qué tan bien R Markdown (el formato) y rmarkdown (el paquete) trabajan con GitHub:\n\nPrueba R Markdown\nRenderizar un script R",
    "crumbs": [
      "Primeras victorias en GitHub",
      "Comience con GitHub"
    ]
  },
  {
    "objectID": "usage-new-project-github-first.html",
    "href": "usage-new-project-github-first.html",
    "title": "15  Nuevo proyecto, GitHub primero",
    "section": "",
    "text": "15.1 Hacer un repositorio en GitHub\nVaya a https://github.com y asegúrese de haber iniciado sesión.\nCerca de “Repositorios”, haga clic en el gran botón verde “Nuevo”. O, si está en su propia página de perfil, haga clic en “Repositorios” y luego haga clic en el gran botón verde “Nuevo”.\nCómo completar esto:\nHaga clic en el gran botón verde que dice “Crear repositorio”.\nAhora haga clic en el gran botón verde que dice “&lt;&gt; Code”.\nCopie una URL clonada a su portapapeles. Si sigue nuestro consejo predeterminado, copie la URL HTTPS. Pero si opta por SSH, asegúrese de copiar la URL de SSH.",
    "crumbs": [
      "Primeras victorias en GitHub",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Nuevo proyecto, GitHub primero</span>"
    ]
  },
  {
    "objectID": "usage-new-project-github-first.html#hacer-un-repositorio-en-github",
    "href": "usage-new-project-github-first.html#hacer-un-repositorio-en-github",
    "title": "15  Nuevo proyecto, GitHub primero",
    "section": "",
    "text": "Plantilla de repositorio: sin plantilla.\nNombre del repositorio: &lt;&lt;&gt;&gt;\n\nDescripción: &lt;&lt;&gt;&gt;\n\nPúblico.\n&lt;&lt;&gt;&gt;\n\n\n\n\n\n\n\n15.1.1 GitLab\nInicie sesión en https://gitlab.com. Haga clic en el botón “+” en la esquina superior derecha y luego en “Nuevo proyecto”.\n\nNombre del proyecto: myrepo (o lo que desees)\n\nPúblico\nSÍ Inicializar el repositorio con un README\n\nHaga clic en el gran botón verde “Crear proyecto”.\nCopie la URL de clonación HTTPS o SSH a su portapapeles mediante el botón azul “Clonar”.\n\n15.1.2 Bitbucket\nInicie sesión en https://bitbucket.org. En el panel del lado izquierdo, haga clic en el botón “+” y luego en “Repositorio” en “Crear”.\n\nNombre del repositorio: myrepo (o el que desees)\nNivel de acceso: desmarque para hacer público el repositorio.\n¿Incluir un archivo README?: seleccione “Sí, con un tutorial (para principiantes)” o “Sí, con una plantilla”.\nSistema de control de versiones: Git\n\nClick the big blue button “Create repository.”\nCopie la URL de clonación HTTPS o SSH que aparece al hacer clic en el botón azul “Clonar”. Asegúrate de eliminar el git clone... que aparece al principio.",
    "crumbs": [
      "Primeras victorias en GitHub",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Nuevo proyecto, GitHub primero</span>"
    ]
  },
  {
    "objectID": "usage-new-project-github-first.html#sec-new-rstudio-project-via-git",
    "href": "usage-new-project-github-first.html#sec-new-rstudio-project-via-git",
    "title": "15  Nuevo proyecto, GitHub primero",
    "section": "\n15.2 Nuevo proyecto RStudio a través de git clone",
    "text": "15.2 Nuevo proyecto RStudio a través de git clone\n\n\n\n\n\n\n\n\nLes presento dos formas de hacer esto:\n\nusethis::create_from_github()\nA través del IDE de RStudio\n\n(Recuerde que mostramos cómo hacer esto con la línea de comando Git en Chapter 11.)\nCuando clonas tu propio repositorio de GitHub, los dos métodos son equivalentes. En otros escenarios, especialmente fork-and-clone ((secfork-and-clone?)), creo que usethis::create_from_github() es superior, porque realiza una configuración adicional recomendada.\nElija uno de estos métodos a continuación.\n\n15.2.1 usethis::create_from_github()\n\nPuede ejecutar este comando en cualquier sesión de R. Si usa RStudio, hágalo en la consola R de cualquier instancia de RStudio.\n\nusethis::create_from_github(\n  \"https://github.com/YOU/YOUR_REPO.git\",\n  destdir = \"~/path/to/where/you/want/the/local/repo/\"\n)\n\nEl primer argumento es repo_spec y acepta la especificación del repositorio de GitHub en varias formas. En particular, puedes usar la URL que acabamos de copiar de GitHub.\nEl argumento destdir especifica el directorio principal donde desea que resida la nueva carpeta (y el repositorio local de Git). Si no especifica destdir, use este valor predeterminado en algún lugar muy visible, como su escritorio. Si desea mantener los repositorios de Git en una determinada carpeta de su computadora, puede personalizar este valor predeterminado configurando la opción usethis.destdir en su .Rprofile.\nAceptamos el comportamiento predeterminado de otros dos argumentos, rstudio y open, porque eso es lo que la mayoría de la gente querrá. Por ejemplo, para un usuario de RStudio, create_from_github() hace esto:\n\nCrea un nuevo directorio local en destdir, que contiene todas estas cosas:\n\nun directorio o carpeta en su computadora\nun repositorio Git, vinculado a un repositorio GitHub remoto\nun proyecto RStudio\n\n\nAbre una nueva instancia de RStudio en el nuevo Proyecto.\nEn ausencia de otras restricciones, sugiero que todos sus proyectos de R tengan exactamente esta configuración.\n\n15.2.2 RStudio IDE\nEn RStudio, inicie un nuevo proyecto:\n\n\nFile &gt; New Project &gt; Version Control &gt; Git. En la “URL del repositorio”, pegue la URL de su nuevo repositorio de GitHub. será algo como esto https://github.com/jennybc/myrepo.git.\nSea intencional acerca de dónde crea este proyecto.\nTe sugiero “Abrir en nueva sesión”.\nHaga clic en “Crear proyecto” para crear un nuevo directorio, que contendrá todas estas cosas:\n\nun directorio o “carpeta” en su computadora\nun repositorio Git, vinculado a un repositorio GitHub remoto\nun proyecto RStudio\n\n\nEn ausencia de otras limitaciones, sugiero que todos sus proyectos de R tengan exactamente esta configuración.\n\nEsto debería descargar el archivo README.md que creamos en GitHub en el paso anterior. Busque en el panel del explorador de archivos de RStudio el archivo README.md.\nDetrás de escena, RStudio ha hecho esto por usted:\ngit clone https://github.com/jennybc/myrepo.git\n\n15.2.3 Mira alrededor\nIndependientemente de si usó usethis o RStudio, ahora debería estar trabajando en el nuevo repositorio de Git. El git clone implícito debería descargar el archivo README.md que creamos en GitHub en el paso anterior. Busque en el panel del explorador de archivos de RStudio el archivo README.md.\nHay una gran ventaja en el flujo de trabajo “GitHub primero, luego RStudio”: el repositorio remoto de GitHub está configurado como el remoto origin para su repositorio local y su rama main local ahora está rastreando el main en GitHub. Este es un punto técnico pero importante sobre Git. La implicación práctica es que ahora está preparado para empujar y tirar. No es necesario perder el tiempo configurando controles remotos de Git y rastreando ramas en la línea de comando.\nEstamos a punto de confirmar que estamos preparados para realizar push and pulls.\n\n\nPull y push.\n\n\n15.2.4 Opcional: echar un vistazo debajo del capó\nActividad completamente opcional: use la línea de comando Git para ver de qué estamos hablando arriba, es decir, la configuración de la rama remota y de seguimiento.\ngit remote -v o git remote --verbose muestra los controles remotos que ha configurado. Así es como se ve alguien que usa HTTPS con GitHub y lo llama origin:\n~/tmp/myrepo % git remote -v\norigin  https://github.com/jennybc/myrepo.git (fetch)\norigin  https://github.com/jennybc/myrepo.git (push)\ngit branch -vv imprime información sobre la rama actual (-vv para “muy detallado”, supongo). En particular, podemos ver que el main local está rastreando la rama main en origin, también conocido como origin/main.\n~/tmp/myrepo % git branch -vv\n* main 2899c91 [origin/main] A commit from my local computer\nFinalmente, git remote show origin ofrece otra visión de información útil sobre ramas y remotos:\n~/tmp/myrepo % git remote show origin    \n* remote origin\n  Fetch URL: https://github.com/jennybc/myrepo.git\n  Push  URL: https://github.com/jennybc/myrepo.git\n  HEAD branch: main\n  Remote branch:\n    main tracked\n  Local branch configured for 'git pull':\n    main merges with remote main\n  Local ref configured for 'git push':\n    main pushes to main (up to date)\ngit clone, que RStudio hizo por nosotros, configura todo esto automáticamente. Es por eso que “Primero GitHub, luego RStudio” es la forma preferida de iniciar proyectos temprano en su vida de Git/GitHub.",
    "crumbs": [
      "Primeras victorias en GitHub",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Nuevo proyecto, GitHub primero</span>"
    ]
  },
  {
    "objectID": "usage-new-project-github-first.html#realizar-cambios-locales-guardar-confirmar",
    "href": "usage-new-project-github-first.html#realizar-cambios-locales-guardar-confirmar",
    "title": "15  Nuevo proyecto, GitHub primero",
    "section": "\n15.3 Realizar cambios locales, guardar, confirmar",
    "text": "15.3 Realizar cambios locales, guardar, confirmar\nHaga esto cada vez que termine una parte valiosa del trabajo, probablemente muchas veces al día.\nDesde RStudio, modifique el archivo README.md, por ejemplo, agregando la línea “Esta es una línea de RStudio”. Guarde sus cambios.\nConfirme estos cambios en su repositorio local. ¿Cómo?\n\nHaga clic en la pestaña “Git” en el panel superior derecho\nMarque la casilla “Staged” para cualquier archivo cuya existencia o modificaciones desee confirmar.\n\nPara ver más detalles sobre los cambios en el archivo desde la última confirmación, haga clic en “Diff” para ver una ventana emergente de Git.\n\n\nSi aún no estás en la ventana emergente de Git, haz clic en “Commit”.\nEscriba un mensaje en “Commit message”, como “Commit from RStudio”.\nHaga clic en “Commit”",
    "crumbs": [
      "Primeras victorias en GitHub",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Nuevo proyecto, GitHub primero</span>"
    ]
  },
  {
    "objectID": "usage-new-project-github-first.html#envía-tus-cambios-locales-a-github",
    "href": "usage-new-project-github-first.html#envía-tus-cambios-locales-a-github",
    "title": "15  Nuevo proyecto, GitHub primero",
    "section": "\n15.4 Envía tus cambios locales a GitHub",
    "text": "15.4 Envía tus cambios locales a GitHub\nHaga esto varias veces al día, pero posiblemente con menos frecuencia de lo que se compromete.\nTiene un nuevo trabajo en su repositorio Git local, pero los cambios aún no están en línea.\nEsto parecerá contradictorio, pero primero detengámonos y salgamos de GitHub.\n¿Por qué? ¡Establece este hábito para el futuro! Si realiza cambios en el repositorio en el navegador o desde otra máquina o (un día) un colaborador lo ha enviado, estará más feliz si realiza esos cambios antes de intentar enviar.\nHaga clic en el botón azul “Pull” en la pestaña “Git” en RStudio. Dudo que suceda algo, es decir, recibirás el mensaje “Already up-to-date”. Esto es sólo para establecer un hábito.\nHaga clic en el botón verde “Push” para enviar sus cambios locales a GitHub. RStudio informará algo como esto:\n&gt;&gt;&gt; /usr/bin/git push origin HEAD:refs/heads/main\nTo https://github.com/jennybc/myrepo.git\n   2899c91..b34cade  HEAD -&gt; main",
    "crumbs": [
      "Primeras victorias en GitHub",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Nuevo proyecto, GitHub primero</span>"
    ]
  },
  {
    "objectID": "usage-new-project-github-first.html#confirmar-el-cambio-local-propagado-al-control-remoto-de-github",
    "href": "usage-new-project-github-first.html#confirmar-el-cambio-local-propagado-al-control-remoto-de-github",
    "title": "15  Nuevo proyecto, GitHub primero",
    "section": "\n15.5 Confirmar el cambio local propagado al control remoto de GitHub",
    "text": "15.5 Confirmar el cambio local propagado al control remoto de GitHub\nVuelve al navegador. Supongo que todavía estamos viendo su nuevo repositorio de GitHub.\nActualizar.\nDeberías ver el nuevo “Esta es una línea de RStudio” en el archivo README.\nSi hace clic en “commit”, debería ver uno con el mensaje “Commit from RStudio”.",
    "crumbs": [
      "Primeras victorias en GitHub",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Nuevo proyecto, GitHub primero</span>"
    ]
  },
  {
    "objectID": "usage-new-project-github-first.html#haz-un-cambio-en-github",
    "href": "usage-new-project-github-first.html#haz-un-cambio-en-github",
    "title": "15  Nuevo proyecto, GitHub primero",
    "section": "\n15.6 Haz un cambio en GitHub",
    "text": "15.6 Haz un cambio en GitHub\nHaga clic en README.md en la lista de archivos en GitHub.\nEn la esquina superior derecha, haga clic en el lápiz para “Editar este archivo”.\nAgregue una línea a este archivo, como “Línea agregada desde GitHub”.\nEdite el mensaje de commit en “Confirmar cambios” o acepte el valor predeterminado.\nHaga clic en el gran botón verde “Confirmar cambios”.\n\n15.6.1 GitLab\nHaga clic en README.md en la lista de archivos en GitLab.\nEn la esquina superior derecha, haga clic en “Editar”.\nAgregue una línea a este archivo, como “Línea agregada desde GitLab”.\nEdite el mensaje de confirmación en “Confirmar cambios” o acepte el valor predeterminado.\nHaga clic en el gran botón verde “Confirmar cambios”.\n\n15.6.2 Bitbucket\nHaga clic en README.md en la lista de archivos de Bitbucket.\nEn la esquina superior derecha, haga clic en “Editar”.\nAgregue una línea a este archivo, como “Línea agregada desde Bitbucket”.\nHaga clic en el botón azul “Confirmar”. Aparecerá una ventana emergente. Edite el mensaje de confirmación o acepte el valor predeterminado.\nHaga clic en el botón azul “Confirmar”.",
    "crumbs": [
      "Primeras victorias en GitHub",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Nuevo proyecto, GitHub primero</span>"
    ]
  },
  {
    "objectID": "usage-new-project-github-first.html#extraer-de-github",
    "href": "usage-new-project-github-first.html#extraer-de-github",
    "title": "15  Nuevo proyecto, GitHub primero",
    "section": "\n15.7 Extraer de GitHub",
    "text": "15.7 Extraer de GitHub\nDe vuelta en RStudio localmente…\nInspeccione su README.md. NO debería tener la línea “Línea agregada desde GitHub”. Debe quedar como lo dejaste. Comprueba eso.\nHaga clic en el botón azul Pull.\nMire README.md nuevamente. Ahora deberías ver la nueva línea allí.",
    "crumbs": [
      "Primeras victorias en GitHub",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Nuevo proyecto, GitHub primero</span>"
    ]
  },
  {
    "objectID": "usage-new-project-github-first.html#el-fin",
    "href": "usage-new-project-github-first.html#el-fin",
    "title": "15  Nuevo proyecto, GitHub primero",
    "section": "\n15.8 El fin",
    "text": "15.8 El fin\nAhora simplemente “haga espuma, enjuague, repita”. Trabaje en algún lugar: localmente o en GitHub. Confirme los cambios. Envielos o importelos, dependiendo de dónde haya realizado el trabajo, pero “sincronice” local y remoto. Repetir.\nTenga en cuenta que, en general (y especialmente en el futuro, cuando colabore con otros desarrolladores), normalmente necesitará importar cambios desde el control remoto (GitHub) antes de enviar los cambios locales que ha realizado. Por esta razón, es una buena idea intentar adquirir el hábito de importar antes de intentar enviar.",
    "crumbs": [
      "Primeras victorias en GitHub",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Nuevo proyecto, GitHub primero</span>"
    ]
  },
  {
    "objectID": "usage-existing-project-github-first.html",
    "href": "usage-existing-project-github-first.html",
    "title": "16  Proyecto existente, GitHub primero",
    "section": "",
    "text": "16.1 Haga un repositorio en GitHub\nVaya a https://github.com y asegúrese de haber iniciado sesión.\nCerca de “Repositorios”, haga clic en el gran botón verde “Nuevo”. O, si está en su propia página de perfil, haga clic en “Repositorios” y luego haga clic en el gran botón verde “Nuevo”.\nCómo completar esto:\nHaga clic en el gran botón verde que dice “Crear repositorio”.\nAhora haga clic en el gran botón verde que dice “&lt;&gt; Code”.\nCopie una URL clonada a su portapapeles. Si sigue nuestro consejo predeterminado, copie la URL HTTPS. Pero si opta por SSH, asegúrese de copiar la URL de SSH.",
    "crumbs": [
      "Primeras victorias en GitHub",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>Proyecto existente, GitHub primero</span>"
    ]
  },
  {
    "objectID": "usage-existing-project-github-first.html#haga-un-repositorio-en-github",
    "href": "usage-existing-project-github-first.html#haga-un-repositorio-en-github",
    "title": "16  Proyecto existente, GitHub primero",
    "section": "",
    "text": "Plantilla de repositorio: sin plantilla.\nNombre del repositorio: &lt;&lt;&gt;&gt;\n\nDescripción: &lt;&lt;&gt;&gt;\n\nPúblico.\n&lt;&lt;&gt;&gt;",
    "crumbs": [
      "Primeras victorias en GitHub",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>Proyecto existente, GitHub primero</span>"
    ]
  },
  {
    "objectID": "usage-existing-project-github-first.html#sec-git-clone-usethis-rstudio",
    "href": "usage-existing-project-github-first.html#sec-git-clone-usethis-rstudio",
    "title": "16  Proyecto existente, GitHub primero",
    "section": "\n16.2 Nuevo proyecto RStudio a través de git clone",
    "text": "16.2 Nuevo proyecto RStudio a través de git clone\n\n\n\n\n\n\n\n\nLes presento dos formas de hacer esto:\n\nusethis::create_from_github()\nA través del IDE de RStudio\n\n(Recuerde que mostramos cómo hacer esto con la línea de comando Git en Chapter 11.)\nCuando clonas tu propio repositorio de GitHub, los dos métodos son equivalentes. En otros escenarios, especialmente fork-and-clone ((secfork-and-clone?)), creo que usethis::create_from_github() es superior, porque realiza una configuración adicional recomendada.\nElija uno de estos métodos a continuación.\n\n16.2.1 usethis::create_from_github()\n\nPuede ejecutar este comando en cualquier sesión de R. Si usa RStudio, hágalo en la consola R de cualquier instancia de RStudio.\n\nusethis::create_from_github(\n  \"https://github.com/YOU/YOUR_REPO.git\",\n  destdir = \"~/path/to/where/you/want/the/local/repo/\"\n)\n\nEl primer argumento es repo_spec y acepta la especificación del repositorio de GitHub en varias formas. En particular, puedes usar la URL que acabamos de copiar de GitHub.\nEl argumento destdir especifica el directorio principal donde desea que resida la nueva carpeta (y el repositorio local de Git). Si no especifica destdir, use este valor predeterminado en algún lugar muy visible, como su escritorio. Si desea mantener los repositorios de Git en una determinada carpeta de su computadora, puede personalizar este valor predeterminado configurando la opción usethis.destdir en su .Rprofile.\nAceptamos el comportamiento predeterminado de otros dos argumentos, rstudio y open, porque eso es lo que la mayoría de la gente querrá. Por ejemplo, para un usuario de RStudio, create_from_github() hace esto:\n\nCrea un nuevo directorio local en destdir, que contiene todas estas cosas:\n\nun directorio o carpeta en su computadora\nun repositorio Git, vinculado a un repositorio GitHub remoto\nun proyecto RStudio\n\n\nAbre una nueva instancia de RStudio en el nuevo Proyecto.\nEn ausencia de otras restricciones, sugiero que todos sus proyectos de R tengan exactamente esta configuración.\n\n16.2.2 RStudio IDE\nEn RStudio, inicie un nuevo proyecto:\n\n\nFile &gt; New Project &gt; Version Control &gt; Git. En la “URL del repositorio”, pegue la URL de su nuevo repositorio de GitHub. será algo como esto https://github.com/jennybc/myrepo.git.\nSea intencional acerca de dónde crea este proyecto.\nTe sugiero “Abrir en nueva sesión”.\nHaga clic en “Crear proyecto” para crear un nuevo directorio, que contendrá todas estas cosas:\n\nun directorio o “carpeta” en su computadora\nun repositorio Git, vinculado a un repositorio GitHub remoto\nun proyecto RStudio\n\n\nEn ausencia de otras limitaciones, sugiero que todos sus proyectos de R tengan exactamente esta configuración.\n\nEsto debería descargar el archivo README.md que creamos en GitHub en el paso anterior. Busque en el panel del explorador de archivos de RStudio el archivo README.md.\nDetrás de escena, RStudio ha hecho esto por usted:\ngit clone https://github.com/jennybc/myrepo.git",
    "crumbs": [
      "Primeras victorias en GitHub",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>Proyecto existente, GitHub primero</span>"
    ]
  },
  {
    "objectID": "usage-existing-project-github-first.html#traiga-su-proyecto-existente",
    "href": "usage-existing-project-github-first.html#traiga-su-proyecto-existente",
    "title": "16  Proyecto existente, GitHub primero",
    "section": "\n16.3 Traiga su proyecto existente",
    "text": "16.3 Traiga su proyecto existente\nUtilizando su método favorito para mover o copiar archivos, copie los archivos que constituyen su proyecto existente en el directorio de este nuevo proyecto.\nEn RStudio, consulte el panel de Git y el explorador de archivos.\n\n¿Estás viendo todos los archivos? Deberían estar aquí si su movimiento/copia fue exitoso.\n¿Aparecen en el panel de Git con signos de interrogación? Deberían aparecer como archivos nuevos sin seguimiento.",
    "crumbs": [
      "Primeras victorias en GitHub",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>Proyecto existente, GitHub primero</span>"
    ]
  },
  {
    "objectID": "usage-existing-project-github-first.html#verificar-y-confirmar",
    "href": "usage-existing-project-github-first.html#verificar-y-confirmar",
    "title": "16  Proyecto existente, GitHub primero",
    "section": "\n16.4 Verificar y confirmar",
    "text": "16.4 Verificar y confirmar\nConfirme sus archivos en este repositorio. ¿Cómo?\n\nHaga clic en la pestaña “Git” en el panel superior derecho\nMarque la casilla “Staged” para todos los archivos que desee confirmar.\n\nPredeterminado: verificado.\nCuándo reconsiderarlo: todo esto irá a GitHub. Considere si eso es apropiado para cada archivo. Puedes conservar absolutamente un archivo localmente, sin enviarlo al repositorio de Git y enviarlo a GitHub. Simplemente déjelo ahí en su panel de Git, sin que esté preparado. No se hará ningún daño. Si se trata de una situación a largo plazo, incluya el archivo en .gitignore.\n\n\nSi aún no estás en la ventana emergente de Git, haz clic en “Commit”.\nEscriba un mensaje en “Commit message”, como “Iniciar proyecto XYZ”.\nHaga clic en “Commit”",
    "crumbs": [
      "Primeras victorias en GitHub",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>Proyecto existente, GitHub primero</span>"
    ]
  },
  {
    "objectID": "usage-existing-project-github-first.html#envía-tus-cambios-locales-a-github",
    "href": "usage-existing-project-github-first.html#envía-tus-cambios-locales-a-github",
    "title": "16  Proyecto existente, GitHub primero",
    "section": "\n16.5 Envía tus cambios locales a GitHub",
    "text": "16.5 Envía tus cambios locales a GitHub\nHaga clic en el botón verde “Push” para enviar sus cambios locales a GitHub. RStudio mostrará algo como:\n&gt;&gt;&gt; /usr/bin/git push origin HEAD:refs/heads/main\nTo https://github.com/jennybc/myrepo.git\n   3a2171f..6d58539  HEAD -&gt; main",
    "crumbs": [
      "Primeras victorias en GitHub",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>Proyecto existente, GitHub primero</span>"
    ]
  },
  {
    "objectID": "usage-existing-project-github-first.html#confirmar-el-cambio-local-propagado-al-control-remoto-de-github",
    "href": "usage-existing-project-github-first.html#confirmar-el-cambio-local-propagado-al-control-remoto-de-github",
    "title": "16  Proyecto existente, GitHub primero",
    "section": "\n16.6 Confirmar el cambio local propagado al control remoto de GitHub",
    "text": "16.6 Confirmar el cambio local propagado al control remoto de GitHub\nVuelve al navegador. Supongo que todavía estamos viendo su nuevo repositorio de GitHub.\nActualice.\nDeberías ver todos los archivos del proyecto que confirmaste allí.\nSi hace clic en “commit”, debería ver uno con el mensaje que utilizó, p. “Iniciar proyecto XYZ”.",
    "crumbs": [
      "Primeras victorias en GitHub",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>Proyecto existente, GitHub primero</span>"
    ]
  },
  {
    "objectID": "usage-existing-project-github-first.html#el-fin",
    "href": "usage-existing-project-github-first.html#el-fin",
    "title": "16  Proyecto existente, GitHub primero",
    "section": "\n16.7 El fin",
    "text": "16.7 El fin\nAhora simplemente “haga espuma, enjuague, repita”. Trabaje en algún lugar: localmente o en GitHub. Confirme los cambios. Envielos o importelos, dependiendo de dónde haya realizado el trabajo, pero “sincronice” local y remoto. Repetir.\nTenga en cuenta que, en general (y especialmente en el futuro, cuando colabore con otros desarrolladores), normalmente necesitará importar cambios desde el control remoto (GitHub) antes de enviar los cambios locales que ha realizado. Por esta razón, es una buena idea intentar adquirir el hábito de importar antes de intentar enviar.",
    "crumbs": [
      "Primeras victorias en GitHub",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>Proyecto existente, GitHub primero</span>"
    ]
  },
  {
    "objectID": "usage-existing-project-github-last.html",
    "href": "usage-existing-project-github-last.html",
    "title": "17  Proyecto existente, GitHub último",
    "section": "",
    "text": "17.1 Preparar el proyecto local.\nAsumimos que tiene su proyecto R existente aislado en un directorio de su computadora. Si eso aún no es cierto, hazlo así. Cree un directorio y reúna allí todos los datos y scripts R existentes. Realmente no importa dónde hagas esto, pero ten en cuenta dónde se encuentra actualmente el proyecto.\nLe animo a que convierta este proyecto en un proyecto de RStudio, aunque no es absolutamente necesario. Si opta por no participar en esto, las instrucciones que usan la línea de comando Git o usethis seguirán funcionando para usted, fuera de RStudio.",
    "crumbs": [
      "Primeras victorias en GitHub",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>Proyecto existente, GitHub último</span>"
    ]
  },
  {
    "objectID": "usage-existing-project-github-last.html#preparar-el-proyecto-local.",
    "href": "usage-existing-project-github-last.html#preparar-el-proyecto-local.",
    "title": "17  Proyecto existente, GitHub último",
    "section": "",
    "text": "17.1.1 Realizar o verificar un Proyecto RStudio\nSi el proyecto aún no es un proyecto RStudio, hágalo así:\n\nDentro de RStudio puedes hacer: File &gt; New Project &gt; Existing Directory y, si lo deseas, “Abrir en nueva sesión”.\nAlternativamente, desde R, llame usethis::create_project(\"path/to/your/project\"), sustituyendo la ruta al directorio de su proyecto existente.\n\nSi su proyecto ya es un proyecto RStudio, ejecútelo.\n\n17.1.2 Crear o verificar un repositorio de Git\nDeberías estar en RStudio ahora, en tu proyecto.\n¿Ya es un repositorio de Git? La presencia del panel Git debería alertarte. Si es así, ya está.\nSi no, tienes varias opciones:\n\nEn la consola R, llame usethis::use_git().\nEn RStudio, vaya a Tools &gt; Project Options … &gt; Git/SVN. En “Sistema de control de versiones”, seleccione “Git”. ¿Confirmar el nuevo repositorio de Git? ¡Sí!\nEn el shell, con el directorio de trabajo configurado en el directorio del proyecto, haga git init.\n\nSi usó usethis o RStudio para inicializar el repositorio de Git, el proyecto debería reiniciarse en RStudio. Hágalo usted mismo si hizo git init. RStudio ahora debería tener un panel Git.",
    "crumbs": [
      "Primeras victorias en GitHub",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>Proyecto existente, GitHub último</span>"
    ]
  },
  {
    "objectID": "usage-existing-project-github-last.html#escenificar-y-comprometerse",
    "href": "usage-existing-project-github-last.html#escenificar-y-comprometerse",
    "title": "17  Proyecto existente, GitHub último",
    "section": "\n17.2 Escenificar y comprometerse",
    "text": "17.2 Escenificar y comprometerse\nSi su proyecto local ya era un repositorio de Git y estaba actualizado, continúe. De lo contrario, probablemente necesites preparar y comprometerte.\n\nHaga clic en la pestaña “Git” en el panel superior derecho\nMarque la casilla “Staged” para todos los archivos que desee confirmar.\n\nPredeterminado: organizar todo\nCuándo hacer lo contrario: todo esto irá a GitHub. Así que considere si eso es apropiado para cada archivo. Puedes conservar absolutamente un archivo localmente, sin enviarlo al repositorio de Git y enviarlo a GitHub. Simplemente déjelo reposar en su panel Git, sin que esté preparado. No se hará ningún daño. Si se trata de una situación a largo plazo, incluya el archivo en .gitignore.\n\n\nSi aún no estás en la ventana emergente de Git, haz clic en “Commit”\nEscribe un mensaje en “Commit message”.\nHaga click en “Commit”",
    "crumbs": [
      "Primeras victorias en GitHub",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>Proyecto existente, GitHub último</span>"
    ]
  },
  {
    "objectID": "usage-existing-project-github-last.html#crear-y-conectar-un-repositorio-de-github",
    "href": "usage-existing-project-github-last.html#crear-y-conectar-un-repositorio-de-github",
    "title": "17  Proyecto existente, GitHub último",
    "section": "\n17.3 Crear y conectar un repositorio de GitHub",
    "text": "17.3 Crear y conectar un repositorio de GitHub\nMostraremos algunos métodos para crear un nuevo repositorio de GitHub y conectarlo a su repositorio local. Elegir uno.\n\n17.3.1 Cree y conecte un repositorio de GitHub con usethis\nPara utilizar usethis para esta tarea, debe haber configurado un token de acceso personal (PAT). Esto ya estará configurado para cualquiera que use HTTPS como protocolo, porque ya están usando PAT para autenticarse para otras operaciones de Git. Pero si eres una persona SSH, necesitarás configurar un PAT, lo cual se explica en Chapter 9. Está bien tener claves PAT y SSH.\nEn su proyecto, en la Consola R, llame a:\n\nusethis::use_github()\n#&gt; ✓ Creating GitHub repository 'jennybc/myrepo'\n#&gt; ✓ Setting remote 'origin' to 'https://github.com/jennybc/myrepo.git'\n#&gt; ✓ Pushing 'main' branch to GitHub and setting 'origin/main' as upstream branch\n#&gt; ✓ Opening URL 'https://github.com/jennybc/myrepo'\n\n\n\n\n\nusethis::use_github() hace lo siguiente:\n\nCrea un nuevo repositorio en GitHub.\nConfigura ese nuevo repositorio como el remoto origin para el repositorio local.\nConfigura tu rama local predeterminada (por ejemplo, main) para rastrear la misma en origin y realiza un envío inicial.\nAbre el nuevo repositorio en tu navegador.\n\n17.3.2 Cree y conecte un repositorio de GitHub sin usar esto\nPrimero, necesitas crear un nuevo repositorio en GitHub.\nVaya a https://github.com y asegúrese de haber iniciado sesión.\nCerca de “Repositorios”, haga clic en el gran botón verde “Nuevo”. O, si está en su propia página de perfil, haga clic en “Repositorios” y luego haga clic en el gran botón verde “Nuevo”.\nCómo completar esto:\n\nPlantilla de repositorio: sin plantilla.\nNombre del repositorio: &lt;&lt;&gt;&gt;\n\nDescripción: &lt;&lt;&gt;&gt;\n\nPúblico.\n&lt;&lt;&gt;&gt;\n\n\nHaga clic en el gran botón verde que dice “Crear repositorio”.\nAhora haga clic en el gran botón verde que dice “&lt;&gt; Code”.\nCopie una URL clonada a su portapapeles. Si sigue nuestro consejo predeterminado, copie la URL HTTPS. Pero si opta por SSH, asegúrese de copiar la URL de SSH.\n\n\n\n\n\n\n\n\n\n17.3.2.1 Conecte el repositorio local al repositorio de GitHub con RStudio\nHaga clic en “dos cuadros morados y un cuadrado blanco” en el panel de Git. Haga clic en “Add remote”. Pegue aquí la URL del repositorio de GitHub y elija un nombre remoto, casi con seguridad origin. Ahora “Add”.\nDeberíamos volver al cuadro de diálogo “New branch” (si no, haga clic nuevamente en “dos cuadros morados y un cuadrado blanco” en el panel de Git). Supongo que estás en la rama main y quieres que rastree main en GitHub (o cualquier rama predeterminada que estés usando). Ingrese main como nombre de la rama y asegúrese de que “Sync branch with remote” esté marcado. Haga clic en “Create” (sí, aunque la rama ya existe). En el siguiente cuadro de diálogo, elija “overwrite”.\n\n17.3.2.2 Conecte el repositorio local al repositorio de GitHub con la línea de comando\nEn un shell, haz esto, sustituyendo tu URL:\ngit remote add origin https://github.com/jennybc/myrepo.git\nEnvie y consolide la relación de seguimiento entre su rama main local y main en GitHub (o como se llame su rama predeterminada):\ngit push --set-upstream origin main",
    "crumbs": [
      "Primeras victorias en GitHub",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>Proyecto existente, GitHub último</span>"
    ]
  },
  {
    "objectID": "usage-existing-project-github-last.html#confirme-los-archivos-locales-propagados-al-control-remoto-de-github",
    "href": "usage-existing-project-github-last.html#confirme-los-archivos-locales-propagados-al-control-remoto-de-github",
    "title": "17  Proyecto existente, GitHub último",
    "section": "\n17.4 Confirme los archivos locales propagados al control remoto de GitHub",
    "text": "17.4 Confirme los archivos locales propagados al control remoto de GitHub\nVuelve al navegador. Supongo que todavía estamos viendo su nuevo repositorio de GitHub.\nActualizar.\nDeberías ver todos los archivos del proyecto que confirmaste allí.\nSi este proyecto ya tenía un historial de Git, debería reflejarse en GitHub.",
    "crumbs": [
      "Primeras victorias en GitHub",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>Proyecto existente, GitHub último</span>"
    ]
  },
  {
    "objectID": "usage-existing-project-github-last.html#el-fin",
    "href": "usage-existing-project-github-last.html#el-fin",
    "title": "17  Proyecto existente, GitHub último",
    "section": "\n17.5 El fin",
    "text": "17.5 El fin\nAhora simplemente “haga espuma, enjuague, repita”. Trabaje en algún lugar: localmente o en GitHub. Confirme los cambios. Envielos o importelos, dependiendo de dónde haya realizado el trabajo, pero “sincronice” local y remoto. Repetir.\nTenga en cuenta que, en general (y especialmente en el futuro, cuando colabore con otros desarrolladores), normalmente necesitará importar cambios desde el control remoto (GitHub) antes de enviar los cambios locales que ha realizado. Por esta razón, es una buena idea intentar adquirir el hábito de importar antes de intentar enviar.",
    "crumbs": [
      "Primeras victorias en GitHub",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>Proyecto existente, GitHub último</span>"
    ]
  },
  {
    "objectID": "usage-rmd-and-github.html",
    "href": "usage-rmd-and-github.html",
    "title": "18  Prueba de R Markdown",
    "section": "",
    "text": "18.1 Hola Mundo\nPracticaremos con el documento estándar R Markdown de RStudio.\nInicie RStudio en un proyecto que sea un repositorio de Git que esté conectado a un repositorio de GitHub.\nAquí estamos modelando “caminar antes de correr”. Es mejor aumentar la complejidad en pequeños incrementos. Probamos la capacidad de nuestro sistema para representar el “hola mundo” de los documentos de R Markdown antes de enturbiar las aguas con nuestros documentos, que probablemente tienen errores.\nHaz esto: File &gt; New File &gt; R Markdown …\nGuarde este documento en un nombre de archivo y ubicación razonables. El nombre del archivo debe terminar en .Rmd o .rmd. Guarde en el nivel superior de este proyecto RStudio y en el repositorio Git, que también es el directorio de trabajo actual. Confía en mí y hazlo por un tiempo.\nQuizás quieras realizar un commit en este punto. Eso te ayudará a ver exactamente qué está sucediendo con tus archivos, porque aparecerá como una “diferencia” en el panel de Git. Hacer que los cambios sean muy visibles es uno de los grandes beneficios de usar Git.\nHaga clic en “Knit HTML” o haga File &gt; Knit Document. RStudio debería mostrar una vista previa del HTML resultante. Mire también el explorador de archivos. Debería ver el documento original de R Markdown, es decir, foo.Rmd Y el HTML resultante foo.html.\nFelicitaciones, acaba de realizar su primer informe reproducible con R Markdown.\nEste es otro buen momento para realizar cambios.",
    "crumbs": [
      "Primeras victorias en GitHub",
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>Prueba de R Markdown</span>"
    ]
  },
  {
    "objectID": "usage-rmd-and-github.html#hola-mundo",
    "href": "usage-rmd-and-github.html#hola-mundo",
    "title": "18  Prueba de R Markdown",
    "section": "",
    "text": "Ponle un título informativo. Esto aparecerá en el documento pero no necesariamente tiene nada que ver con el nombre del archivo. ¡Pero el título y el nombre del archivo deberían estar relacionados! ¿Por qué confundirse? El título es para ojos humanos, por lo que puede contener espacios y puntuación. El nombre del archivo es para humanos y computadoras, por lo que debe tener palabras similares, pero sin espacios ni puntuación.\nAcepte el Autor predeterminado o edítelo si lo desea.\nAcepte el formato de salida predeterminado de HTML.\nHaga clic en Aceptar.",
    "crumbs": [
      "Primeras victorias en GitHub",
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>Prueba de R Markdown</span>"
    ]
  },
  {
    "objectID": "usage-rmd-and-github.html#enviar-a-github",
    "href": "usage-rmd-and-github.html#enviar-a-github",
    "title": "18  Prueba de R Markdown",
    "section": "18.2 Enviar a GitHub",
    "text": "18.2 Enviar a GitHub\nEnvíe el estado actual a GitHub.\nVe a visitarlo en el navegador.\n¿Ves los nuevos archivos? ¿Un documento R Markdown y el HTML asociado? Visita ambos en el navegador. Verifica esto:\n\nRmd es bastante legible. Pero el resultado obviamente no está ahí.\nHTML es feo.",
    "crumbs": [
      "Primeras victorias en GitHub",
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>Prueba de R Markdown</span>"
    ]
  },
  {
    "objectID": "usage-rmd-and-github.html#formato-de-salida",
    "href": "usage-rmd-and-github.html#formato-de-salida",
    "title": "18  Prueba de R Markdown",
    "section": "18.3 Formato de salida",
    "text": "18.3 Formato de salida\n¿Realmente quieres HTML? ¿Solo quieres HTML? ¿Estás absolutamente seguro? Si es así, ¡puedes saltarte este paso!\nEl proceso mágico que convierte tu R Markdown en HTML es el siguiente:\nfoo.Rmd --&gt; foo.md --&gt; foo.html\nTenga en cuenta el markdow, foo.md. De forma predeterminada, RStudio descarta esto, ¡pero es posible que desees conservar ese archivo markdow!\n¿Por qué? GitHub brinda un tratamiento muy especial a los archivos markdow. Se representan casi como HTML. Esto es genial porque conserva todos los encantos del texto plano, pero te ofrece una pseudopágina web gratuita cuando visitas el archivo en el navegador. Por el contrario, HTML se representa como texto sin formato en GitHub y tendrás que tomar medidas especiales para verlo como deseas.\nEn muchos casos, solo deseas el markdown. En ese caso, cambiamos el formato de salida a github_document. Esto significa que el renderizado se verá así:\nfoo.Rmd --&gt; foo.md\ndonde foo.md es un markdown con sabor a GitHub. Si aún desea el HTML pero también el markdown intermedia, también hay una manera de solicitarlo.\nEste punto que estamos señalando sobre la importancia de los archivos .md es la razón por la que tantos paquetes R tienen un archivo NEWS.md y README.md, a menudo generados a partir de README.Rmd.\nEl formato de salida es una de las muchas cosas que podemos controlar en la parte frontal YAML de los documentos .Rmd, es decir, el texto en la parte superior de su archivo entre las líneas iniciales y finales de ---.\nPuede realizar algunos cambios en YAML a través del IDE de RStudio: haga clic en el “engranaje” en la barra superior del editor de código fuente, cerca del botón “Knit HTML”. Seleccione “Opciones de salida”, vaya a la pestaña Avanzado y marque “Mantener archivo markdown”. Su YAML ahora debería parecerse más a esto:\n---\ntitle: \"Something fascinating\"\nauthor: \"Jenny Bryan\"\ndate: \"`r format(Sys.Date())`\"\noutput:\n  html_document:\n    keep_md: true\n---\nDeberías haber obtenido la línea keep_md: true. También puedes simplemente editar el archivo tú mismo para lograrlo. El IDE solo expone una pequeña fracción de lo que es posible configurar en YAML.\nDe hecho, es necesaria una edición manual si desea mantener solo el markdown y obtener un markdown con sabor a GitHub. En ese caso, haz que tu YAML se vea así:\n---\ntitle: \"Something fascinating\"\nauthor: \"Jenny Bryan\"\ndate: \"`r format(Sys.Date())`\"\noutput: github_document\n---\n¡Guardar!\nQuizás quieras realizar un commit en este punto.\nRenderizar mediante el botón “Knit HTML”.\nAhora vuelva a visitar el explorador de archivos. Además de foo.Rmd, ahora deberías ver foo.md. Si hay fragmentos de R que forman figuras, el uso de formatos de salida de rebajas también hará que esos archivos de figuras queden en un subdirectorio con un nombre sensato, como foo_files.\nSi confirma y presiona foo.md y todo lo que está dentro de foo_files, cualquiera que tenga permiso para ver su repositorio de GitHub podrá ver una versión decente de su informe.\nSi su formato de salida es html_document, aún debería ver foo.html. Si su formato de salida es github_document y ve foo.html, eso es un resto de experimentos anteriores. Borra eso. Sólo te confundirá más tarde.\nQuizás quieras realizar un commit aquí.",
    "crumbs": [
      "Primeras victorias en GitHub",
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>Prueba de R Markdown</span>"
    ]
  },
  {
    "objectID": "usage-rmd-and-github.html#empujar-a-github",
    "href": "usage-rmd-and-github.html#empujar-a-github",
    "title": "18  Prueba de R Markdown",
    "section": "18.4 Empujar a GitHub",
    "text": "18.4 Empujar a GitHub\nEnvíe el estado actual a GitHub.\nVe a visitarlo en el navegador.\n¿Ves las modificaciones y los nuevos archivos? Su .Rmd debería modificarse, es decir, debería ver los cambios que realizó en el frontmatter de YAML. Y debería haber obtenido, al menos, el archivo de rebajas asociado, foo.md.\n\nVisite el archivo markdown y compárelo con nuestro HTML anterior.\n¿Ves cómo el markdown es mucho más útil directamente en GitHub? Interioriza esta lección.",
    "crumbs": [
      "Primeras victorias en GitHub",
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>Prueba de R Markdown</span>"
    ]
  },
  {
    "objectID": "usage-rmd-and-github.html#ponle-tu-sello",
    "href": "usage-rmd-and-github.html#ponle-tu-sello",
    "title": "18  Prueba de R Markdown",
    "section": "18.5 Ponle tu sello",
    "text": "18.5 Ponle tu sello\nSeleccione todo menos el frontmatter YAML y… ¡bórrelo!\nEscribe una sola oración.\nInserte un fragmento de R vacío, a través del menú “Chunk” en la parte superior derecha del editor de código fuente o con el método abreviado de teclado correspondiente.\n```{r, eval=TRUE}`r ''`\n## inserte su brillante código aquí\n```\nInserta de 1 a 3 líneas de código funcional que sea relevante para ti o para el proyecto donde estás experimentando. “Recorre” y ejecuta esas líneas usando el botón “Ejecutar” o el método abreviado de teclado correspondiente. ¡DEBES asegurarte de que tu código realmente funcione!\n¿Satisfecho? ¡Guarde!\nQuizás quieras realizar un commit aquí.\nAhora renderice todo el documento mediante “Knit HTML”. ¡Voilá!\nQuizás quieras realziar un commit aquí. Y enviar. Y admire su progreso en GitHub.",
    "crumbs": [
      "Primeras victorias en GitHub",
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>Prueba de R Markdown</span>"
    ]
  },
  {
    "objectID": "usage-rmd-and-github.html#desarrolla-tu-informe",
    "href": "usage-rmd-and-github.html#desarrolla-tu-informe",
    "title": "18  Prueba de R Markdown",
    "section": "18.6 Desarrolla tu informe",
    "text": "18.6 Desarrolla tu informe\nDe esta manera incremental, desarrolle su informe. Agregue código a este fragmento. Refinelo. Agrega nuevos trozos. Pero siga ejecutando el código “manualmente” para asegurarse de que realmente funcione.\nSi el código no funciona, puedo garantizarle que fallará, de una manera más espectacular y críptica, cuando se ejecute con los brazos extendidos a través de “Knit HTML” o rmarkdown::render().\nLimpie su espacio de trabajo, reinicie R y vuelva a ejecutar todo periódicamente, si las cosas se ponen raras. Hay muchos elementos de menú fragmentados y atajos de teclado para acelerar este flujo de trabajo. Represente todo el documento con frecuencia para detectar errores cuando sean fáciles de identificar y corregir. Guarde con frecuencia y confirme cada vez que llegue a un punto que desee como posición de “retroceso”.\nPronto desarrollarás tu propio mojo, pero esto debería brindarte tu primera experiencia exitosa con R Markdown.",
    "crumbs": [
      "Primeras victorias en GitHub",
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>Prueba de R Markdown</span>"
    ]
  },
  {
    "objectID": "usage-rmd-and-github.html#publica-tu-informe",
    "href": "usage-rmd-and-github.html#publica-tu-informe",
    "title": "18  Prueba de R Markdown",
    "section": "18.7 Publica tu informe",
    "text": "18.7 Publica tu informe\nSi ha estado creando HTML, puede publicarlo en algún lugar de la web, enviarlo por correo electrónico a su colaborador, lo que sea.\nPase lo que pase, técnicamente puedes publicar este informe simplemente enviando una versión renderizada a GitHub. Sin embargo, ciertas prácticas hacen que este esfuerzo de publicación sea más satisfactorio para su audiencia.\nAquí hay dos comportamientos que encuentro muy frustrantes:\n\n“Aquí está mi código. He aquí”. Esto es cuando alguien solo publica su fuente, es decir, R Markdown o código R, Y realmente quiere que otras personas aprecien su “producto”. La suposición implícita es que el público objetivo descargará todos los datos y el código y los ejecutará localmente.\n“Aquí está mi HTML. He aquí”. Esto es cuando alguien acepta la salida predeterminada solo HTML. Recuerde, los humanos no pueden leer los archivos HTML en GitHub. Por lo tanto, la suposición implícita es que el público objetivo descargará el repositorio y apuntará su navegador a este archivo HTML para poder verlo. ¿HTML en GitHub? No es legible por humanos.\n\nA veces es muy poco realista esperar que su audiencia tome las medidas adicionales descritas anteriormente. A menudo, con un cambio muy pequeño por tu parte, puedes crear un artefacto en GitHub que tu público objetivo puede apreciar de inmediato.\nCrear, confirmar y enviar markdowns (es decir, archivos .md) es una estrategia de publicación muy funcional y liviana. Utilice output: github_document o, si la salida es html_document, agregue keep_md: true. En ambos casos, es fundamental confirmar y enviar todo lo que esté dentro de foo_files, es decir, cualquier figura que se haya creado. Ahora la gente puede visitar y consumir tu trabajo en GitHub, como cualquier otra página web.\nEste es (más o menos) otro ejemplo de un principio generalmente válido, que es mantener las cosas legibles por máquinas y humanos, siempre que sea posible. Al hacer que foo.Rmd esté disponible, otros pueden ver y ejecutar su código real. Al compartir también foo.md y/o foo.html, otros pueden explorar casualmente su producto final y decidir si quieren obtener y ejecutar el código.",
    "crumbs": [
      "Primeras victorias en GitHub",
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>Prueba de R Markdown</span>"
    ]
  },
  {
    "objectID": "usage-rmd-and-github.html#html-en-github",
    "href": "usage-rmd-and-github.html#html-en-github",
    "title": "18  Prueba de R Markdown",
    "section": "18.8 HTML en GitHub",
    "text": "18.8 HTML en GitHub\nLos archivos HTML, como foo.html, no son útiles de inmediato en GitHub (aunque sus versiones locales se pueden ver fácilmente). Visita uno y verás el HTML sin formato. Qué asco. Pero hay formas de obtener una vista previa: como http://htmlpreview.github.io. Espere mucho dolor con los archivos HTML dentro de repositorios privados (de ahí las recomendaciones anteriores para enfatizar la reducción). Cuando se vuelve vital para todo el mundo ver HTML adecuado en todo su esplendor, es hora de utilizar una estrategia de publicación web más sofisticada.\nTengo más ideas generales sobre cómo hacer que un repositorio de GitHub funcione como un sitio web.",
    "crumbs": [
      "Primeras victorias en GitHub",
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>Prueba de R Markdown</span>"
    ]
  },
  {
    "objectID": "usage-rmd-and-github.html#sec-rmd-troubleshooting",
    "href": "usage-rmd-and-github.html#sec-rmd-troubleshooting",
    "title": "18  Prueba de R Markdown",
    "section": "18.9 Solución de problemas",
    "text": "18.9 Solución de problemas\nAsegúrese de que RStudio y el paquete rmarkdown (y sus dependencias) estén actualizados. En caso de una falla catastrófica al renderizar el documento estándar de R Markdown, considere que su software puede ser demasiado antiguo. Detalles sobre el sistema utilizado para representar este documento y cómo verificar su configuración:\n\nversión rmarkdown r packageVersion(\"rmarkdown\"). Usar packageVersion(\"rmarkdown\") para comprobar el tuyo.\nr R.version.string. Usar R.version.string para comprobar el tuyo.\nRStudio IDE 2021.9.0.341 (“Ghost Orchid” Preview). Use RStudio &gt; About RStudio o RStudio.Version()$version para comprobar el tuyo.\n\nDeshazte de tu .Rprofile, por lo menos temporalmente. He descubierto que un .Rprofile “maduro” que se ha acumulado al azar a lo largo de los años puede causar problemas. Específicamente, si tiene algo relacionado con knitr, markdown, rmarkdown o el propio RStudio, es posible que esté impidiendo la instalación o el uso de los beneficios más recientes. Comente todo el archivo o cámbiele el nombre a otro y reinicie o incluso reinstale RStudio.\n“Ignoré tu consejo y agregué un montón de código a la vez. Ahora mi Rmd no se procesa.” Si no puedes descubrir qué está mal leyendo los mensajes de error, elige uno:\n\nBElimine estos cambios, vuelva a un estado funcional (posiblemente sin código) y restáurelos gradualmente. Ejecute su código de forma interactiva para asegurarse de que funcione. Renderice el documento completo con frecuencia. ¡Confirme después de cada adición exitosa! Cuando vuelvas a introducir el código roto, ahora será parte de un pequeño cambio y la raíz del problema será mucho más fácil de identificar y solucionar.\nDígale a knitr que siga adelante, incluso en presencia de errores. Algunos problemas son más fáciles de diagnosticar si puede ejecutar declaraciones R específicas durante el renderizado y dejar más evidencia para el examen forense.\n\nInserta este trozo cerca de la parte superior de tu documento .Rmd:\n```{r setup, include = FALSE, cache = FALSE}`r ''`\nknitr::opts_chunk$set(error = TRUE)\n```\nSi no es deseable aceptar errores globalmente, aún puedes especificar error = TRUE para un fragmento específico como este:\n```{r wing-and-a-prayer, error = TRUE}`r ''`\n## tu código incompleto va aquí ;)\n```\n\nAdaptar la estrategia “git bisect”:\n\nColoque knitr::knit_exit() en algún lugar temprano de su documento .Rmd, ya sea en código R en línea o en un fragmento. Continúe moviéndolo antes hasta que todo funcione. Ahora muévalo hacia abajo en el documento. Con el tiempo, podrá limitar la ubicación de su código roto lo suficiente como para encontrar las líneas y solucionarlo.\n\n\nConsulta tu directorio de trabajo. Te romperá el corazón saber con qué frecuencia tus errores son realmente mundanos y básicos. Pregúntame cómo lo sé. Cuando las cosas van mal, considere:\n\n¿Qué es el directorio de trabajo?\n¿Ese archivo que quiero leer/escribir está realmente donde creo que está?\n\nColoque estos comandos en fragmentos de R para comprobar lo anterior:\n\ngetwd() mostrará el directorio de trabajo en tiempo de ejecución. Si jugó con el directorio de trabajo con, por ejemplo, el mouse, ¿tal vez esté configurado en un lugar para su desarrollo interactivo y en otro cuando “Knit HTML” se haga cargo?\nlist.files() enumerará los archivos en el directorio de trabajo. ¿El archivo que deseas está ahí?\n\nNo intente cambiar el directorio de trabajo dentro de un documento de R Markdown. Simplemente no lo hagas. Ver Preguntas frecuentes sobre knitr #5. Esos es todo.\nNo tenga prisa por crear una estructura de subdirectorios complicada. RStudio/knitr/rmarkdown (que le ofrece el botón “Knit HTML”) son bastante obstinados acerca de que el directorio de trabajo se establezca en la ubicación archivo .Rmd y sobre todos los archivos que viven juntos en un gran directorio feliz. Todo esto se puede solucionar. Por ejemplo, recomiendo el paquete here para crear rutas de archivos, una vez que necesite subdirectorios. Pero no hagas esto hasta que realmente lo necesites.",
    "crumbs": [
      "Primeras victorias en GitHub",
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>Prueba de R Markdown</span>"
    ]
  },
  {
    "objectID": "usage-r-script-and-github.html",
    "href": "usage-r-script-and-github.html",
    "title": "19  Renderizar un script R",
    "section": "",
    "text": "19.1 Transforme RMarkdown en un script R renderizable\nConsiga un archivo RMarkdown que funcione, como el que creó en su prueba de Rmd. O utilice el documento estándar .Rmd que RStudio crea con File &gt; New File &gt; R Markdown ….\nGuarde el archivo como foo.R, en lugar de foo.Rmd. Sí, por un breve momento, tendrás R Markdown guardado como un script R, pero eso no será así por mucho tiempo.\nTransforme RMarkdown a R:\nRenderice el script R a través de uno de estos métodos:\nObtendrá un informe de markdown y/o HTML, al igual que con R Markdown.\nSi tiene problemas para realizar todos los cambios necesarios y se siente frustrado, vea a continuación un ejemplo que puede copiar y pegar.\nTodos los consejos de flujo de trabajo de la prueba de Rmd se aplican aquí: cuando escriba un script de un análisis, preséntelo en markdown, confirme el .R, el .md, cualquier figura asociada y envíelo a GitHub. Los colaboradores pueden ver su código, pero también explorar los resultados sin tener que descargar y ejecutar el código. Esto hace que el estado actual de su análisis sea accesible para alguien que ni siquiera ejecuta R o que quiere echar un vistazo rápido a las cosas desde un teléfono celular o mientras está de vacaciones.",
    "crumbs": [
      "Primeras victorias en GitHub",
      "<span class='chapter-number'>19</span>  <span class='chapter-title'>Renderizar un script R</span>"
    ]
  },
  {
    "objectID": "usage-r-script-and-github.html#transforme-rmarkdown-en-un-script-r-renderizable",
    "href": "usage-r-script-and-github.html#transforme-rmarkdown-en-un-script-r-renderizable",
    "title": "19  Renderizar un script R",
    "section": "",
    "text": "¿Algo que no sea código R? ¿Te gusta el YAML y la prosa? Protégelo con comentarios estilo roxygen: comienza cada línea con #'.\n\n¿Algo que sea código R? Déjelo existir “tal cual” como código de nivel superior. Eso significa que necesitarás cambiar la sintaxis de los encabezados de fragmentos de R de esta manera:\nAntes: ```{r setup, include = FALSE}\nDespués: #+ r setup, include = FALSE\nReemplace las comillas invertidas iniciales y la llave de apertura con #+.\nEliminar la llave final.\nElimina las 3 comillas invertidas que finalizan cada fragmento.\n\n\n\n\nHaga clic en el icono “notebook” en RStudio para “Compile Report”.\nEn RStudio, haga File &gt; Knit Document.\nEn R, ejecute rmarkdown::render(\"foo.R\").",
    "crumbs": [
      "Primeras victorias en GitHub",
      "<span class='chapter-number'>19</span>  <span class='chapter-title'>Renderizar un script R</span>"
    ]
  },
  {
    "objectID": "usage-r-script-and-github.html#escribir-un-script-r-listo-para-renderizar",
    "href": "usage-r-script-and-github.html#escribir-un-script-r-listo-para-renderizar",
    "title": "19  Renderizar un script R",
    "section": "\n19.2 Escribir un script R listo para renderizar",
    "text": "19.2 Escribir un script R listo para renderizar\nEn lugar de transformar un archivo RMarkdown, creemos directamente un script R listo para renderizar.\nCree un nuevo script R y copie/pegue este código en él.\n\n#' Aquí hay algo de prosa en un comentario muy especial. Resumamos el conjunto de datos integrado `VADeaths`.\n# Aquí hay un comentario de código normal, que permanecerá como tal.\nsummary(VADeaths)\n\n#' Aquí hay algo más de prosa. Puedo usar la sintaxis habitual de Markdown para hacer cosas\n#' **negritas** o *italicas*. Usemos un ejemplo de la ayuda `dotchart()` para\n#' hacer un diagrama de puntos de Cleveland a partir de los datos de `VADeaths`. Incluso me molesto en nombrar\n#' este fragmento, entonces el PNG resultante tiene un nombre decente.\n#+ dotchart\ndotchart(VADeaths, main = \"Tasas de mortalidad en Virginia - 1940\")\n\nRenderice el script R mediante uno de estos métodos:\n\nHaga clic en el icono “notebook” en RStudio para “Compile Report”.\nEn RStudio, haz File &gt; Knit Document.\nEn R, haz rmarkdown::render(\"YOURSCRIPT.R\").\n\n¡Disfruta de tu atractivo informe casi sin esfuerzo! En serio, todo lo que tenías que hacer era pensar en cuándo usar los comentarios especiales #' para promocionarlo a un texto bien renderizado.\nBasándonos en los consejos de flujo de trabajo en Prueba de Rmd, agreguemos algo de contenido de YAML, comentado adecuadamente con #', y solicitemos github_document como formato de salida. Aquí está el guión completo nuevamente:\n\n#' ---\n#' title: \"¡Se pueden renderizar scripts R!\"\n#' output: github_document\n#' ---\n#'\n#' Aquí hay algo de prosa en un comentario muy especial. Resumamos el conjunto de datos integrado `VADeaths`.\n# Aquí hay un comentario de código normal, que permanecerá como tal.\nsummary(VADeaths)\n\n#' Aquí hay algo más de prosa. Puedo usar la sintaxis habitual de Markdown para hacer cosas\n#' **negritas** o *italicas*. Usemos un ejemplo de la ayuda `dotchart()` para\n#' hacer un diagrama de puntos de Cleveland a partir de los datos de `VADeaths`. Incluso me molesto en nombrar\n#' este fragmento, entonces el PNG resultante tiene un nombre decente.\n#+ dotchart\ndotchart(VADeaths, main = \"Tasas de mortalidad en Virginia - 1940\")\n\nAquí detrás de escena hemos usado rmarkdown::render() para representar este script y puedes ir y verlo en GitHub.",
    "crumbs": [
      "Primeras victorias en GitHub",
      "<span class='chapter-number'>19</span>  <span class='chapter-title'>Renderizar un script R</span>"
    ]
  },
  {
    "objectID": "git-intro.html",
    "href": "git-intro.html",
    "title": "Algunos conceptos básicos de Git",
    "section": "",
    "text": "¡Hasta ahora te hemos contado sorprendentemente poco sobre Git! Esto es por diseño.\nDescubrimos que el uso real, en el curso de su trabajo, es la forma más efectiva de construir un modelo mental útil para Git. En los talleres en vivo, nos esforzamos por presentar las ideas básicas más importantes en el contexto de nuestras actividades guiadas. Los autodidactas pueden lograr lo mismo si siguen las guías sobre “pilas incluidas” que aparecen anteriormente en las secciones anteriores.\nSin embargo, aprovechando este éxito inicial, ahora es el momento perfecto para definir explícitamente algo de vocabulario de Git. También queremos ayudarlo a vincular los conceptos de Git con tareas y proyectos de ciencia de datos.\nEsta parte recopila todo lo que hemos escrito sobre los conceptos básicos de Git. Es un trabajo en progreso y está concebido como un complemento a los excelentes recursos externos para Git, que no tenemos ningún deseo de reinventar.",
    "crumbs": [
      "Fundamentos de Git",
      "Algunos conceptos básicos de Git"
    ]
  },
  {
    "objectID": "git-basics.html",
    "href": "git-basics.html",
    "title": "20  Repo, commit, diff, tag",
    "section": "",
    "text": "20.1 Repos o repositorios\nGit es un sistema de control de versiones cuyo propósito original era ayudar a grupos de desarrolladores a trabajar de forma colaborativa en grandes proyectos de software. Git gestiona la evolución de un conjunto de archivos, llamado repositorio o repo, de una manera altamente estructurada. Históricamente, estos archivos habrían consistido en código fuente e instrucciones sobre cómo crear una aplicación a partir de su fuente.\nGit ha sido reutilizado por la comunidad científica de datos (Ram 2013; Bartlett 2016; Perez-Riverol et al. 2016). Lo usamos para gestionar la variada colección de archivos que componen los proyectos típicos de análisis de datos, que consisten en datos, cifras, informes y, sí, algo de código fuente.\nPara proyectos nuevos o existentes, le recomendamos que:\nEsta configuración ocurre una vez por proyecto y puede ocurrir al inicio del proyecto o en cualquier momento posterior. Es probable que sus proyectos existentes ya se encuentren en un directorio dedicado. Hacer de dicho directorio un proyecto RStudio y un repositorio Git se reduce a permitir que esas aplicaciones dejen notas en archivos o directorios ocultos. El proyecto sigue siendo un directorio normal en su computadora, que puede ubicar, nombrar, mover y, en general, interactuar con él como desee. ¡No es necesario manipularlo con guantes especiales!\nEl flujo de trabajo diario probablemente no sea dramáticamente diferente de lo que hace actualmente. Trabaja de la forma habitual, escribiendo scripts R o creando informes en LaTeX o R Markdown. Pero en lugar de guardar únicamente archivos individuales, periódicamente realiza una confirmación, que toma una instantánea de todos los archivos de todo el proyecto. Si alguna vez ha versionado un archivo agregando sus iniciales o la fecha, efectivamente ha realizado una confirmación, aunque solo para una sola archivo. Es una versión que es importante para usted y que quizás desee inspeccionar o volver a consultar más adelante. Periódicamente, envías confirmaciones a GitHub. Esto es como compartir un documento con colegas en DropBox o enviarlo como archivo adjunto de correo electrónico. Al acceder a GitHub, haces que tu trabajo y todo tu progreso acumulado sean accesibles para otros.\nEste es un cambio moderado en su flujo de trabajo diario normal. Al principio se siente extraño, pero rápidamente se convierte en algo natural. En STAT 545, los estudiantes deben enviar todos los trabajos del curso a través de GitHub, a partir de la primera semana. La mayoría nunca ha visto Git antes y no se identifican como programadores. Es un tema importante en las horas de clase y de oficina durante las dos primeras semanas. Entonces prácticamente nunca volvemos a hablar de ello.",
    "crumbs": [
      "Fundamentos de Git",
      "<span class='chapter-number'>20</span>  <span class='chapter-title'>Repo, commit, diff, tag</span>"
    ]
  },
  {
    "objectID": "git-basics.html#repos-o-repositorios",
    "href": "git-basics.html#repos-o-repositorios",
    "title": "20  Repo, commit, diff, tag",
    "section": "",
    "text": "Dedicarle un directorio o carpeta local.\nConviértalo en un proyecto RStudio. Opcional pero recomendado; obviamente solo se aplica a proyectos que involucran R y usuarios de RStudio.\nConviértelo en un repositorio Git.",
    "crumbs": [
      "Fundamentos de Git",
      "<span class='chapter-number'>20</span>  <span class='chapter-title'>Repo, commit, diff, tag</span>"
    ]
  },
  {
    "objectID": "git-basics.html#commits-diffs-y-tags",
    "href": "git-basics.html#commits-diffs-y-tags",
    "title": "20  Repo, commit, diff, tag",
    "section": "20.2 Commits, diffs, y tags",
    "text": "20.2 Commits, diffs, y tags\nAhora conectamos los conceptos fundamentales de Git con el flujo de trabajo de la ciencia de datos:\n\nrepository\ncommit\ndiff\n\nRecuerde que un repo o repositorio es solo un directorio de archivos que Git administra de manera integral. Una confirmación(commit) funciona como una instantánea de todos los archivos del repositorio, en un momento específico. En el fondo, no es así exactamente como Git implementa las cosas. Aunque los modelos mentales no tienen que ser precisos para ser útiles, en este caso ayuda alinear ambos.\n\n\n\n\n\n\nFigure 20.1: Historial de confirmaciones parciales para nuestro ejemplo de iris, destacando diferencias, mensajes de confirmación, SHA y etiquetas\n\n\n\nFigure 20.1 es una mirada a un análisis ficticio de los datos del iris, centrándose en la evolución de un guión, iris.R. Considere la versión A de este archivo y una versión modificada, la versión B. Supongamos que la versión A fue parte de una confirmación de Git y la versión B fue parte de la siguiente confirmación. El conjunto de diferencias entre A y B se llama “diff” y los usuarios de Git contemplan mucho las diferencias. La inspección de diferencias es la forma en que usted se vuelve a explicar en qué se diferencia la versión A de la versión B. La inspección de diferencias no se limita a confirmaciones adyacentes. Puede inspeccionar las diferencias entre dos confirmaciones cualesquiera.\nDe hecho, la noción de Git de cualquier versión específica de iris.R es una acumulación de diferencias. Si retrocede lo suficiente, encontrará la confirmación donde se creó el archivo en primer lugar. Git almacena cada versión posterior como esa versión inicial, más todas las diferencias intermedias en el historial que afectan el archivo. Dejaremos de lado estos detalles internos ahora, pero comprender la importancia de estos deltas hará que las operaciones de Git sean menos desconcertantes a largo plazo.\nEntonces, al observar las diferencias, es fácil ver en qué se diferencian dos instantáneas, pero ¿qué pasa con el por qué?\nCada vez que realiza una confirmación, también debe escribir un mensaje de confirmación breve. Idealmente, esto transmite la motivación para el cambio. Recuerde, la diferencia mostrará el contenido. Cuando vuelves a visitar un proyecto después de un descanso o necesitas digerir los cambios recientes realizados por un colega, mirar el historial, leer los mensajes de confirmación y hojear las diferencias, es una forma extremadamente eficiente de ponerte al día. Figure 20.1 muestra los mensajes asociados con las últimas tres confirmaciones.\nCada confirmación necesita algún tipo de apodo para que puedas identificarla. Git hace esto automáticamente, asignando a cada confirmación lo que se llama un SHA, una cadena aparentemente aleatoria de 40 letras y números (de hecho, no es aleatoria, sino que es un hash de suma de verificación SHA-1 de la confirmación). Aunque estará expuesto a estos, no es necesario que los maneje directamente con mucha frecuencia y, cuando lo hace, normalmente los primeros 7 caracteres son suficientes. Los mensajes de confirmación en Figure 20.1 tienen el prefijo SHA truncado. También puedes designar ciertas instantáneas como especiales con una etiqueta, que es el nombre que elijas. En un proyecto de software, es típico etiquetar una versión con su versión, por ejemplo, “v1.0.3”. Para un manuscrito o proyecto analítico, puede etiquetar la versión enviada a una revista o transmitida a colaboradores externos. Figure 20.1 muestra una etiqueta, “draft-01”, asociada con la última confirmación.\n\n\n\n\nBartlett, Alice. 2016. “Git for Humans.” Financial Times, London; Talk at UX Brighton. https://speakerdeck.com/alicebartlett/git-for-humans.\n\n\nPerez-Riverol, Yasset, Laurent Gatto, Rui Wang, Timo Sachsenberg, Julian Uszkoreit, Felipe da Veiga Leprevost, Christian Fufezan, et al. 2016. “Ten Simple Rules for Taking Advantage of Git and GitHub.” PLOS Computational Biology 12 (7): 1–11. https://doi.org/10.1371/journal.pcbi.1004947.\n\n\nRam, Karthik. 2013. “Git Can Facilitate Greater Reproducibility and Increased Transparency in Science.” Source Code for Biology and Medicine 8 (1): 7. https://doi.org/10.1186/1751-0473-8-7.",
    "crumbs": [
      "Fundamentos de Git",
      "<span class='chapter-number'>20</span>  <span class='chapter-title'>Repo, commit, diff, tag</span>"
    ]
  },
  {
    "objectID": "git-commands.html",
    "href": "git-commands.html",
    "title": "21  Comandos de git",
    "section": "",
    "text": "Una colección de algunos de los comandos de Git que se han estado ejecutando en gran medida bajo el capó. Hemos enfatizado los primeros flujos de trabajo que son posibles en RStudio. Pero todo esto y mucho más se puede hacer desde la línea de comandos. Esta lista está aquí principalmente para que podamos consultarla durante los talleres en vivo si es necesario.\nA menos que utilice la API de GitHub, la mayoría de los bits de GitHub realmente deben realizarse desde el navegador.\nNuevo repositorio de git local desde un repositorio en GitHub:\ngit clone https://github.com/jennybc/happy-git-with-r.git\nVerifique que el control remoto se haya clonado exitosamente:\ngit remote --verbose\nSeleccionar cambios locales, confirmar:\ngit add foo.txt\ngit commit --message \"Un mensaje de confirmación\"\nCompruebe el estado del mundo Git:\ngit status\ngit log\ngit log --oneline\nComparar versiones:\ngit diff\nAgregue un control remoto al repositorio local existente:\ngit remote add origin https://github.com/jennybc/happy-git-with-r\ngit remote --verbose\ngit remote show origin\nEnvíe el main local a GitHub main y haga que el main local rastree main en GitHub:\ngit push --set-upstream origin main\n# forma más corta\ngit push -u origin main\n# ¡solo necesitas configurar el seguimiento ascendente una vez!\nEnvío regular:\ngit push \n# lo anterior generalmente implica (y ciertamente lo hace en nuestro tutorial)\ngit push origin main\n# git push [remote-name] [branch-name]\nImportar confirmaciones desde GitHub:\ngit pull\nImportar confirmaciones y no evitar que esto le ponga en un aprieto de conflicto de fusión:\ngit pull --ff-only\nObtener confirmaciones\ngit fetch\nCambiar a una rama\ngit checkout [branch-name]\nComprobación del seguimiento remoto y de ramas\ngit remote -v\ngit remote show origin\ngit branch -vv",
    "crumbs": [
      "Fundamentos de Git",
      "<span class='chapter-number'>21</span>  <span class='chapter-title'>Comandos de git</span>"
    ]
  },
  {
    "objectID": "git-branches.html",
    "href": "git-branches.html",
    "title": "22  Ramas",
    "section": "",
    "text": "22.1 Crear una nueva rama\nPuede crear una nueva rama con git branch y luego verificar la rama con git checkout. Para distinguirlo de la corriente principal de desarrollo, presumiblemente en “principal”, lo llamaremos “rama de características”.\nTambién puedes usar el atajo git checkout -b issues-5 para crear y verificar la rama de una vez.\nUna vez que haya cambiado a una rama, puede comprometerse con ella como de costumbre.",
    "crumbs": [
      "Fundamentos de Git",
      "<span class='chapter-number'>22</span>  <span class='chapter-title'>Ramas</span>"
    ]
  },
  {
    "objectID": "git-branches.html#crear-una-nueva-rama",
    "href": "git-branches.html#crear-una-nueva-rama",
    "title": "22  Ramas",
    "section": "",
    "text": "git branch issue-5\ngit checkout issue-5",
    "crumbs": [
      "Fundamentos de Git",
      "<span class='chapter-number'>22</span>  <span class='chapter-title'>Ramas</span>"
    ]
  },
  {
    "objectID": "git-branches.html#cambiar-de-rama",
    "href": "git-branches.html#cambiar-de-rama",
    "title": "22  Ramas",
    "section": "22.2 Cambiar de rama",
    "text": "22.2 Cambiar de rama\nUsas git checkout para cambiar entre ramas.\nPero, ¿qué haces si estás trabajando en una rama y necesitas cambiar? ¿Pero el trabajo en la rama actual no está completo? Una opción es Git stash, pero generalmente una mejor opción es salvaguardar el estado actual con una confirmación temporal. Aquí utilizo “WIP” como mensaje de confirmación para indicar el trabajo en progreso.\ngit commit --all -m \"WIP\"\ngit checkout main\nLuego, cuando regreses a la rama y continúes con tu trabajo, Necesitas deshacer la confirmación temporal restableciendo tu estado. Específicamente, queremos un reinicio mixto. Este es un “directorio de trabajo seguro”, es decir, no afecta el estado de ningún archivo. Pero sí elimina el commit WIP temporal. A continuación, la referencia HEAD^ dice que se debe revertir el estado de confirmación al padre de la confirmación actual (HEAD).\ngit checkout issue-5\ngit reset HEAD^\nSi esto es difícil de recordar, o revertir el estado de confirmación a un estado anterior diferente, la referencia también se puede proporcionar como el SHA de una confirmación específica, que puede ver a través de git log. Aquí es donde creo que un cliente Git gráfico puede ser invaluable, ya que generalmente puedes hacer clic derecho en la confirmación de destino y luego seleccionar el tipo de reinicio deseado (por ejemplo, suave, mixto o duro). Este es exactamente el tipo de uso de Git intermedio a avanzado que a menudo parece más accesible en un cliente gráfico.",
    "crumbs": [
      "Fundamentos de Git",
      "<span class='chapter-number'>22</span>  <span class='chapter-title'>Ramas</span>"
    ]
  },
  {
    "objectID": "git-branches.html#fusionar-una-rama",
    "href": "git-branches.html#fusionar-una-rama",
    "title": "22  Ramas",
    "section": "22.3 Fusionar una rama",
    "text": "22.3 Fusionar una rama\nUna vez que haya hecho su trabajo y lo haya confirmado en la rama de funciones, puede volver a “principal” y fusionar la rama de funciones.\ngit checkout main\ngit merge issue-5",
    "crumbs": [
      "Fundamentos de Git",
      "<span class='chapter-number'>22</span>  <span class='chapter-title'>Ramas</span>"
    ]
  },
  {
    "objectID": "git-branches.html#lidiar-con-los-conflictos",
    "href": "git-branches.html#lidiar-con-los-conflictos",
    "title": "22  Ramas",
    "section": "22.4 Lidiar con los conflictos",
    "text": "22.4 Lidiar con los conflictos\nLa mayoría de las veces, la fusión se realizará sin problemas. Sin embargo, si ambas ramas que está fusionando cambiaron la misma parte del mismo archivo, obtendrá un conflicto de fusión.\ngit merge issue-5\n# Auto-merging index.html\n# CONFLICT (content): Merge conflict in index.html\n# Automatic merge failed; fix conflicts and then commit the result.\nLo primero que debe hacer es NO ENTRAR EN PÁNICO. Los conflictos de fusión no son el fin del mundo y la mayoría son relativamente pequeños y fáciles de resolver.\nEl primer paso para resolver un conflicto de fusión es determinar qué archivos están en conflicto, que puedes hacer con git status:\ngit status\n# On branch main\n# You have unmerged paths.\n#   (fix conflicts and run \"git commit\")\n# \n# Unmerged paths:\n#   (use \"git add &lt;file&gt;...\" to mark resolution)\n# \n#     both modified:      index.html\n# \n# no changes added to commit (use \"git add\" and/or \"git commit -a\")\nEntonces esto muestra que solo index.html no está fusionado y debe resolverse. Luego podemos abrir el archivo para ver qué líneas están en conflicto.\n&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD:index.html\n&lt;div id=\"footer\"&gt;contact : email.support@github.com&lt;/div&gt;\n=======\n&lt;div id=\"footer\"&gt;\n please contact us at support@github.com\n&lt;/div&gt;\n&gt;&gt;&gt;&gt;&gt;&gt;&gt; issue-5:index.html\nEn este conflicto, las líneas entre &lt;&lt;&lt;&lt;&lt;&lt; HEAD:index.html y ====== son el contenido de la rama en la que se encuentra actualmente. Las líneas entre ======= y &gt;&gt;&gt;&gt;&gt;&gt;&gt; issues-5:index.html son de la rama de funciones que estamos fusionando.\nPara resolver el conflicto, edite esta sección hasta que refleje el estado que desea en el resultado combinado. Elige una versión u otra o crea un híbrido. También elimine los marcadores de conflicto &lt;&lt;&lt;&lt;&lt;&lt;, ====== y &gt;&gt;&gt;&gt;&gt;&gt;.\n&lt;div id=\"footer\"&gt;\nplease contact us at email.support@github.com\n&lt;/div&gt;\nAhora ejecute git add index.html y git commit para finalizar la fusión. CONFLICTOS RESUELTOS.\n\n22.4.1 Rescate\nSi, durante la fusión, se confunde sobre el estado de las cosas o hace una error, use git merge --abort para cancelar la fusión y volver al estado antes de ejecutar git merge. Luego puedes intentar completar la fusión nuevamente.\nBifurcación y fusión de Git Basic:\nhttps://git-scm.com/book/en/v2/Git-Branching-Basic-Branching-and-Merging",
    "crumbs": [
      "Fundamentos de Git",
      "<span class='chapter-number'>22</span>  <span class='chapter-title'>Ramas</span>"
    ]
  },
  {
    "objectID": "git-remotes.html",
    "href": "git-remotes.html",
    "title": "23  Remotos",
    "section": "",
    "text": "23.1 Listar qué controles remotos existen\ngit remote enumera los nombres de los controles remotos disponibles, pero generalmente es más útil ver a qué URL corresponde cada nota (con -v).\ngit remote -v\n\norigin  https://github.com/davidrsch/hg-gh4res (fetch)\norigin  https://github.com/davidrsch/hg-gh4res (push)",
    "crumbs": [
      "Fundamentos de Git",
      "<span class='chapter-number'>23</span>  <span class='chapter-title'>Remotos</span>"
    ]
  },
  {
    "objectID": "git-remotes.html#agregar-un-nuevo-control-remoto",
    "href": "git-remotes.html#agregar-un-nuevo-control-remoto",
    "title": "23  Remotos",
    "section": "\n23.2 Agregar un nuevo control remoto",
    "text": "23.2 Agregar un nuevo control remoto\ngit clone agrega automáticamente un nuevo control remoto, por lo que a menudo no es necesario hacerlo manualmente inicialmente. Sin embargo, después de la clonación inicial, suele ser útil agregar controles remotos adicionales.\nUtilice git remote add para agregar un nuevo control remoto:\ngit remote add happygit https://github.com/jennybc/happy-git-with-r.git\nNota: cuando agregas un control remoto, le asignas un apodo (aquí happygit), que puedes usar en los comandos de git en lugar de la URL completa.\ngit fetch happygit\nBarra lateral sobre apodos: existe una fuerte convención para usar origin como apodo de su control remoto principal. En este punto, es común que el control remoto principal de un repositorio esté alojado en GitHub (o GitLab o Bitbucket). Es tentador utilizar un apodo más descriptivo (como github), pero es posible que valga la pena seguir la convención. Hace que su configuración sea más fácil de entender para otros y para que usted transfiera información que lee en la documentación, en Stack Overflow o en blogs.\nUna razón común para agregar un segundo control remoto es cuando ha realizado una “bifurcación y clonación” de un repositorio y su copia personal (su bifurcación) está configurada como el control remoto origin. Con el tiempo, querrás extraer los cambios del repositorio original. Es común utilizar upstream como apodo para este control remoto.\ngit remote add upstream https://github.com/TRUE_OWNER/REPO.git",
    "crumbs": [
      "Fundamentos de Git",
      "<span class='chapter-number'>23</span>  <span class='chapter-title'>Remotos</span>"
    ]
  },
  {
    "objectID": "git-remotes.html#obteniendo-datos-de-controles-remotos",
    "href": "git-remotes.html#obteniendo-datos-de-controles-remotos",
    "title": "23  Remotos",
    "section": "\n23.3 Obteniendo datos de controles remotos",
    "text": "23.3 Obteniendo datos de controles remotos\nPara obtener nuevos datos desde un uso remoto git fetch &lt;remote_name&gt;. Esto recupera los datos localmente, pero lo más importante es que no cambia el estado de sus archivos locales de ninguna manera. Para incorporar los datos a su repositorio, necesita fusionar o cambiar la base de su proyecto con el proyecto remoto.\n# Obtener los datos\ngit fetch happygit\n\n# Fusionar con main local\ngit merge happygit/main main\n\n# git pull es un atajo que hace lo anterior en un solo comando\ngit pull happygit main\nPara obtener más detalles sobre los flujos de trabajo git pull, consulte Chapter 29.",
    "crumbs": [
      "Fundamentos de Git",
      "<span class='chapter-number'>23</span>  <span class='chapter-title'>Remotos</span>"
    ]
  },
  {
    "objectID": "git-remotes.html#enviar-a-controles-remotos",
    "href": "git-remotes.html#enviar-a-controles-remotos",
    "title": "23  Remotos",
    "section": "\n23.4 Enviar a controles remotos",
    "text": "23.4 Enviar a controles remotos\nUtilice git push &lt;remote&gt; &lt;branch&gt; para enviar sus cambios locales a la rama &lt;branch&gt; en el control remoto &lt;remote&gt;.\n# enviar mis cambios locales a la rama principal del control remoto de origen\ngit push origin main\n\n# enviar mis cambios locales a la rama de prueba del control remoto happygit\ngit push happygit test",
    "crumbs": [
      "Fundamentos de Git",
      "<span class='chapter-number'>23</span>  <span class='chapter-title'>Remotos</span>"
    ]
  },
  {
    "objectID": "git-remotes.html#cambiar-el-nombre-y-cambiar-los-controles-remotos",
    "href": "git-remotes.html#cambiar-el-nombre-y-cambiar-los-controles-remotos",
    "title": "23  Remotos",
    "section": "\n23.5 Cambiar el nombre y cambiar los controles remotos",
    "text": "23.5 Cambiar el nombre y cambiar los controles remotos\ngit remote rename se puede utilizar para cambiar el nombre de un control remoto:\ngit remote rename happygit hg\ngit remote set-url se puede utilizar para cambiar la URL de un control remoto. Esto a veces es útil si inicialmente configuró un control remoto usando HTTPS, pero ahora desea usar SSH en su lugar (o viceversa).\ngit remote set-url happygit git@github.com:jennybc/happy-git-with-r.git\nUn flujo de trabajo bastante común es que inicialmente clonaste un repositorio en GitHub localmente (sin bifurcarlo), pero ahora quieres crear tu propia bifurcación y enviarle cambios. Como se describió anteriormente, es común llamar al repositorio de origen upstream y llamar a su bifurcación origin. Entonces, en este caso, primero debe cambiar el nombre del control remoto existente (de origin a upstream). Luego agrega tu tenedor como un nuevo control remoto, con el nombre origin.\ngit remote rename origin upstream\ngit remote add origin git@github.com:jimhester/happy-git-with-r.git",
    "crumbs": [
      "Fundamentos de Git",
      "<span class='chapter-number'>23</span>  <span class='chapter-title'>Remotos</span>"
    ]
  },
  {
    "objectID": "git-remotes.html#upstream-seguimiento-de-ramas",
    "href": "git-remotes.html#upstream-seguimiento-de-ramas",
    "title": "23  Remotos",
    "section": "\n23.6 Upstream seguimiento de ramas",
    "text": "23.6 Upstream seguimiento de ramas\nEs posible configurar la rama en el control remoto al que corresponde cada uno de sus controles remotos locales. git clone configura esto automáticamente, por lo que para tu propia rama main esto no es algo con lo que te toparás. Sin embargo, de forma predeterminada, si crea una nueva rama e intenta acceder a ella, verá algo como esto:\ngit checkout -b mybranch\ngit push\n# fatal: The current branch foo has no upstream branch.\n# To push the current branch and set the remote as upstream, use\n#\n#     git push --set-upstream origin foo\nPuede hacer lo que dice el mensaje de error y configurar explícitamente la rama upstream con --set-upstream. Sin embargo, recomendaría cambiar el comportamiento predeterminado de push para configurar automáticamente la rama upstream en la rama con el mismo nombre en el control remoto.\nPuedes hacer esto cambiando la opción git push.default a current.\ngit config --global push.default current\nConsulte también Trabajar con controles remotos:\nhttps://git-scm.com/book/en/v2/Git-Basics-Working-with-Remotes",
    "crumbs": [
      "Fundamentos de Git",
      "<span class='chapter-number'>23</span>  <span class='chapter-title'>Remotos</span>"
    ]
  },
  {
    "objectID": "git-refs.html",
    "href": "git-refs.html",
    "title": "24  Referencias",
    "section": "",
    "text": "24.1 Referencias útiles\nEstas son algunas de las referencias más útiles:\nSi desea que todo esto sea más concreto, puede usar git rev-parse en el shell para observar cómo las referencias se resuelven en SHA concretos. Aquí está el patrón general:\nAquí hay algunos ejemplos ejecutados en el repositorio Happy Git:\nObserve que HEAD y main se resuelven en el mismo SHA, ya que la rama main estaba desprotegida en ese momento. testing-something es el nombre de una rama que estaba por ahí.\nEstas referencias se pueden usar en todo tipo de operaciones de Git, como git diff, git reset y git checkout:",
    "crumbs": [
      "Fundamentos de Git",
      "<span class='chapter-number'>24</span>  <span class='chapter-title'>Referencias</span>"
    ]
  },
  {
    "objectID": "git-refs.html#referencias-útiles",
    "href": "git-refs.html#referencias-útiles",
    "title": "24  Referencias",
    "section": "",
    "text": "Un nombre de rama. Ejemplo: main, wild-experiment. Cuando te refieres a la rama main, eso se resuelve en el SHA de la punta de la rama main. Piense en una referencia de rama como una referencia deslizante que evoluciona a medida que lo hace la rama.\n\n\n\n\n\n\n\nHEAD. Esto (casi siempre) se resuelve en la punta de la rama que está actualmente desprotegida.1 Puedes pensar en HEAD como una referencia que apunta a la punta de la rama actual, que a su vez es una ref, que apunta a un SHA específico. Hay dos capas de dirección indirecta. Esto también se llama referencia simbólica.\n\n\n\n\n\n\n\nUna etiqueta. Ejemplo: v1.4.2. Las etiquetas se diferencian de las referencias de rama y de la referencia HEAD en que tienden a ser mucho más estáticas. Las etiquetas no se deslizan por naturaleza, aunque es posible reposicionar una etiqueta para que apunte a un nuevo SHA, si se hace un esfuerzo explícito. El uso más común de una etiqueta es proporcionar una etiqueta agradable para un SHA específico.\n\n\n\n\n\n\n\ngit rev-parse YOUR_REF_GOES_HERE\n\n~/rrr/happy-git-with-r % git rev-parse HEAD\n631fee855db49d87f6c2a2cab474e89c11322bf4\n\n~/rrr/happy-git-with-r % git rev-parse main\n631fee855db49d87f6c2a2cab474e89c11322bf4\n\n~/rrr/happy-git-with-r % git rev-parse testing-something                       \n1eeb91d177b7cb5f9a0b29ebee3e6c0c8ff98f88\n\n\ngit diff main testing-something\n\ngit reset testing-something -- README.md\n\ngit checkout -b my-new-branch main",
    "crumbs": [
      "Fundamentos de Git",
      "<span class='chapter-number'>24</span>  <span class='chapter-title'>Referencias</span>"
    ]
  },
  {
    "objectID": "git-refs.html#referencias-relativos",
    "href": "git-refs.html#referencias-relativos",
    "title": "24  Referencias",
    "section": "24.2 Referencias relativos",
    "text": "24.2 Referencias relativos\nTambién hay modificadores que le ayudan a especificar una confirmación relativa a una referencia, p. “la confirmación justo antes de este”.\nHEAD~1 se refiere a la confirmación justo antes de HEAD. HEAD^ es otra forma de decir exactamente lo mismo.\n\n\n\n\n\nAquí hay algunos ejemplos ejecutados en el repositorio Happy Git:\n~/rrr/happy-git-with-r % git rev-parse HEAD~1\n5dacec4950a3746310bb30704417a792302b044a\n\n~/rrr/happy-git-with-r % git rev-parse HEAD^\n5dacec4950a3746310bb30704417a792302b044a\nObserve que HEAD~1 y HEAD^ se resuelven en el mismo SHA.\nAmbos patrones se generalizan. HEAD~3 y HEAD^^^ son referencias válidas y equivalentes.\nDebo admitir que no soy un gran admirador de estos atajos de referencia relativa y especialmente cuando retrocedo más de una confirmación. Me preocupa tener algún tipo de error uno por uno según tengo entendido y terminaré apuntando a la confirmación incorrecta.\nHerramientas como GitKraken y GitHub hacen que sea extremadamente fácil copiar SHA específicos a su portapapeles. Entonces, cuando necesito una referencia que no sea un simple nombre de rama o etiqueta, casi siempre me apoyo en herramientas fáciles de usar como GitKraken o GitHub para permitirme expresar mi intención utilizando el SHA de interés real. Sospecho que los atajos de referencia relativos son más populares entre las personas que usan exclusivamente la línea de comandos Git y operan bajo diferentes restricciones. En realidad, existe un amplio conjunto de formas de especificar una confirmación de destino que va mucho más allá de la sintaxis ^ y ~ que se muestra aquí. Puede obtener más información en la documentación oficial de Git sobre parámetros de revisión.\nEn GitKraken, haga clic con el botón derecho o control en la confirmación de destino para acceder a un menú que incluye “Copiar confirmación sha”, entre muchos otros comandos útiles. Si está utilizando otro cliente Git, probablemente haya una manera de hacerlo y vale la pena descubrirla.\n\n\n\n\n\nGitHub también hace que sea extremadamente fácil copiar un SHA en muchos contextos. Esta captura de pantalla muestra solo un ejemplo. Una vez que empiece a buscar esta función, la encontrará en muchos lugares de GitHub.",
    "crumbs": [
      "Fundamentos de Git",
      "<span class='chapter-number'>24</span>  <span class='chapter-title'>Referencias</span>"
    ]
  },
  {
    "objectID": "git-refs.html#footnotes",
    "href": "git-refs.html#footnotes",
    "title": "24  Referencias",
    "section": "",
    "text": "¿Cuándo HEAD no se resuelve en el SHA en la punta de alguna rama? Cuando estás en un estado detached HEAD. ¡CABEZA separada! Eso suena mal, pero no es intrínsecamente bueno o malo. Sin embargo, ES malo estar en un estado de CABEZA separada si no era tu intención y no entiendes el trato. Entras en un estado CABEZA separada cuando verificas directamente una confirmación específica, en lugar de verificar o cambiar a una rama. En manos experimentadas, esto puede ser algo legítimo. Pero mientras tanto, te recomiendo que siempre visites un estado específico en el historial consultando una rama, incluso si eso significa que necesitas crear una rama temporal como holder o time-travel. Para salir del estado CABEZA separada, consulte alguna rama existente, con git checkout main o similar. De lo contrario, el hilo de StackOverflow ¿Cómo puedo arreglar un cabezal separado de Git? aborda muchos escenarios desconcertantes de CABEZA separada.↩︎",
    "crumbs": [
      "Fundamentos de Git",
      "<span class='chapter-number'>24</span>  <span class='chapter-title'>Referencias</span>"
    ]
  },
  {
    "objectID": "remote-setups-intro.html",
    "href": "remote-setups-intro.html",
    "title": "Configuraciones remotas de Git",
    "section": "",
    "text": "La parte anterior terminó con algunos conceptos básicos sobre Git remotos, como cómo definir o cambiar el nombre de uno. Recuerde que un control remoto de Git es otra copia del repositorio, que generalmente se encuentra en otro lugar (de ahí el término “remoto”), desde donde puede extraer cambios o enviarlos. Los controles remotos son la base de todo el trabajo colaborativo de Git.\nPero conocer la mecánica de cómo agregar o cambiar el nombre de un control remoto no sirve de nada si no sabes por qué o cuándo hacerlo. Afortunadamente, tenemos opiniones muy firmes sobre cómo debes configurar tus controles remotos, todas motivadas por prepararte para un trabajo colaborativo fluido y feliz.\nEn esta parte describimos varias configuraciones remotas que son comunes (para bien o para mal) y para qué sirven (o qué tienen de malo y cómo solucionarlo).",
    "crumbs": [
      "Configuraciones de remotos",
      "Configuraciones remotas de Git"
    ]
  },
  {
    "objectID": "remote-setups-common.html",
    "href": "remote-setups-common.html",
    "title": "25  Configuraciones remotas comunes",
    "section": "",
    "text": "25.1 Sin GitHub\nComo punto de partida, considere un repositorio de Git local que aún no esté conectado a GitHub.\nEsto no es muy emocionante, pero prepara el escenario para lo que está por venir. Introducimos el ícono que usamos para un repositorio de Git, que parece una pila de monedas o un barril. Este es azul, lo que indica que tienes permiso de escritura.\nComo alcanzar:\nusethis describe esta configuración como “no_github”.",
    "crumbs": [
      "Configuraciones de remotos",
      "<span class='chapter-number'>25</span>  <span class='chapter-title'>Configuraciones remotas comunes</span>"
    ]
  },
  {
    "objectID": "remote-setups-common.html#sin-github",
    "href": "remote-setups-common.html#sin-github",
    "title": "25  Configuraciones remotas comunes",
    "section": "",
    "text": "Línea de comando Git: git init\nCon usethis, proyecto existente: usethis::use_git()\nCon RStudio:\n\nProyecto existente: Tools &gt; Version Control &gt; Project Setup, seleccione Git como el sistema de control de versión\nNuevo proyecto: asegúrese de que esté seleccionado “Create a Git repository”",
    "crumbs": [
      "Configuraciones de remotos",
      "<span class='chapter-number'>25</span>  <span class='chapter-title'>Configuraciones remotas comunes</span>"
    ]
  },
  {
    "objectID": "remote-setups-common.html#sec-ours-you",
    "href": "remote-setups-common.html#sec-ours-you",
    "title": "25  Configuraciones remotas comunes",
    "section": "25.2 La nuestra (más específicamente, la tuya)",
    "text": "25.2 La nuestra (más específicamente, la tuya)\nUn siguiente paso común es asociar un repositorio local con una copia en GitHub, de su propiedad.\n\n\n\n\n\nSe configura un control remoto llamado origin y usted tiene permiso para enviar (y extraer) origin. (Es por eso que origin está coloreado en azul y hay flechas sólidas que van en ambas direcciones). El control remoto origin en GitHub es lo que llamaremos un repositorio fuente, lo que significa que no es una bifurcación (es decir, una copia). de cualquier otra cosa en GitHub. En este caso, origin es también lo que llamaremos su repositorio principal, lo que significa que es el control remoto principal con el que interactúa en GitHub (para este proyecto).\nCómo lograr si el repositorio local existe primero:\n\nLas instrucciones detalladas se encuentran en Proyecto existente, GitHub último.\nCon usethis: usethis::use_github().\nLínea de comando Git o RStudio: no puede completar esta tarea completamente desde la línea de comando o desde RStudio:\n\nCree un nuevo repositorio de GitHub en el navegador, con el nombre correcto, y capture su URL HTTPS o SSH.\nConfigurar el repositorio como el remoto origin.\nPush.\nIncluso ahora, la configuración puede no ser ideal, porque las relaciones de seguimiento ascendentes probablemente no estén configuradas, lo que significa que es posible que no pueda enviar e importar fácilmente. Es posible que deba configurar explícitamente una rama upstream para una o más ramas locales. La próxima vez que quieras crear un repositorio de GitHub desde un repositorio local, considera usar usethis::use_github(), que completa toda esta configuración de una sola vez.\n\n\nCómo lograr si el repositorio remoto existe primero:\n\nLas instrucciones detalladas se encuentran en Nuevo proyecto RStudio mediante git clone.\nCon usethis: usethis::create_from_github(\"OWNER/REPO\", fork = FALSE)\nLínea de comando: git clone &lt;URL&gt;, con la URL HTTPS o SSH del repositorio de origen\nEn RStudio: capture la URL HTTPS o SSH del repositorio de origen y haga File &gt; New Project &gt; Version Control &gt; Git.\n\nusethis describe esta configuración como “ours”.",
    "crumbs": [
      "Configuraciones de remotos",
      "<span class='chapter-number'>25</span>  <span class='chapter-title'>Configuraciones remotas comunes</span>"
    ]
  },
  {
    "objectID": "remote-setups-common.html#sec-ours-them",
    "href": "remote-setups-common.html#sec-ours-them",
    "title": "25  Configuraciones remotas comunes",
    "section": "25.3 Nuestra",
    "text": "25.3 Nuestra\nAquí hay una variación sobre “ours” que es equivalente en la práctica.\n\n\n\n\n\nSe configura un control remoto llamado origin y puede enviar (y extraer) origin. Como se indicó anteriormente, origin es un repositorio fuente, lo que significa que no es una bifurcación (o copia) de nada más en GitHub. Sin embargo, el control remoto origin no es de su propiedad. En cambio, es propiedad de otro usuario u organización de GitHub. origin también es su repositorio principal en esta configuración.\n¿Como sucedió esto?\n\nEl repositorio de origen es propiedad de una organización y su función en esta organización le confiere poder suficiente para crear repositorios o enviarlos a este repositorio.\nEl propietario del repositorio de origen lo agregó, específicamente, como colaborador de este repositorio específico.\n\n¿Como lograr esto? El procedimiento es el mismo que para la configuración “ours” anterior. Pero recuerde especificar usethis::use_github(organization = \"ORGNAME\") si desea crear un nuevo repositorio bajo una organización, en lugar de su cuenta personal.\nusethis describe esta configuración como “ours”.",
    "crumbs": [
      "Configuraciones de remotos",
      "<span class='chapter-number'>25</span>  <span class='chapter-title'>Configuraciones remotas comunes</span>"
    ]
  },
  {
    "objectID": "remote-setups-common.html#sec-theirs",
    "href": "remote-setups-common.html#sec-theirs",
    "title": "25  Configuraciones remotas comunes",
    "section": "25.4 Suyo",
    "text": "25.4 Suyo\nEsta es una configuración en la que muchas personas se meten, cuando en realidad no es lo que necesitan. No está roto per se, pero es limitante.\n\n\n\n\n\nNo puede enviar al origin, que es tanto el repositorio de origen como el repositorio principal. (Esto se indica con el color naranja de origin y la flecha de “enviar” discontinua y atenuada). origin es de solo lectura para usted.\nSi está realizando un repositorio para una prueba rápida, esta configuración está bien. Pero no hay forma de recuperar los cambios en el repositorio de origen, ya que no puede enviarlos y no ha creado una bifurcación, que es necesaria para una solicitud de fusión.\n¿Como sucedió esto?\n\nClonando el repositorio de origen, ya sea mediante git clone &lt;URL&gt; (línea de comando) o mediante un cliente Git, p. Flujo de trabajo Archivo &gt; Nuevo proyecto &gt; Control de versiones &gt; Git de RStudio.\nEjecutando usethis::create_from_github(\"OWNER/REPO\", fork = FALSE).\n\nusethis describe esta configuración como “theirs”.\n¿Qué sucede si desea realizar una solicitud de fusión? Esto significa que deberías haber hecho fork-and-clone en lugar de clone. Si no ha realizado cambios o es fácil guardarlos en algún lugar temporalmente, simplemente comience de nuevo con un flujo de trabajo de bifurcación y clonación (explicado completamente en Chapter 31) y vuelva a introducir sus cambios. También es posible conservar su trabajo en una rama local, bifurcar el repositorio de origen, reconfigurar sus controles remotos, volver a sincronizar con el repositorio de origen y volver a la normalidad. Pero es mucho más fácil equivocarse. ¡Y recuerda bifurcar y clonar (no sólo clonar) en el futuro!",
    "crumbs": [
      "Configuraciones de remotos",
      "<span class='chapter-number'>25</span>  <span class='chapter-title'>Configuraciones remotas comunes</span>"
    ]
  },
  {
    "objectID": "remote-setups-common.html#sec-fork-them",
    "href": "remote-setups-common.html#sec-fork-them",
    "title": "25  Configuraciones remotas comunes",
    "section": "25.5 Fork (theirs)",
    "text": "25.5 Fork (theirs)\nEsta es una configuración ideal si desea realizar una solicitud de fusión y, en general, seguir el desarrollo de un repositorio fuente propiedad de otra persona.\n\n\n\n\n\nEsto muestra un “fork-and-clone” exitoso. Su repositorio local puede extraer cambios del repositorio de origen, que está configurado como “upstream”, al cual no puede enviar cambios (pero sí puede importarlos). Tienes un fork del repositorio fuente (una copia muy especial, en GitHub) y está configurado como origin. origin es su repositorio principal. Puede enviar e importar desde el origin. Puede realizar una solicitud de fusión al repositorio de origen a través de su bifurcación.\nusethis describe esta configuración como “fork”.\nComo alcanzar:\n\nLas instrucciones detalladas se dan en Fork y clone.\nCon usethis: usethis::create_from_github(\"OWNER/REPO\", fork = TRUE)\nLínea de comando Git o RStudio: no puede completar esta tarea completamente desde la línea de comando o RStudio:\n\nBifurca el repositorio fuente en el navegador, captura la URL HTTPS o SSH de tu bifurcación, luego usa git clone &lt;FORK_URL&gt; (línea de comando) o RStudio. File &gt; New Project &gt; Version Control &gt; Git flujo de trabajo. Pero espera, ¡aún no has terminado! Si se detiene aquí, tendrá la configuración incompleta a la que nos referimos como “fork (salvageable)”.\nAún necesita agregar el repositorio de origen como control remoto upstream. Capture la URL HTTPS o SSH del repositorio de origen. En la línea de comando, haga git remoto add upstream &lt;SOURCE_URL&gt; o haga clic en el botón Nueva rama de RStudio, que abre una ventana donde puede agregar el control remoto upstream.\nIncluso entonces, la configuración puede no ser ideal, porque su rama predeterminada local probablemente esté rastreando el origin, no el upstream, lo cual es preferible para una bifurcación. usethis::create_from_github() completa toda esta configuración de una sola vez.\nEstos dos últimos pasos se describen en Finalizar la configuración de bifurcación y clonación.",
    "crumbs": [
      "Configuraciones de remotos",
      "<span class='chapter-number'>25</span>  <span class='chapter-title'>Configuraciones remotas comunes</span>"
    ]
  },
  {
    "objectID": "remote-setups-common.html#fork-ours",
    "href": "remote-setups-common.html#fork-ours",
    "title": "25  Configuraciones remotas comunes",
    "section": "25.6 Fork (ours)",
    "text": "25.6 Fork (ours)\nEsta es una variación menos común en la configuración de fork.\n\n\n\n\n\nEn este caso, tiene permiso para enviar al repositorio de origen, pero elige crear una bifurcación personal de todos modos. Ciertos proyectos favorecen este enfoque y ofrece la máxima flexibilidad de desarrollo para usuarios avanzados. Sin embargo, en este caso, a la mayoría de los usuarios les resulta mejor la configuración más sencilla “ours”.\nComo lograrlo:\n\nEn general, es lo mismo que la configuración de bifurcación normal anterior.\nCon usethis, asegúrese de especificar explícitamente fork = TRUE, es decir, ejecute usethis::create_from_github(\"OWNER/REPO\", fork = TRUE).\n\nusethis describe esta configuración como “fork”.",
    "crumbs": [
      "Configuraciones de remotos",
      "<span class='chapter-number'>25</span>  <span class='chapter-title'>Configuraciones remotas comunes</span>"
    ]
  },
  {
    "objectID": "remote-setups-common.html#sec-fork_upstream_is_not_origin_parent",
    "href": "remote-setups-common.html#sec-fork_upstream_is_not_origin_parent",
    "title": "25  Configuraciones remotas comunes",
    "section": "25.7 Fork (salvageable)",
    "text": "25.7 Fork (salvageable)\nAquí hay una última configuración de bifurcación que no es óptima, pero se puede salvar.\n{fig-align=“center” fig-alt = “Setup described as ‘fork_upstream_is_not_origin_parent’” width=“60%”}\nEsto es lo que sucede cuando haces bifurcación y clonación y solo haces bifurcación y clonación. Lo que falta es una conexión con el repositorio de origen.\n¿Como sucedió esto?\n\nClonar su propia bifurcación, ya sea mediante git clone en el shell o mediante un cliente Git, como RStudio. Y luego parando aquí.\n\nSi solo planea realizar una solicitud de extracción, esta configuración está bien. Cuando finalice el intercambio, elimine su repositorio local y su bifurcación y continúe con su vida. Siempre puedes volver a bifurcar en el futuro. Pero si su solicitud de extracción permanece abierta por un tiempo o si planea realizar contribuciones repetidas, deberá incorporar los desarrollos en curso en el repositorio fuente a su copia local.\nPuedes convertir esto en la configuración de bifurcación ideal así:\n\nLas instrucciones detalladas se encuentran en Finalizar la configuración de bifurcación y clonación.\nAgregue el repositorio de origen como remoto upstream.\nEstablezca upstream/main como la rama de seguimiento ascendente para main local (sustituya el nombre de su rama predeterminada).\n\nLa próxima vez que hagas fork-and-clone, considera usar usethis::create_from_github(fork = TRUE) en su lugar, lo que completa toda esta configuración de una sola vez.\nusethis describe esta configuración como “fork_upstream_is_not_origin_parent”.",
    "crumbs": [
      "Configuraciones de remotos",
      "<span class='chapter-number'>25</span>  <span class='chapter-title'>Configuraciones remotas comunes</span>"
    ]
  },
  {
    "objectID": "remote-setups-equivocal.html",
    "href": "remote-setups-equivocal.html",
    "title": "26  Configuraciones remotas equívocas",
    "section": "",
    "text": "26.1 Tal vez “ours” o “theirs”\nCuando detectamos solo un control remoto de GitHub, pero no podemos verificar la información anterior, usethis describe la configuración como “maybe_ours_or_theirs”.\n{fig-align=“center” fig-alt=“Setup described as ‘maybe_ours_or_theirs’” width = “60%”}\nUna vez que un PAT está disponible, esta configuración se puede identificar como “ours” (que le pertenece a usted), “ours” (pero que pertenece a otra persona) , o “theirs”.",
    "crumbs": [
      "Configuraciones de remotos",
      "<span class='chapter-number'>26</span>  <span class='chapter-title'>Configuraciones remotas equívocas</span>"
    ]
  },
  {
    "objectID": "remote-setups-equivocal.html#tal-vez-fork",
    "href": "remote-setups-equivocal.html#tal-vez-fork",
    "title": "26  Configuraciones remotas equívocas",
    "section": "26.2 Tal vez fork",
    "text": "26.2 Tal vez fork\nCuando detectamos dos controles remotos de GitHub, pero no podemos verificar la información anterior, usethis describe la configuración como “maybe_fork”.\n\n\n\n\n\nUna vez que un PAT está disponible, esta configuración se puede identificar como una bien configurada fork o una bifurcación con configuración incompleta (o posiblemente algo más raro).",
    "crumbs": [
      "Configuraciones de remotos",
      "<span class='chapter-number'>26</span>  <span class='chapter-title'>Configuraciones remotas equívocas</span>"
    ]
  },
  {
    "objectID": "remote-setups-equivocal.html#como-arreglar",
    "href": "remote-setups-equivocal.html#como-arreglar",
    "title": "26  Configuraciones remotas equívocas",
    "section": "26.3 Como arreglar",
    "text": "26.3 Como arreglar\nEstas configuraciones no necesariamente están rotas, pero su uso necesita más información para funcionar.\nPara “solucionar” esto, configure un token de acceso personal de GitHub. Consulte Section 9.3 para obtener más detalles sobre por qué y cómo hacerlo.",
    "crumbs": [
      "Configuraciones de remotos",
      "<span class='chapter-number'>26</span>  <span class='chapter-title'>Configuraciones remotas equívocas</span>"
    ]
  },
  {
    "objectID": "workflows-intro.html",
    "href": "workflows-intro.html",
    "title": "Useful Git patterns for real life",
    "section": "",
    "text": "Much of this originates as live workshop materials; the unlinked workflows are planned but not yet converted to prose here.\nGit patterns that come up frequently in real work:\n\nCommit early and often. Push less often. The Repeated Amend.\nHelp, my push was rejected!\nIntegrating remote and local work. Probably so you can push again.\nBurn it all down.\nTime travel:\n\n“I just need to see the past”. Browse and search on GitHub.\n“I need to visit the past”. Create a checkout a branch.\n“I want to return to the past”. git revert, git reset\n“I had a great cookie last October”. git cherry pick, git checkout REF -- path\n\n\nPlay well with others:\n\nFork and clone.\nGet upstream changes for a fork.\nDisposable fork.\nMake your repo rewarding to browse on GitHub.\nExplore and extend a pull request",
    "crumbs": [
      "Flujos de trabajo diarios",
      "Useful Git patterns for real life"
    ]
  },
  {
    "objectID": "workflows-repeated-amend.html",
    "href": "workflows-repeated-amend.html",
    "title": "27  The Repeated Amend",
    "section": "",
    "text": "27.1 Rock climbing analogy\nLet’s talk about this:\nWhen I’m doing something tricky, I often proceed towards my goal in small increments, checking that everything still works along the way. Yes it works? Make a commit. This is my new worst case scenario. Keep going.\nWhat’s not to love?\nThis can lead to an awful lot of tiny commits. This is absolutely fine and nothing to be ashamed of. But one day you may start to care about the utility and aesthetics of your Git history.\nThe Repeated Amend is a pattern where, instead of cluttering your history with lots of tiny commits, you build up a “good” commit gradually, by amending.\nYes, there are other ways to do this, e.g. via squashing and interactive rebase, but I think amending is the best way to get started.",
    "crumbs": [
      "Flujos de trabajo diarios",
      "<span class='chapter-number'>27</span>  <span class='chapter-title'>The Repeated Amend</span>"
    ]
  },
  {
    "objectID": "workflows-repeated-amend.html#rock-climbing-analogy",
    "href": "workflows-repeated-amend.html#rock-climbing-analogy",
    "title": "27  The Repeated Amend",
    "section": "",
    "text": "Using a Git commit is like using anchors and other protection when climbing. If you’re crossing a dangerous rock face you want to make sure you’ve used protection to catch you if you fall. Commits play a similar role: if you make a mistake, you can’t fall past the previous commit. Coding without commits is like free-climbing: you can travel much faster in the short-term, but in the long-term the chances of catastrophic failure are high! Like rock climbing protection, you want to be judicious in your use of commits. Committing too frequently will slow your progress; use more commits when you’re in uncertain or dangerous territory. Commits are also helpful to others, because they show your journey, not just the destination.\nR Packages, Hadley Wickham (Wickham (2015))\n\n\n\nuse more commits when you’re in uncertain or dangerous territory",
    "crumbs": [
      "Flujos de trabajo diarios",
      "<span class='chapter-number'>27</span>  <span class='chapter-title'>The Repeated Amend</span>"
    ]
  },
  {
    "objectID": "workflows-repeated-amend.html#workflow-sketch",
    "href": "workflows-repeated-amend.html#workflow-sketch",
    "title": "27  The Repeated Amend",
    "section": "27.2 Workflow sketch",
    "text": "27.2 Workflow sketch\n\n27.2.1 Initial condition\nStart with your project in a functional state:\n\nR package? Run your tests or R CMD check.\nData analysis? Re-run your script or re-render your .Rmd with the new chunk.\nWebsite or book? Make sure the project still compiles.\nYou get the idea.\n\nMake sure your “working tree is clean” and you are synced up with your GitHub remote. git status should show something like:\n~/tmp/myrepo % git status                                                          \nOn branch main\nYour branch is up to date with 'origin/main'.\n\nnothing to commit, working tree clean\n\n\n27.2.2 Get to work\nImagine we start at commit C, with previous commit B and, before that, A:\n... -- A -- B -- C\nMake a small step towards your goal. Re-check that your project “works”.\nStage those changes with and make a commit with the message “WIP”, meaning “work in progress”. Do this in RStudio or in the shell (Appendix A):\ngit add path/to/the/changed/file\ngit commit -m \"WIP\"\nThe message can be anything, but “WIP” is a common convention. If you use it, whenever you return to a project where the most recent commit message is “WIP”, you’ll know that you were probably in the middle of something. If you push a “WIP” commit, on purpose or by mistake, it signals to other people that more commits might be coming.\nYour history now looks like this:\nA -- B -- C -- WIP*\nDon’t push! The * above signifies a commit that exists only in your local repo, not (yet) on GitHub. If you called git status, you’d see something like “Your branch is ahead of ‘origin/main’ by 1 commit.”, which is also displayed in RStudio’s Git pane.\nDo a bit more work. Re-check that your project is still in a functional state. Stage and commit again, but this time amend your previous commit. RStudio offers a check box for “Amend previous commit” or in the shell:\ngit commit --amend --no-edit\nThe --no-edit part retains the current commit message of “WIP”.\nDon’t push! Your history now looks like this:\nA -- B -- C -- WIP*\nbut the changes associated with the WIP* commit now represent your last two commits, i.e. all the accumulated changes since state C.\nKeep going like this.\nLet’s say you’ve finally achieved your goal. One last time, check that your project is functional and in a state you’re willing to share with others.\nCommit, amending again, but with a real commit message this time. Think of this as commit D. Push. Do this in RStudio or the shell:\ngit commit --amend -m \"Implement awesome feature; closes #43\"\ngit push\nYour history – and that on GitHub – look like this:\nA -- B -- C -- D\nAs far as the world knows, you implemented the feature in one fell swoop. But you got to work on the task incrementally, with the peace of mind that you could never truly break things.",
    "crumbs": [
      "Flujos de trabajo diarios",
      "<span class='chapter-number'>27</span>  <span class='chapter-title'>The Repeated Amend</span>"
    ]
  },
  {
    "objectID": "workflows-repeated-amend.html#what-if-i-need-to-fall-back",
    "href": "workflows-repeated-amend.html#what-if-i-need-to-fall-back",
    "title": "27  The Repeated Amend",
    "section": "27.3 What if I need to fall back?",
    "text": "27.3 What if I need to fall back?\nImagine you’re in the middle of a Repeated Amend workflow:\nA -- B -- C -- WIP*\nand you make some changes that break your project, e.g. tests start failing. These bad changes are not yet committed, but they are saved. You want to fall back to the last good state, represented by WIP*.\nIn Git lingo, you want to do a hard reset to the WIP* state. Your local files will be forcibly reset to their state as of the WIP* commit. With the command line:\ngit reset --hard\nwhich is implicitly the same as\ngit reset --hard HEAD\nwhich says: “reset my files to their state at the most recent commit”.\nThis is also possible in RStudio. In fact, the RStudio way makes it easier to selectively reset only specific files or only certain changes. Click on “Diff” or “Commit”. Select a file with changes you do not want. Use “Discard All” to discard all changes in that file. Use “Discard chunk” to discard specific changes in a file. Repeat this procedure for each affected file until you are back to an acceptable state. Carry on.\nIf you committed a bad state, go to link to come for more reset scenarios.",
    "crumbs": [
      "Flujos de trabajo diarios",
      "<span class='chapter-number'>27</span>  <span class='chapter-title'>The Repeated Amend</span>"
    ]
  },
  {
    "objectID": "workflows-repeated-amend.html#why-dont-we-push-intermediate-progress",
    "href": "workflows-repeated-amend.html#why-dont-we-push-intermediate-progress",
    "title": "27  The Repeated Amend",
    "section": "27.4 Why don’t we push intermediate progress?",
    "text": "27.4 Why don’t we push intermediate progress?\nAmending a commit is an example of what’s called “rewriting Git history”.\nRewriting history that has already been pushed to GitHub – and therefore potentially pulled by someone else – is a controversial practice. Like most controversial practices, lots of people still indulge in it, as do I.\nBut there is the very real possibility that you create headaches for yourself and others, so in Happy Git we must recommend that you abstain. Once you’ve pushed something, consider it written in stone and move on.",
    "crumbs": [
      "Flujos de trabajo diarios",
      "<span class='chapter-number'>27</span>  <span class='chapter-title'>The Repeated Amend</span>"
    ]
  },
  {
    "objectID": "workflows-repeated-amend.html#um-what-if-i-did-push",
    "href": "workflows-repeated-amend.html#um-what-if-i-did-push",
    "title": "27  The Repeated Amend",
    "section": "27.5 Um, what if I did push?",
    "text": "27.5 Um, what if I did push?\nI told you not to!\nBut OK here we are.\nLet’s imagine you pushed this state to GitHub by mistake:\nA -- B -- C -- WIP (85bf30a)\nand proceeded to git commit --amend again locally, leading to this state:\nA -- B -- C -- WIP* (6e884e6)\nI’m deliberately showing two histories that sort of look the same, in terms of commit messages. But the last SHA reveals they are actually different.\nYou are in a pickle now, as you can’t do a simple push or pull. A push will be rejected and a pull will probably lead to a merge that you don’t want.\nYou have two choices:\n\nIf you have collaborators who may have pulled the repo at commit WIP (85bf30a), you have to regard that particular history as being written in stone now. If there is any very precious work that only exists locally, such as a specific file, save a copy of that to a new file path, temporarily. Hard reset your local repo to C (git reset --hard HEAD^) and pull from GitHub. GitHub and local history now show this:\nA -- B -- C -- WIP (85bf30a)\nIf you saved some precious work to a temporary file path, bring it back into the repo now; save, stage, commit, and push. GitHub and local history now show this:\nA -- B -- C -- WIP (85bf30a) -- E\nIf you have no collaborators or you have reason to believe they have not pulled, you can rewrite history, even on GitHub. You might as well make sure your local commit has a real, non-“WIP” message at this point. Force push your history to GitHub (git push --force). GitHub and local history now show this:\nA -- B -- C -- D\n\nIn both cases, you’ve made the changes you want and your local repo and the GitHub remote are synced up again. The history is nicer in the second case, but that’s a secondary issue.\nThere are many different ways to rewrite history and rescue some of these situations, but we find the approaches described above to be very approachable.\n\n\n\n\nWickham, Hadley. 2015. R Packages. 1st ed. O’Reilly Media, Inc.",
    "crumbs": [
      "Flujos de trabajo diarios",
      "<span class='chapter-number'>27</span>  <span class='chapter-title'>The Repeated Amend</span>"
    ]
  },
  {
    "objectID": "workflows-push-rejected.html",
    "href": "workflows-push-rejected.html",
    "title": "28  Dealing with push rejection",
    "section": "",
    "text": "28.1 She who pushes first wins!\nYou may have noticed that you – the author of D – are faffing around with Git more than the person who committed and pushed C, i.e. your collaborator.\nThere is a lesson to be learned here!\nIf you had pushed D first, you’d be relaxing and they’d be figuring out how to integrate C into their history in order to push. So push your work often. Don’t go dark and work “offline” for long stretches of time.\nObviously, you should push work to main because it’s “ready” to share (or at least “ready enough”), not to avoid Git merges.\nThere is a truly legitimate point here: It is better for the overall health of a project to be committing, pushing, and integrating more often, not less. This does not eliminate the need to integrate different lines of work, but it makes each integration smaller, less burdensome, and less prone to error.",
    "crumbs": [
      "Flujos de trabajo diarios",
      "<span class='chapter-number'>28</span>  <span class='chapter-title'>Dealing with push rejection</span>"
    ]
  },
  {
    "objectID": "workflows-push-rejected.html#stay-in-touch",
    "href": "workflows-push-rejected.html#stay-in-touch",
    "title": "28  Dealing with push rejection",
    "section": "28.2 Stay in touch",
    "text": "28.2 Stay in touch\nAnother take away is this: the sooner you know about C, the better. Pull (or fetch) often.\nLet’s think about your commit D. Maybe it was built up over a couple of days via the Repeated Amend pattern. Maybe C was sitting there on GitHub the whole time or appeared very early in your process.\nConsider that it might be easier to integrate C into your work D sooner rather than later. Sometimes this is not true, but more often it is.\nIn general, it pays off to be proactively aware of what others are doing (e.g. to pull or fetch often) than to always be in reactive mode, learning about your collaborator’s work only when your push is rejected.",
    "crumbs": [
      "Flujos de trabajo diarios",
      "<span class='chapter-number'>28</span>  <span class='chapter-title'>Dealing with push rejection</span>"
    ]
  },
  {
    "objectID": "workflows-push-rejected.html#use-branches",
    "href": "workflows-push-rejected.html#use-branches",
    "title": "28  Dealing with push rejection",
    "section": "28.3 Use branches",
    "text": "28.3 Use branches\nFinally, your early experiences collaborating with others and yourself in main will give you a visceral understanding of why most Git users eventually start to use branches.\nBranches afford explicit workflows for integrating different lines of work on your own terms. This is much nicer than trying to do a tricky merge or rebase in a frustrated panic, because you need to push your work to GitHub at the end of the day.",
    "crumbs": [
      "Flujos de trabajo diarios",
      "<span class='chapter-number'>28</span>  <span class='chapter-title'>Dealing with push rejection</span>"
    ]
  },
  {
    "objectID": "workflows-pull.html",
    "href": "workflows-pull.html",
    "title": "29  Pull, but you have local work",
    "section": "",
    "text": "29.1 Local work is uncommitted\nRemote state is A--B--C.\nLocal state is A--B--(uncommitted changes).",
    "crumbs": [
      "Flujos de trabajo diarios",
      "<span class='chapter-number'>29</span>  <span class='chapter-title'>Pull, but you have local work</span>"
    ]
  },
  {
    "objectID": "workflows-pull.html#local-work-is-uncommitted",
    "href": "workflows-pull.html#local-work-is-uncommitted",
    "title": "29  Pull, but you have local work",
    "section": "",
    "text": "29.1.1 Happy simple cases\nThere are two happy scenarios, in which git pull will “just work”:\n\nYou’ve introduced completely new files that don’t exist in the remote branch and, therefore, cannot possibly have conflicting changes. You’re in luck! You can just git pull.\nThe files affected by your local work have ZERO overlap with the files affected by the changes you need to pull from the remote. You’re also in luck! You can just git pull.\n\nSummary of these happy git pull scenarios:\n                 Remote: A--B--C\n\nLocal before 'git pull': A--B--(uncommitted changes)\n Local after 'git pull': A--B--C--(uncommitted changes)\nWhat has actually happened here is that git pull resulted in a fast-forward merge, i.e. we placed commit C right on the end of your history. This would also be the case in the simpler situation where recent local history was just A--B, i.e. you had not added any local work since the last sync up with origin/main.\n\n\n29.1.2 git stash works, sometimes\nIf your changes affect a file (foo.R in the example below) that has also been changed in commit C, you cannot git pull. It doesn’t hurt to try, but you will fail and it will look something like this:\njenny@2015-mbp ethel $ git pull\nremote: Enumerating objects: 5, done.\nremote: Counting objects: 100% (5/5), done.\nremote: Compressing objects: 100% (2/2), done.\nremote: Total 3 (delta 1), reused 1 (delta 0), pack-reused 0\nUnpacking objects: 100% (3/3), done.\nFrom github.com:jennybc/ethel\n   db046b4..2d33a6f  main     -&gt; origin/main\nUpdating db046b4..2d33a6f\nerror: Your local changes to the following files would be overwritten by merge:\n        foo.R\nPlease commit your changes or stash them before you merge.\nAborting\nNow what? First, you must safeguard your local changes by either stashing or committing them. (I personally would choose to commit and execute a workflow described in Section 29.2.)\nI am not a big fan of git stash; I think it’s usually better to take every possible chance to solidify your skills around core concepts and operations, e.g., make a commit, possibly in a branch. But if you want to use git stash, this opportunity is as good as it gets.\ngit stash is a way to temporarily store some changes to get them out of the way. Now you can do something else, without a lot of fuss. In our case, “do something else” is to get the upstream changes with a nice, simple git pull. Then you reapply and delete the stash and pick up where you left off.\nFor more details about stashing, I recommend\n\nThe stashing coverage in the “Filesystem interactions” chapter of Git in Practice (book website or read on GitHub)\n7.3 Git Tools - Stashing and Cleaning in Pro Git.\n\nHere’s the best case scenario for “stash, pull, unstash” in the example above:\ngit stash save\ngit pull\ngit stash pop\nAnd here’s the output from our example:\njenny@2015-mbp ethel $ git stash save\nSaved working directory and index state WIP on main: db046b4 Merge branch 'main'of github.com:jennybc/ethel\n\njenny@2015-mbp ethel $ git pull\nUpdating db046b4..2d33a6f\nFast-forward\n foo.R | 2 +-\n 1 file changed, 1 insertion(+), 1 deletion(-)\n\njenny@2015-mbp ethel $ git stash pop\nAuto-merging foo.R\nOn branch main\nYour branch is up-to-date with 'origin/main'.\n\nChanges not staged for commit:\n  (use \"git add &lt;file&gt;...\" to update what will be committed)\n  (use \"git checkout -- &lt;file&gt;...\" to discard changes in working directory)\n\n        modified:   foo.R\n\nno changes added to commit (use \"git add\" and/or \"git commit -a\")\nDropped refs/stash@{0} (012c4dcd3a4c3af6757c4c3ca99a9eaeff1eb2a4)\nThat is what success looks like. You’ve achieved this:\n      Remote: A--B--C\n\nLocal before: A--B--(uncommitted changes)\n Local after: A--B--C--(uncommitted changes)\nAs above, we have just enjoyed a fast-forward merge, made possible by temporarily stashing then unstashing the uncommitted local changes.\n\n\n29.1.3 git stash with conflicts\nIf your local changes have some overlap with changes you are pulling, you will, instead get a merge conflict from git stash pop. Now you have some remedial work to do. In this case, you have gained nothing by using git stash in the first place, which explains my general lack of enthusiasm for git stash.\nHere’s how to execute the git stash workflow in our example, in the face of conflicts (based on this Stack Overflow answer):\njenny@2015-mbp ethel $ git stash save\nSaved working directory and index state WIP on main: 2d33a6f Back to 5\n\njenny@2015-mbp ethel $ git pull\nUpdating 2d33a6f..1eddf9e\nFast-forward\n foo.R | 1 +\n 1 file changed, 1 insertion(+)\n \njenny@2015-mbp ethel $ git stash pop\nAuto-merging foo.R\nCONFLICT (content): Merge conflict in foo.R\nAt this point, you must resolve the merge conflict (future link). Literally, at each locus of conflict, pick one version or the other (upstream or stashed) or create a hybrid yourself. Remove the all the markers inserted to demarcate the conflicts. Save.\nSince git stash pop did not go smoothly, we need to manually reset (future link) and delete the stash to finish.\njenny@2015-mbp ethel $ git reset\nUnstaged changes after reset:\nM       foo.R\n\njenny@2015-mbp ethel $ git stash drop\nDropped refs/stash@{0} (7928db50288e9b4d934803b6b451a000fd7242ed)\nPhew, we are done. We’ve achieved this:\n      Remote: A--B--C\n\nLocal before: A--B--(uncommitted changes)\n Local after: A--B--C--(uncommitted changes*)\nThe asterisk on uncommitted changes* indicates that your uncommitted changes might now reflect adjustments made when you resolved the conflicts.",
    "crumbs": [
      "Flujos de trabajo diarios",
      "<span class='chapter-number'>29</span>  <span class='chapter-title'>Pull, but you have local work</span>"
    ]
  },
  {
    "objectID": "workflows-pull.html#sec-git-pull-with-local-commits",
    "href": "workflows-pull.html#sec-git-pull-with-local-commits",
    "title": "29  Pull, but you have local work",
    "section": "29.2 Local work is committed",
    "text": "29.2 Local work is committed\nRemote state is A--B--C.\nLocal state is A--B--D.\n\n29.2.1 Pull (fetch and merge)\nThe simplest option is to fetch the commits from upstream and merge them, which is what git pull does. This is a good option if you’re new to Git. It leads to a messier history, but when you are new, this is the least of your worries. Merge, be happy, and carry on.\nHere is the best case, no-merge-conflicts version of git pull:\njenny@2015-mbp ethel $ git pull\n\n&lt; YOU WILL PROBABLY BE KICKED INTO AN EDITOR HERE RE: MERGE COMMIT MESSAGE! &gt;\n\nMerge made by the 'recursive' strategy.\n README.md | 4 ++--\n 1 file changed, 2 insertions(+), 2 deletions(-)\nDepending on your version of Git, your config, and your use of a GUI, you might be required to confirm/edit a commit message for the merge commit.\nOr what if things don’t go this smoothly? If commit C (on the remote) and commit D (local) have changes to the same parts of one or more files, Git may not be able to automatically merge and you will get merge conflicts. It will look something like this:\njenny@2015-mbp ethel $ git pull\nAuto-merging foo.R\nCONFLICT (content): Merge conflict in foo.R\nAutomatic merge failed; fix conflicts and then commit the result.\nYou must resolve these conflicts (future link). Literally, at each locus of conflict, pick one version or the other (upstream or local) or create a hybrid yourself. Remove the all the markers inserted to demarcate the conflicts. Save.\nMark the affected file foo.R as resolved via git add and make an explicit git commit to finalize this merge.\njenny@2015-mbp ethel $ git add foo.R\njenny@2015-mbp ethel $ git commit\n[main 20b297b] Merge branch 'main' of github.com:jennybc/ethel\nAgain, do not be surprised if, during git commit, you find yourself in an editor, confirming/editing the commit message for the merge commit.\nWe’ve achieved this:\n      Remote: A--B--C\n\nLocal before: A--B--D\n Local after: A--B--D--(merge commit)\n                  \\_C_/\n\n\n29.2.2 Pull and rebase\ngit pull --rebase creates a nicer history than git pull when integrating local and remote commits. It avoids a merge commit, so the history is less cluttered and is linear. It can make merge conflicts more onerous to resolve, which is why I still recommend git pull as the entry-level solution.\nHere is the best case, no-merge-conflicts version of git pull --rebase:\njenny@2015-mbp ethel $ git pull --rebase\nFirst, rewinding head to replay your work on top of it...\nApplying: Take max\nNotice that you were NOT kicked into an editor to fiddle with the commit message for the merge commit, because there is no merge commit! This is the beauty of rebasing.\nWe’ve achieved this:\n      Remote: A--B--C\n\nLocal before: A--B--D\n Local after: A--B--C--D\nIt is as if we pulled the upstream work in commit C, then did the local work embodied in commit D. We have no cluttery merge commits and a linear history. Nice!\nThe bad news: As with plain vanilla git pull, it is still possible to get merge conflicts with git pull --rebase. If you have multiple local commits, you can even find yourself resolving conflicts over and over, as these commits are sequentially replayed. Hence this is a better fit for more experienced Git users and in situations where conflicts are unlikely (those tend to be correlated, actually).\nAt this point, if you try to do git pull --rebase and get bogged down in merge conflicts, I recommend git rebase --abort to back out. For now, just pursue a more straightforward strategy.",
    "crumbs": [
      "Flujos de trabajo diarios",
      "<span class='chapter-number'>29</span>  <span class='chapter-title'>Pull, but you have local work</span>"
    ]
  },
  {
    "objectID": "workflows-pull.html#other-approaches",
    "href": "workflows-pull.html#other-approaches",
    "title": "29  Pull, but you have local work",
    "section": "29.3 Other approaches",
    "text": "29.3 Other approaches\nThere are many more ways to handle this situation, which you can discover and explore as you gain experience and start to care more about the history. We sketch some ideas here.\n\n29.3.1 Use a temporary branch for local work\nRecall:\nRemote state is A--B--C.\nLocal state is A--B--(uncommitted changes).\nThis is an alternative to the stash workflow that has the advantage of giving you practice with Git techniques that are more generally useful. It also leads to a nice history.\nCreate a new, temporary branch and commit your uncommitted changes there. Checkout main and git pull to get changes from upstream. You now need to recover the work from the commit in the temporary branch. Options:\n\nMerge the temporary branch into main.\nCherry pick the commit from the temporary branch into main.\n\nIn either case, it is still possible you will need to deal with merge conflicts.\nIn either case, if you felt forced to commit before you were ready or to accept an ugly merge commit, you can either do a mixed reset to “uncommit” but keep the changes on main or keep amending until you are satisfied with the commit.",
    "crumbs": [
      "Flujos de trabajo diarios",
      "<span class='chapter-number'>29</span>  <span class='chapter-title'>Pull, but you have local work</span>"
    ]
  },
  {
    "objectID": "workflows-pull.html#some-local-work-is-committed-some-is-not",
    "href": "workflows-pull.html#some-local-work-is-committed-some-is-not",
    "title": "29  Pull, but you have local work",
    "section": "29.4 Some local work is committed, some is not",
    "text": "29.4 Some local work is committed, some is not\nThis is an awkward hybrid situation that can be handled with a combination of strategies seen above: make a pragmatic commit on main or a temporary branch. Integrate the upstream and local changes in main. If you aren’t happy with the final pragmatic commit (which only exists locally), reset or amend until you are.",
    "crumbs": [
      "Flujos de trabajo diarios",
      "<span class='chapter-number'>29</span>  <span class='chapter-title'>Pull, but you have local work</span>"
    ]
  },
  {
    "objectID": "workflows-see-the-past.html",
    "href": "workflows-see-the-past.html",
    "title": "30  Time travel: See the past",
    "section": "",
    "text": "30.1 Hyperlinks are awesome!\nThis is where GitHub (and GitLab or BitBucket) really shine. The ability to quickly explore different commits/states, switch between branches, inspect individual files, and see the discussion in linked issues is incredibly powerful.\nYes, technically, you can visit past states of your project using Git commands locally. But it is significantly more cumbersome. You generally have to checkout these previous states, which raises the prospect of getting comfortable in the “detached head” state and unintentionally making new commits on the wrong branch or on no branch at all.\nGitHub’s hyperlink-rich presentation of your repo and its history is one of the top reasons to sync local work to a copy on GitHub, even if you keep it private. It can be much easier to hone in on a state or change of interest by clicking around or using GitHub’s search features. Also, because it is so clearly a remote and read-only action, there is no possibility of goofing up local state or committing new work to the wrong branch.",
    "crumbs": [
      "Flujos de trabajo diarios",
      "<span class='chapter-number'>30</span>  <span class='chapter-title'>Time travel: See the past</span>"
    ]
  },
  {
    "objectID": "workflows-see-the-past.html#browse-commit-history-and-specific-commits",
    "href": "workflows-see-the-past.html#browse-commit-history-and-specific-commits",
    "title": "30  Time travel: See the past",
    "section": "30.2 Browse commit history and specific commits",
    "text": "30.2 Browse commit history and specific commits\nFrom your repo’s landing page, access commit history by clicking on “xyz commits”. This is like using git log locally, but much more rewarding. If you have a good local Git client, it probably also provides a graphical overview of history.\n\n\n\nLink to commit listing on GitHub.\n\n\nOnce you’re viewing the history, notice three ways to access more info for each commit:\n\nThe clipboard icon copies the SHA-1 of the commit. This can be handy if you need to refer to this commit elsewhere, e.g. in an issue thread or a commit message or in a Git command you’re forming for local execution.\nClick on the abbreviated SHA-1 itself in order to the view the diff associated with the commit.\nClick on the double angle brackets &lt;&gt; to browse the state of the entire repo at that point in history.\n\n\n\n\nExample of a commit listing on GitHub.\n\n\nBack out of any drilled down view by clicking on YOU/REPO to return to your repo’s landing page. This brings you back to the present state and top-level of your repo.\n\n30.2.1 Use hyperlinks yourself!\nOnce you’ve identified a relevant commit, diff, or file state, you can copy the current URL from your browser and use it to enhance online discussion elsewhere, i.e. to bring other people to this exact view of the repo. The hyperlink-iness of repos hosted on GitHub can make online discussion of a project much more precise and efficient.",
    "crumbs": [
      "Flujos de trabajo diarios",
      "<span class='chapter-number'>30</span>  <span class='chapter-title'>Time travel: See the past</span>"
    ]
  },
  {
    "objectID": "workflows-see-the-past.html#file-driven-inquiries",
    "href": "workflows-see-the-past.html#file-driven-inquiries",
    "title": "30  Time travel: See the past",
    "section": "30.3 File driven inquiries",
    "text": "30.3 File driven inquiries\nWhat if you’re interested in how a specific file came to be the way it is? First navigate to the file, then notice “Blame” and “History” in the upper right.\n\n\n\nVisiting a specific file on GitHub.\n\n\n\n30.3.1 Blame\nThe “blame” view of a file is related to what git blame does on the command line. It reveals who last touched each line of the file, how long ago, and the associated commit message. Click on the commit message to visit that commit. Or click the “stacked rectangles” icon to move further back in time, but staying in blame view. This is handy when doing forensics on a specific and small set of lines.\nadd a screenshot (and update that above) but first pick a better example than Happy Git, i.e. one with more contributors / more interesting history\n\n\n30.3.2 History\nThe “history” view for a file is very much like the overall commit history described above, except it only includes commits that affect the file of interest. This can be handy when your inquiry is rather diffuse and you’re trying to digest the general story arc for a file.\n\n\n30.3.3 Hyperlink to specific lines at a specific state\nWhen viewing a file on GitHub, you can click on a line number to highlight it. Use “click … shift-click” to select a range of lines. Notice your browser’s URL shows something of this form:\nhttps://github.com/OWNER/REPO/blob/SHA/path/to/file.R#L27-L31\nIf the URL does not contain the SHA, type “y” to toggle into that form.\nThese file- and SHA-specific URLs are a great way to point people at particular lines of code in online conversations. It’s best practice to use the uglier links that contain the SHA, as they will stand the test of time.",
    "crumbs": [
      "Flujos de trabajo diarios",
      "<span class='chapter-number'>30</span>  <span class='chapter-title'>Time travel: See the past</span>"
    ]
  },
  {
    "objectID": "workflows-see-the-past.html#search",
    "href": "workflows-see-the-past.html#search",
    "title": "30  Time travel: See the past",
    "section": "30.4 Search",
    "text": "30.4 Search\nSearch is always available in the upper-righthand corner of GitHub.\n\n\n\nTyping into GitHub search bar.\n\n\nOnce you enter some text in the search box, a dropdown provides the choice to search in the current repo (the default) or all of GitHub. GitHub searches the contents of files (described as “Code”), commit messages, and issues. Take advantage of the search hits across these different domains. Again, this is a powerful way to zoom in on specific lines of code, revisit an interesting time in project history, or re-discover a conversation thread.\n\n30.4.1 Issue search\nIf you want to search issues specifically, the search box on any repo’s Issues page is prepopulated with the filters is:issue and is:open.",
    "crumbs": [
      "Flujos de trabajo diarios",
      "<span class='chapter-number'>30</span>  <span class='chapter-title'>Time travel: See the past</span>"
    ]
  },
  {
    "objectID": "workflows-fork-and-clone.html",
    "href": "workflows-fork-and-clone.html",
    "title": "31  Fork and clone",
    "section": "",
    "text": "31.1 Fork and clone without usethis\nI assume you’re already visiting the source repo in the browser. In the upper right hand corner, click Fork.\nThis creates a copy of REPO in your GitHub account and takes you there in the browser. Now we are looking at YOU/REPO.\nClone YOU/REPO, which is your copy of the repo, a.k.a. your fork, to your local machine. Make sure to clone your repo, not the source repo. Elsewhere, we describe multiple methods for cloning a remote repo. Pick one:\nMake a conscious decision about the local destination directory and HTTPS vs SSH URL.",
    "crumbs": [
      "Flujos de trabajo diarios",
      "<span class='chapter-number'>31</span>  <span class='chapter-title'>Fork and clone</span>"
    ]
  },
  {
    "objectID": "workflows-fork-and-clone.html#fork-and-clone-without-usethis",
    "href": "workflows-fork-and-clone.html#fork-and-clone-without-usethis",
    "title": "31  Fork and clone",
    "section": "",
    "text": "The cloning instructions in Existing project, GitHub first cover usethis and RStudio.\nThe cloning instructions in Connect to GitHub show how to do this with command line Git.\n\n\n\n31.1.1 Finish the fork and clone setup\nIf you stop at this point, you have what I regard as an incomplete setup, described elsewhere as “fork (salvageable)”.\n\n\n\n\nThis is sad, because there is no direct connection between your local copy of the repo and the source repo OWNER/REPO.\nThere are two more recommended pieces of setup:\n\nConfigure the source repo as the upstream remote\nConfigure your local main branch (or whatever the default is) to track upstream/main, not origin/main\n\n\nThe nickname upstream can technically be whatever you want. There is a strong tradition of using upstream in this context and, even though I have better ideas, I believe it is best to conform. Every book, blog post, and Stack Overflow thread that you read will use upstream here. Save your psychic energy for other things.\nThese steps make it easier for you to stay current with developments in the source repo. We talk more below about why you should never commit to the default branch, e.g. main, when you’re working in a fork (see Section 31.4).\n\n31.1.2 Configure the upstream remote\nThe first step is to get the URL of the source repo OWNER/REPO. Navigate to the source repo on GitHub. It is easy to get to from your fork, YOU/REPO, via the “forked from” link in the upper left.\nUse the big green “Code” button to get the URL for OWNER/REPO on your clipboard. Be intentional about whether you copy the HTTPS or SSH URL.\nYou can configure the upstream remote with command line Git, usethis, or RStudio.\nHere’s how to use command line Git in a shell:\ngit remote add upstream https://github.com/OWNER/REPO.git\nusethis::use_git_remote() allows you to configure a Git remote. Execute this in R:\n\nusethis::use_git_remote(\n  name = \"upstream\",\n  url = \"https://github.com/OWNER/REPO.git\"\n)\n\nFinally, you can do this in RStudio, although it feels a bit odd. Click on “New Branch” in the Git pane (“two purple boxes and a white square”).\n\n\n\n\nThis will reveal a button to “Add Remote”. Click it. Enter upstream as the remote name and paste the URL for OWNER/REPO that you got from GitHub. Click “Add”. Decline the opportunity to add a new branch by clicking “Cancel”.\nRegardless of how you configured upstream, do this in a shell:\ngit fetch upstream\n\n31.1.3 Set upstream tracking branch for the default branch\nThis is optional but highly recommended for most fork and clone situations. We’re going to set upstream/main from the source repo as the upstream tracking branch of local main. (If your default branch has a different name, substitute accordingly.)\nThis is desirable so that a simple git pull pulls from the source repo, not from your fork. It also means a simple git push will (attempt to) push to the source repo, which will almost always be rejected since you probably do not have permission. This failure will alert you to the fact that you’re doing something questionable, while it’s still easy to back out.\nFirst, fetch info for the upstream remote. This is especially important if you just configured upstream for the first time.\ngit fetch upstream\nThe two commands below do the same thing; the first is just shorthand for the second. Do this with command line Git in a shell:\ngit branch -u upstream/main\ngit branch --set-upstream-to upstream/main\nIf you found this fork and clone workflow long and tedious, consider using usethis::create_from_github() next time!",
    "crumbs": [
      "Flujos de trabajo diarios",
      "<span class='chapter-number'>31</span>  <span class='chapter-title'>Fork and clone</span>"
    ]
  },
  {
    "objectID": "workflows-fork-and-clone.html#sec-fork-and-clone-create-from-github",
    "href": "workflows-fork-and-clone.html#sec-fork-and-clone-create-from-github",
    "title": "31  Fork and clone",
    "section": "\n31.2 usethis::create_from_github(\"OWNER/REPO\", fork = TRUE)\n",
    "text": "31.2 usethis::create_from_github(\"OWNER/REPO\", fork = TRUE)\n\nThe usethis package has a convenience function, create_from_github(), that can do “fork and clone” (as well as just clone). The fork argument controls whether the source repo is cloned or fork-and-cloned. Note that create_from_github(fork = TRUE) requires that you have configured a GitHub personal access token.\nI assume you’re already visiting the source repo in the browser. Now click the big green button that says “&lt;&gt; Code”. Copy a clone URL to your clipboard. If you’re taking our default advice, copy the HTTPS URL. But if you’re opting for SSH, then make sure to copy the SSH URL.\nYou can execute this next command in any R session. If you use RStudio, then do this in the R console of any RStudio instance. In either case, after successful completion, you should find yourself in the new project that is the local repo connected to your fork.\n\nusethis::create_from_github(\n  \"https://github.com/OWNER/REPO\",\n  destdir = \"~/path/to/where/you/want/the/local/repo/\",\n  fork = TRUE\n)\n\nThe first argument is repo_spec and it accepts the GitHub repo specification in various forms. In particular, you can use the URL we just copied for the source repo.\nThe destdir argument specifies the parent directory where you want the new folder (and local Git repo) to live. If you don’t specify destdir, usethis defaults to some very conspicuous place, like your desktop. If you like to keep Git repos in a certain folder on your computer, you can personalize this default by setting the usethis.destdir option in your .Rprofile.\nThe fork argument specifies whether to clone (fork = FALSE) or fork and clone (fork = TRUE). You often don’t need to specify fork and can just enjoy the default behaviour, which is governed by your permissions on the source repo. By default, fork = FALSE if you can push to the source repo and fork = TRUE if you cannot.\nHere is what that might look like (note that we’re accepting the default behaviour for many arguments):\n\nusethis::create_from_github(\"https://github.com/OWNER/REPO\")\n#&gt; ℹ Defaulting to 'https' Git protocol\n#&gt; ✔ Setting `fork = TRUE`\n#&gt; ✔ Creating '/some/path/to/local/REPO/'\n#&gt; ✔ Forking 'OWNER/REPO'\n#&gt; ✔ Cloning repo from 'https://github.com/YOU/REPO.git' into '/some/path/to/local/REPO'\n#&gt; ✔ Setting active project to '/some/path/to/local/REPO'\n#&gt; ℹ Default branch is 'main'\n#&gt; ✔ Adding 'upstream' remote: 'https://github.com/OWNER/REPO.git'\n#&gt; ✔ Pulling changes from 'upstream/main'.\n#&gt; ✔ Setting remote tracking branch for local 'main' branch to 'upstream/main'\n#&gt; ✔ Setting active project to '&lt;no active project&gt;'\n\nFor an RStudio user, create_from_github(fork = TRUE) does all of this:\n\nForks the source repo on GitHub.\nClones your fork to a new local repo (and RStudio Project). This configures your fork as the origin remote.\nConfigures the source repo as the upstream remote.\nSets the upstream tracking branch for main (or whatever the default branch is) to upstream/main.\nOpens a new RStudio instance in the new local repo (and RStudio Project).",
    "crumbs": [
      "Flujos de trabajo diarios",
      "<span class='chapter-number'>31</span>  <span class='chapter-title'>Fork and clone</span>"
    ]
  },
  {
    "objectID": "workflows-fork-and-clone.html#engage-with-the-new-repo",
    "href": "workflows-fork-and-clone.html#engage-with-the-new-repo",
    "title": "31  Fork and clone",
    "section": "\n31.3 Engage with the new repo",
    "text": "31.3 Engage with the new repo\nIf you used usethis::create_from_github() or did fork and clone via Existing project, GitHub first, you are probably in an RStudio Project for this new repo.\nRegardless, get yourself into this project, whatever that means for you, using your usual method.\nExplore the new repo in some suitable way. If it is a package, you could run the tests or check it. If it is a data analysis project, run a script or render an Rmd. Convince yourself that you have gotten the code.\nYou should now be in the perfect position to sync up with ongoing developments in the source repo and to propose new changes via a pull request from your fork.\n{fig-align=“center” fig-alt = “Fork and clone, ideal setup.” width=“60%”}\nYou can use the commands below to review more of the nitty gritty Git details of your fork and clone setup:\n\nCommand line Git in a shell:\n\ngit remote -v\n\ngit remote show origin (or upstream)\ngit branch -vv\n\n\nIn R:\n\nusethis::git_remotes()\nusethis::git_sitrep()\n\n\n\nIn the shell, git remote -v should reveal that your remotes are configured like so:\norigin    https://github.com/YOU/REPO.git (fetch)\norigin    https://github.com/YOU/REPO.git (push)\nupstream  https://github.com/OWNER/REPO.git (fetch)\nupstream  https://github.com/OWNER/REPO.git (push)\nComparable info is available In R with usethis::git_remotes():\n\ngit_remotes()\n#&gt; $origin\n#&gt; [1] \"https://github.com/YOU/REPO.git\"\n#&gt; \n#&gt; $upstream\n#&gt; [1] \"https://github.com/OWNER/repo.git\"\n\nIn the shell, with the default branch checked out, git branch -vv should reveal that upstream/main is the upstream tracking branch:\n~/some/repo/ % git branch -vv                   \n* main 2739987 [upstream/main] Some commit message\nAll of this info about remotes and branches is also included in the rich information reported with usethis::git_sitrep().",
    "crumbs": [
      "Flujos de trabajo diarios",
      "<span class='chapter-number'>31</span>  <span class='chapter-title'>Fork and clone</span>"
    ]
  },
  {
    "objectID": "workflows-fork-and-clone.html#sec-fork-dont-touch-main",
    "href": "workflows-fork-and-clone.html#sec-fork-dont-touch-main",
    "title": "31  Fork and clone",
    "section": "\n31.4 Don’t mess with main\n",
    "text": "31.4 Don’t mess with main\n\nHere is some parting advice for how to work in a fork and clone and situation.\nIf you make any commits in your local repository, I strongly recommend that you work in a new branch, not main (or whatever the default branch is called).\nI strongly recommend that you do not make commits to main of a repo you have forked. If you commit to main in a repo you don’t own, it creates a divergence between that branch’s history in the source repo and in your repo. Nothing but pain will come from this. (If you’ve already done this, we discuss how to fix the situation in Um, what if I did touch main?.)\nWhen you treat main as read-only, it makes life much easier when you want to pull upstream work into your copy. The OWNER of REPO will also be happier to receive your pull request from a non-main branch.\nFor more detail, this Q&A on Stack Overflow is helpful: Why is it bad practice to commit to your fork’s master branch?.",
    "crumbs": [
      "Flujos de trabajo diarios",
      "<span class='chapter-number'>31</span>  <span class='chapter-title'>Fork and clone</span>"
    ]
  },
  {
    "objectID": "workflows-upstream-changes-into-fork.html",
    "href": "workflows-upstream-changes-into-fork.html",
    "title": "32  Get upstream changes for a fork",
    "section": "",
    "text": "32.1 Verify your local repo’s configuration\nVocabulary: OWNER/REPO refers to what we call the source repo, owned by OWNER, who is not you. YOU/REPO refers to your fork, i.e. your remote copy of the source repo, on GitHub. This is the same vocabulary used elsewhere, such as the chapter on common remote configurations.",
    "crumbs": [
      "Flujos de trabajo diarios",
      "<span class='chapter-number'>32</span>  <span class='chapter-title'>Get upstream changes for a fork</span>"
    ]
  },
  {
    "objectID": "workflows-upstream-changes-into-fork.html#verify-your-local-repos-configuration",
    "href": "workflows-upstream-changes-into-fork.html#verify-your-local-repos-configuration",
    "title": "32  Get upstream changes for a fork",
    "section": "",
    "text": "32.1.1 List your remotes\nLet’s inspect the current remotes for your local repo.\nYou can check this with command line Git in the shell (Appendix Appendix A):\ngit remote -v\nWe want to see something like this:\norigin    https://github.com/YOU/REPO.git (fetch)\norigin    https://github.com/YOU/REPO.git (push)\nupstream  https://github.com/OWNER/REPO.git (fetch)\nupstream  https://github.com/OWNER/REPO.git (push)\nComparable info is available in R with usethis::git_remotes():\n\ngit_remotes()\n#&gt; $origin\n#&gt; [1] \"https://github.com/YOU/REPO.git\"\n#&gt; \n#&gt; $upstream\n#&gt; [1] \"https://github.com/OWNER/repo.git\"\n\nIf you only have one remote, probably origin, I highly recommend you modify the remote configuration. But first, we’ll check one other thing.\n\n32.1.2 View the upstream tracking branch\nIdeally, your local main branch has upstream/main as its upstream tracking branch. Even you have a correctly configured upstream remote, this is worth checking. If your default branch has a branch other than main, substitute accordingly.\nIn the shell, with the default branch checked out, git branch -vv should reveal that upstream/main is the upstream tracking branch:\n~/some/repo/ % git branch -vv                   \n* main 2739987 [upstream/main] Some commit message\nIf, instead, you see origin/main, I highly recommend you reconfigure the tracking branch.\nAll of this info about remotes and branches is also included in the rich information reported with usethis::git_sitrep().\n\n32.1.3 Repair or complete your repo’s configuration\nInstructions for adding the upstream remote and setting upstream tracking for your default branch are given in Finish the fork and clone setup.",
    "crumbs": [
      "Flujos de trabajo diarios",
      "<span class='chapter-number'>32</span>  <span class='chapter-title'>Get upstream changes for a fork</span>"
    ]
  },
  {
    "objectID": "workflows-upstream-changes-into-fork.html#verify-that-your-working-tree-is-clean",
    "href": "workflows-upstream-changes-into-fork.html#verify-that-your-working-tree-is-clean",
    "title": "32  Get upstream changes for a fork",
    "section": "\n32.2 Verify that your “working tree is clean”",
    "text": "32.2 Verify that your “working tree is clean”\nWe assume your repo has this favorable configuration:\n\n\n\n\nMake sure you are on the default branch, e.g. main, and that your “working tree is clean”. First, let’s make sure our information on the upstream remote is current:\ngit fetch upstream\ngit status should now show something like:\nOn branch main\nYour branch is up to date with 'origin/main'.\n\nnothing to commit, working tree clean\nIf you have modified files, you should either discard those changes or create a new branch and commit the changes there for safekeeping.\nIt’s also fine if you see something like this:\nYour branch is behind 'upstream/main' by 2 commits, and can be fast-forwarded.\nHowever, if you see something like this:\nYour branch is ahead of 'upstream/main' by 1 commit.\nor this:\nYour branch and 'upstream/main' have diverged,\nand have 1 and 1 different commits each, respectively.\nthis is a sign that you have made some regrettable choices.\nI recommend that you never make your own commits to the default branch of a fork or to any branch that you don’t effectively (co-)own. However, if you have already done so, we explain how to fix the problem in Um, what if I did touch main?.",
    "crumbs": [
      "Flujos de trabajo diarios",
      "<span class='chapter-number'>32</span>  <span class='chapter-title'>Get upstream changes for a fork</span>"
    ]
  },
  {
    "objectID": "workflows-upstream-changes-into-fork.html#sync-option-1-pull-changes-from-upstream-then-push-to-origin",
    "href": "workflows-upstream-changes-into-fork.html#sync-option-1-pull-changes-from-upstream-then-push-to-origin",
    "title": "32  Get upstream changes for a fork",
    "section": "\n32.3 Sync option 1: Pull changes from upstream, then push to origin\n",
    "text": "32.3 Sync option 1: Pull changes from upstream, then push to origin\n\nNow we are ready to pull the changes that we don’t have from the source repo OWNER/REPO into our local copy.\ngit pull upstream main --ff-only\nThis says: “pull the changes from the remote known as upstream into the main branch of my local repo”. I am being explicit about the remote (upstream) and the branch (main) in this case, both to make it more clear and to make this command robust to repo- and user-level Git configurations. But if you’ve followed our setup recommendations, you don’t actually need to be this explicit.\nI also highly recommend using the --ff-only flag in this case, so that you also say “if I have made my own commits to main, please force me to confront this problem NOW”. Here’s what it looks like if a fast-forward merge isn’t possible:\n$ git pull upstream main --ff-only\nFrom github.com:OWNER/REPO\n * branch              main     -&gt; FETCH_HEAD\nfatal: Not possible to fast-forward, aborting.\nSee Um, what if I did touch main? to get yourself back on the happy path.\nAssuming you’ve succeeded with git pull, this next step is optional and many people who are facile with Git do not bother.\nIf you take my advice to never work in main of a fork, then the state of the main branch in your fork YOU/REPO does not technically matter. You will never make a pull request from main and there are ways to set the correct base for the branches and pull requests that you do create.\nIf, however, your grasp of all these Git concepts is tenuous at best, it can be helpful to try to keep things simple and orderly and synced up.\nFeel free to push the newly updated state of local main to your fork YOU/REPO and enjoy the satisfaction of being “caught up” with OWNER/REPO, in both your remote fork and in your local repo.\nIn the shell:\ngit push origin main\nIf you’ve followed our configuration advice, you really do need to be this explicit in order to push to origin (not upstream).",
    "crumbs": [
      "Flujos de trabajo diarios",
      "<span class='chapter-number'>32</span>  <span class='chapter-title'>Get upstream changes for a fork</span>"
    ]
  },
  {
    "objectID": "workflows-upstream-changes-into-fork.html#sync-option-2-sync-your-fork-on-github-pull-changes-from-origin-to-local-repo",
    "href": "workflows-upstream-changes-into-fork.html#sync-option-2-sync-your-fork-on-github-pull-changes-from-origin-to-local-repo",
    "title": "32  Get upstream changes for a fork",
    "section": "\n32.4 Sync option 2: Sync your fork on GitHub, pull changes from origin to local repo",
    "text": "32.4 Sync option 2: Sync your fork on GitHub, pull changes from origin to local repo\nFor many years, this was not possible, though many GitHub users wished for this feature. Happily it is now possible to sync a fork with its source repo in the browser, i.e. to do the sync between the 2 GitHub repos. The official GitHub documentation for this is Syncing a fork branch from the web UI.\nNavigate to the main page of your fork YOU/REPO, i.e. your primary repo which is configured as the origin remote.\nAt the top you’ll see some information on how the state of main in your fork relates to main in the source repo, similar to what we see with git status in the alternative approach above. Ideally you will see something like:\nThis branch is 2 commits behind OWNER:main.\nwhich indicates you can sync up in the ideal fast-forward sense.\nIf you see something like this:\nThis branch is 1 commit ahead, 2 commits behind OWNER:main.\nthis is a sign that you have made some regrettable choices.\nI recommend that you never make your own commits to the default branch of a fork or to any branch that you don’t effectively (co-)own. However, if you have already done so, we explain how to fix the problem in Um, what if I did touch main?.\nOnce you are ready to proceed, click “Sync fork” in the upper right corner. Upon success, the main page of YOU/REPO shows something like\n\nThis branch is up to date with OWNER/REPO:main.\n\nIf you have made commits on the default branch of your fork, which we strongly advise against, this can result in a merge commit (or even merge conflicts). If you are suffering due to commits you’ve made on main and it’s beyond the help we describe below, consider deleting your fork and local repo and making a fresh start with Fork and clone. Live and learn.\nOnce you have successfully synced the default branch of YOU/REPO with the default branch of OWNER/REPO, you probably want to do the same for your local repo. Since they are synced, you can pull from either upstream or origin.\nIn the shell, with the default branch checked out, execute one of these:\ngit pull upstream main --ff-only\ngit pull origin main --ff-only\nIf you’ve followed our configuration advice, you don’t actually need to specify the remote and branch, because this branch is configured to pull from upstream. For the same reasons as before, it’s a good idea to include the --ff-only flag. If you have made local commits to main, this will surface that problem, which is solved in the next section.",
    "crumbs": [
      "Flujos de trabajo diarios",
      "<span class='chapter-number'>32</span>  <span class='chapter-title'>Get upstream changes for a fork</span>"
    ]
  },
  {
    "objectID": "workflows-upstream-changes-into-fork.html#sec-touched-main",
    "href": "workflows-upstream-changes-into-fork.html#sec-touched-main",
    "title": "32  Get upstream changes for a fork",
    "section": "\n32.5 Um, what if I did touch main?",
    "text": "32.5 Um, what if I did touch main?\nI told you not to!\nBut OK here we are.\nLet’s imagine this is the state of main (or whatever the default branch is called) in the source repo OWNER/REPO:\n... -- A -- B -- C -- D -- E -- F\nand and this is the state of the main branch in your local copy:\n... -- A -- B -- C -- X -- Y -- Z\nThe two histories agree, up to commit or state C, then they diverge.\nIf you want to preserve the work in commits X, Y, and Z, create a new branch right now, with tip at Z, like so, but substituting your preferred branch name:\ngit checkout -b my-great-innovations\nThis safeguards your great innovations from commits X, Y, and Z. Now checkout main again:\ngit checkout main\nI now assume you have either preserved the work in X, Y, and Z (with a branch) or have decided to let it go.\nDo a hard reset of the main branch to C.\ngit reset --hard C\nYou will have to figure out how to convey C in Git-speak. Specify it relative to HEAD or provide the SHA. See future link about time travel for more support.\n\nThe history of your main branch is now compatible with its history in OWNER/REPO. The instructions above for pulling changes from upstream should now work. A fast-forward-only pull should succeed.\ngit pull upstream main --ff-only\nAnd now your local history for main should match that in the source repo:\n... -- A -- B -- C -- D -- E -- F\nIf you chose to create a branch with your work, you will also have that locally:\n... -- A -- B -- C -- D -- E -- F (main)\n                   \\\n                    -- X -- Y -- Z (my-great-innovations)\nIf you pushed your alternative history (with commits X, Y, and Z) to your fork YOU/REPO and you like keeping everything synced up, you will also need to force push main to the origin remote:\ngit push --force origin main\nWe really, really don’t like discussing force pushes in Happy Git, though. We only do so here, because we are talking about a fork, which is fairly easy to replace if things go sideways.",
    "crumbs": [
      "Flujos de trabajo diarios",
      "<span class='chapter-number'>32</span>  <span class='chapter-title'>Get upstream changes for a fork</span>"
    ]
  },
  {
    "objectID": "workflows-explore-extend-pull-request.html",
    "href": "workflows-explore-extend-pull-request.html",
    "title": "33  Explore and extend a pull request",
    "section": "",
    "text": "33.1 Update from the future\nThe lessons learned here eventually lead to the pr_*() family of functions in usethis. pr_fetch() and pr_push() are now my workhorses for exploring and extending PRs. You can read more about usethis’s functions to help with pull requests in their very own article: Pull request helpers.",
    "crumbs": [
      "Flujos de trabajo diarios",
      "<span class='chapter-number'>33</span>  <span class='chapter-title'>Explore and extend a pull request</span>"
    ]
  },
  {
    "objectID": "workflows-explore-extend-pull-request.html#terminology",
    "href": "workflows-explore-extend-pull-request.html#terminology",
    "title": "33  Explore and extend a pull request",
    "section": "\n33.2 Terminology",
    "text": "33.2 Terminology\nVocabulary I use throughout.\nfork branch The name of the branch in the fork from which the PR was made. Best case scenario: informative name like fix-fluffy-bunny. Worst case scenario: PR is from master.\nlocal PR branch The name of the local branch you’ll use to work with the PR. Best case scenario: can be same as fork branch. Worse case scenario: PR is from master, so you must make up a new name based on something about the PR, e.g. pr-666 or janedoe-master.\nPR parent The SHA of the commit in the main repo that is the base for the PR.\nPR remote The SSH or HTTPS URL for the fork from which the PR was made. Or the nickname of the remote, if you’ve bothered to set that up.",
    "crumbs": [
      "Flujos de trabajo diarios",
      "<span class='chapter-number'>33</span>  <span class='chapter-title'>Explore and extend a pull request</span>"
    ]
  },
  {
    "objectID": "workflows-explore-extend-pull-request.html#official-github-advice-version-1",
    "href": "workflows-explore-extend-pull-request.html#official-github-advice-version-1",
    "title": "33  Explore and extend a pull request",
    "section": "\n33.3 Official GitHub advice, Version 1",
    "text": "33.3 Official GitHub advice, Version 1\nEvery PR on GitHub has a link to “command line instructions” on how to merge the PR locally via command line Git. On this journey, there is a point at which you can pause and explore the PR locally.\nHere are their steps with my vocabulary and some example commands:\n\n\nCreate and check out the local PR branch, anticipating its relationship to the fork branch. Template of the Git command, plus an example of how it looks under both naming scenarios:\n# Template of the Git command\ngit checkout -b LOCAL_PR_BRANCH master \n# How it looks under both naming scenarios\ngit checkout -b fix-fluffy-bunny master \ngit checkout -b janedoe-master master \n\n\nPull from the fork branch of the PR remote:\n# Template of the Git command\ngit pull REMOTE FORK_PR_BRANCH\n# How it looks under both naming scenarios\ngit pull https://github.com/janedoe/yourpackage.git fix-fluffy-bunny\ngit pull https://github.com/janedoe/yourpackage.git master\n\nSatisfy yourself that all is well and you want to merge.\n\nCheckout master:\ngit checkout master\n\n\nMerge the local PR branch into master with --no-ff, meaning “no fast forward merge”. This ensures you get a true merge commit, with two parents.\n# Template of the Git command\ngit merge --no-ff LOCAL_PR_BRANCH\n# How it looks under both naming scenarios\ngit merge --no-ff fix-fluffy-bunny\ngit merge --no-ff janedoe-master\n\n\nPush master to GitHub.\ngit push origin master\n\n\nWhat’s not to like? The parent commit of the local PR branch will almost certainly not be the parent commit of the fork PR branch, where the external contributor did their work. This often means you get merge conflicts in git pull, which you’ll have to deal with ASAP. The older the PR, the more likely this is and the hairier the conflicts will be.\nI would prefer to deal with the merge conflicts only after I’ve vetted the PR and to resolve the conflicts locally, not on GitHub. So I don’t use this exact workflow.",
    "crumbs": [
      "Flujos de trabajo diarios",
      "<span class='chapter-number'>33</span>  <span class='chapter-title'>Explore and extend a pull request</span>"
    ]
  },
  {
    "objectID": "workflows-explore-extend-pull-request.html#official-github-advice-version-2",
    "href": "workflows-explore-extend-pull-request.html#official-github-advice-version-2",
    "title": "33  Explore and extend a pull request",
    "section": "\n33.4 Official GitHub advice, Version 2",
    "text": "33.4 Official GitHub advice, Version 2\nGitHub has another set of instructions: Checking out pull requests locally\nIt starts out by referring to the Version 1 instructions, but goes on to address an inactive pull request”, defined as a PR “whose owner has either stopped responding, or, more likely, has deleted their fork”.\nThis workflow may NOT give the original PR author credit (next time it’s easy to test this, I’ll update with a definitive answer). I’ve never used it verbatim because I’ve never had this exact problem re: deleted fork.",
    "crumbs": [
      "Flujos de trabajo diarios",
      "<span class='chapter-number'>33</span>  <span class='chapter-title'>Explore and extend a pull request</span>"
    ]
  },
  {
    "objectID": "workflows-explore-extend-pull-request.html#official-github-advice-version-3",
    "href": "workflows-explore-extend-pull-request.html#official-github-advice-version-3",
    "title": "33  Explore and extend a pull request",
    "section": "\n33.5 Official GitHub advice, Version 3",
    "text": "33.5 Official GitHub advice, Version 3\nGitHub has yet another set of instructions: Committing changes to a pull request branch created from a fork\nThe page linked above explains all the pre-conditions, but the short version is that a maintainer can probably push new commits to a PR, effectively pushing commits to a fork. Strange, but true!\nThis set of instructions suggests that you clone the fork, checkout the branch from which the PR was made, make any commits you wish, and then push. Any new commits you make will appear in the PR. And then you could merge.\nMy main takeaway: maintainer can push to the branch of a fork associated with a PR.",
    "crumbs": [
      "Flujos de trabajo diarios",
      "<span class='chapter-number'>33</span>  <span class='chapter-title'>Explore and extend a pull request</span>"
    ]
  },
  {
    "objectID": "workflows-explore-extend-pull-request.html#a-workflow-i-once-used",
    "href": "workflows-explore-extend-pull-request.html#a-workflow-i-once-used",
    "title": "33  Explore and extend a pull request",
    "section": "\n33.6 A workflow I once used",
    "text": "33.6 A workflow I once used\nThe lessons learned here eventually lead to the pr_*() family of functions in usethis. pr_fetch() and pr_push() are now my workhorses for exploring and extending PRs. You can read more about usethis’s functions to help with pull requests in their very own article: Pull request helpers.\nThis combines ideas from the three above approaches, but with a few tweaks. I am sketching this up in R code, with the hope of putting this into a function and package at some point. This is a revision of an earlier approach, based on feedback from Jim Hester.\nExample of a PR from the master branch (suboptimal but often happens) from fictional GitHub user abcde on usethis.\n\nlibrary(git2r)\n\n## add the pull requester's fork as a named remote\nremote_add(name = \"abcde\", url = \"git@github.com:abcde/usethis.git\")\n\n## fetch\nfetch(name = \"abcde\")\n\n## list remote branches and isolate the one I want\nb &lt;- branches(flags = \"remote\")\nb &lt;- b[[\"abcde/master\"]]\n\n## get the SHA of HEAD on this branch\nsha &lt;- branch_target(b)\n\n## create local branch\nbranch_create(commit = lookup(sha = sha), name = \"abcde-master\")\n\n## check it out\ncheckout(object = \".\", branch = \"abcde-master\")\n\n## set upstream tracking branch\nbranch_set_upstream(repository_head(), name = \"abcde/master\")\n\n## confirm upstream tracking branch\nbranch_get_upstream(repository_head())\n\n## make one or more commits here\n\n## push to the branch in the fork and, therefore, into the PR\npush()",
    "crumbs": [
      "Flujos de trabajo diarios",
      "<span class='chapter-number'>33</span>  <span class='chapter-title'>Explore and extend a pull request</span>"
    ]
  },
  {
    "objectID": "workflows-make-github-repo-browsable.html",
    "href": "workflows-make-github-repo-browsable.html",
    "title": "34  Make a GitHub repo browsable",
    "section": "",
    "text": "34.1 Be savvy about your files\nKeep files in the plainest, web-friendliest form that is compatible with your main goals. Plain text is the very best. GitHub offers special handling for certain types of files:",
    "crumbs": [
      "Flujos de trabajo diarios",
      "<span class='chapter-number'>34</span>  <span class='chapter-title'>Make a GitHub repo browsable</span>"
    ]
  },
  {
    "objectID": "workflows-make-github-repo-browsable.html#be-savvy-about-your-files",
    "href": "workflows-make-github-repo-browsable.html#be-savvy-about-your-files",
    "title": "34  Make a GitHub repo browsable",
    "section": "",
    "text": "Markdown files, which may be destined for conversion into, e.g., HTML\nMarkdown files named README.md\n\nHTML files, often the result of compiling Markdown files\nSource code, such as .R files\nDelimited files, such as CSVs and TSVs\nPNG files",
    "crumbs": [
      "Flujos de trabajo diarios",
      "<span class='chapter-number'>34</span>  <span class='chapter-title'>Make a GitHub repo browsable</span>"
    ]
  },
  {
    "objectID": "workflows-make-github-repo-browsable.html#get-over-your-hang-ups-re-committing-derived-products",
    "href": "workflows-make-github-repo-browsable.html#get-over-your-hang-ups-re-committing-derived-products",
    "title": "34  Make a GitHub repo browsable",
    "section": "\n34.2 Get over your hang ups re: committing derived products",
    "text": "34.2 Get over your hang ups re: committing derived products\nLet’s acknowledge the discomfort some people feel about putting derived products under version control. Specifically, if you’ve got an R Markdown document foo.Rmd, it can be knit() to produce the intermediate product foo.md, which can be converted to the ultimate output foo.html. Which of those files are you “allowed” to put under version control? Source-is-real hardliners will say only foo.Rmd but pragmatists know this can be a serious bummer in real life. Just because I can rebuild everything from scratch, it doesn’t mean I want to.\nThe taboo of keeping derived products under version control originates from compilation of binary executables from source. Software built on a Mac would not work on Windows and so it made sense to keep these binaries out of the holy source code repository. Also, you could assume the people with access to the repository have the full development stack and relish opportunities to use it. None of these arguments really apply to the foo.Rmd --&gt; foo.md --&gt; foo.html workflow. We don’t have to blindly follow traditions from the compilation domain!\nIn fact, looking at the diffs for foo.md or foo-figure-01.png can be extremely informative. This is also true in larger data analytic projects after a make clean; make all operation. By looking at the diffs in the downstream products, you often catch unexpected changes. This can tip you off to changes in the underlying data and/or the behavior of packages you depend on.\nThis chapter explores cool things GitHub can do with various file types, if they happen to end up in your repo. I won’t ask you how they got there.",
    "crumbs": [
      "Flujos de trabajo diarios",
      "<span class='chapter-number'>34</span>  <span class='chapter-title'>Make a GitHub repo browsable</span>"
    ]
  },
  {
    "objectID": "workflows-make-github-repo-browsable.html#markdown",
    "href": "workflows-make-github-repo-browsable.html#markdown",
    "title": "34  Make a GitHub repo browsable",
    "section": "\n34.3 Markdown",
    "text": "34.3 Markdown\nYou will quickly discover that GitHub renders Markdown files very nicely. By clicking on foo.md, you’ll get a decent preview of foo.html. Yay! You should read GitHub’s own guide on how to leverage automatic Markdown rendering.\nExploit this aggressively. Make Markdown your default format for narrative text files and use them liberally to embed notes to yourself and others in a repository hosted on Github. It’s an easy way to get pseudo-webpages inside a project “for free”. You may never even compile these files to HTML explicitly; in many cases, the HTML preview offered by GitHub is all you ever need.",
    "crumbs": [
      "Flujos de trabajo diarios",
      "<span class='chapter-number'>34</span>  <span class='chapter-title'>Make a GitHub repo browsable</span>"
    ]
  },
  {
    "objectID": "workflows-make-github-repo-browsable.html#r-markdown",
    "href": "workflows-make-github-repo-browsable.html#r-markdown",
    "title": "34  Make a GitHub repo browsable",
    "section": "\n34.4 R Markdown",
    "text": "34.4 R Markdown\nWhat does this mean for R Markdown files? Keep intermediate Markdown. Or only render to Markdown. Commit both foo.Rmd and foo.md, even if you choose to .gitignore the final product, e.g. foo.html or foo.pdf or foo.docx. From September 2014, GitHub renders R Markdown files nicely, like Markdown, and with proper syntax highlighting, which is great. But, of course, the code blocks just sit there un-executed, so my advice about keeping Markdown still holds.\nIf your target output format is not Markdown, you want YAML frontmatter that looks something like this for .Rmd:\n---\ntitle: \"Something fascinating\"\nauthor: \"Jenny Bryan\"\ndate: \"`r format(Sys.Date())`\"\noutput:\n  html_document:\n    keep_md: TRUE\n---\nor like this for .R:\n#' ---\n#' title: \"Something fascinating\"\n#' author: \"Jenny Bryan\"\n#' date: \"`r format(Sys.Date())`\"\n#' output:\n#'   html_document:\n#'     keep_md: TRUE\n#' ---\nThe keep_md: TRUE part says to keep the intermediate Markdown. In RStudio, when editing .Rmd, click on the gear next to “Knit HTML” for YAML authoring help.\nSince 2016, rmarkdown offers a custom output format for GitHub-flavored markdown, github_document. Read about R Markdown workflows for explicit examples of how to use this. If Markdown is your target output format, your YAML can be even simpler and look like this for .Rmd:\n---\noutput: github_document\n---\nor like this for .R:\n#' ---\n#' output: github_document\n#' ---\nFor a quick, stand-alone document that doesn’t fit neatly into a repository or project (yet), make it a Gist. Example: Hadley Wickham’s advice on what you need to do to become a data scientist. Gists can contain multiple files, so you can still provide the R script or R Markdown source and the resulting Markdown, as I’ve done in this write-up of Twitter-sourced tips for cross-tabulation. I’ve collected YAML examples for all the above scenarios in a gist.",
    "crumbs": [
      "Flujos de trabajo diarios",
      "<span class='chapter-number'>34</span>  <span class='chapter-title'>Make a GitHub repo browsable</span>"
    ]
  },
  {
    "objectID": "workflows-make-github-repo-browsable.html#readme.md",
    "href": "workflows-make-github-repo-browsable.html#readme.md",
    "title": "34  Make a GitHub repo browsable",
    "section": "\n34.5 README.md\n",
    "text": "34.5 README.md\n\nYou probably already know that GitHub renders README.md at the top-level of your repo as the de facto landing page. This is analogous to what happens when you point a web browser at a directory instead of a specific web page: if there is a file named index.html, that’s what the server will show you by default. On GitHub, files named README.md play exactly this role for directories in your repo.\nImplication: for any logical group of files or mini project-within-your-project, create a sub-directory in your repository. And then create a README.md file to annotate these files, collect relevant links, etc. Now when you navigate to the sub-directory on GitHub the nicely rendered README.md will simply appear. The GitHub repo that backs the gapminder data package has a README in the data-raw subdirectory that explains exactly how the package data is created. In fact, it is generated programmatically from README.Rmd.\nSome repositories consist solely of README.md. Examples: Jeff Leek’s write-ups on How to share data with a statistician or Developing R packages. I am becoming a bigger fan of README-only repos than gists because repo issues trigger notifications, whereas comments on gists do not.\nIf you’ve got a directory full of web-friendly figures, such as PNGs, you can use code like this to generate a README.md for a quick DIY gallery, as Karl Broman has done with his FruitSnacks. I did same for all the fantastic O RLY book covers made by The Practical Dev.\nI have also used this device to share Keynote slides on GitHub (mea culpa!). Export them as PNGs images and throw ’em into a README gallery: slides on file organization and some on file naming.",
    "crumbs": [
      "Flujos de trabajo diarios",
      "<span class='chapter-number'>34</span>  <span class='chapter-title'>Make a GitHub repo browsable</span>"
    ]
  },
  {
    "objectID": "workflows-make-github-repo-browsable.html#finding-stuff",
    "href": "workflows-make-github-repo-browsable.html#finding-stuff",
    "title": "34  Make a GitHub repo browsable",
    "section": "\n34.6 Finding stuff",
    "text": "34.6 Finding stuff\nOK these are pure GitHub tips but if you’ve made it this far, you’re obviously a keener.\n\nPress t to activate the file finder whenever you’re in a repo’s file and directory view. AWESOME, especially when there are files tucked into lots of subdirectories.\nPress y to get a permanent link when you’re viewing a specific file. Watch what changes in the URL. This is important if you are about to link to a file or to specific lines. Otherwise your links will break easily in the future. If the file is deleted or renamed or if lines get inserted or deleted, your links will no longer point to what you intended. Use y to get links that include a specific commit in the URL.",
    "crumbs": [
      "Flujos de trabajo diarios",
      "<span class='chapter-number'>34</span>  <span class='chapter-title'>Make a GitHub repo browsable</span>"
    ]
  },
  {
    "objectID": "workflows-make-github-repo-browsable.html#html",
    "href": "workflows-make-github-repo-browsable.html#html",
    "title": "34  Make a GitHub repo browsable",
    "section": "\n34.7 HTML",
    "text": "34.7 HTML\nIf you have an HTML file in a GitHub repository, simply visiting the file shows the raw HTML. Here’s a nice ugly example:\n\nhttps://github.com/STAT545-UBC/STAT545-UBC.github.io/blob/master/bit003_api-key-env-var.html\n\nNo one wants to look at that. You can provide this URL to rawgit.com to serve this HTML more properly and get a decent preview.\nYou can form two different types of URLs with rawgit.com:\n\n\nFor sharing low-traffic, temporary examples or demos with small numbers of people, do this:\n\nhttps://rawgit.com/STAT545-UBC/STAT545-UBC.github.io/master/bit003_api-key-env-var.html\nBasically: replace https://github.com/ with https://rawgit.com/\n\n\n\nFor use on production websites with any amount of traffic, do this:\n\nhttps://cdn.rawgit.com/STAT545-UBC/STAT545-UBC.github.io/master/bit003_api-key-env-var.html\nBasically: replace https://github.com/ with https://cdn.rawgit.com/\n\n\n\n2018-10-09 update: RawGit announced that it is in a sunset phase and will soon shut down. They recommended: jsDelivr, GitHub Pages, CodeSandbox, and unpkg as alternatives.\nThis sort of enhanced link might be one of the useful things to put in a README.md or other Markdown file in the repo.\nYou may also want to check out this Chrome extension or GitHub & BitBucket HTML Preview, though recently I’ve more success with rawgit.com. (Neither work with private GitHub repos, which is all the more reason to keep intermediate markdown files for HTML, as described above.)\nSometimes including HTML files will cause GitHub to think that your R repository is HTML. Besides being slightly annoying, this can make it difficult for people to find your work if they are searching specifically for R repos. You can exclude these files or directories from GitHub’s language statistics by adding a .gitattributes file that marks them as ‘documentation’ rather than code. See an example here.",
    "crumbs": [
      "Flujos de trabajo diarios",
      "<span class='chapter-number'>34</span>  <span class='chapter-title'>Make a GitHub repo browsable</span>"
    ]
  },
  {
    "objectID": "workflows-make-github-repo-browsable.html#source-code",
    "href": "workflows-make-github-repo-browsable.html#source-code",
    "title": "34  Make a GitHub repo browsable",
    "section": "\n34.8 Source code",
    "text": "34.8 Source code\nYou will notice that GitHub does automatic syntax highlighting for source code. For example, notice the coloring of this R script. The file’s extension is the primary determinant for if/how syntax highlighting will be applied. You can see information on recognized languages, the default extensions and more at github/linguist. You should be doing it anyway, but let this be another reason to follow convention in your use of file extensions.\nNote you can click on “Raw” in this context as well, to get just the plain text and nothing but the plain text.",
    "crumbs": [
      "Flujos de trabajo diarios",
      "<span class='chapter-number'>34</span>  <span class='chapter-title'>Make a GitHub repo browsable</span>"
    ]
  },
  {
    "objectID": "workflows-make-github-repo-browsable.html#delimited-files",
    "href": "workflows-make-github-repo-browsable.html#delimited-files",
    "title": "34  Make a GitHub repo browsable",
    "section": "\n34.9 Delimited files",
    "text": "34.9 Delimited files\nGitHub will nicely render tabular data in the form of .csv (comma-separated) and .tsv (tab-separated) files. You can read more in the blog post announcing this feature in August 2013 or in this GitHub help page.\nAdvice: take advantage of this! If something in your repo can be naturally stored as delimited data, by all means, do so. Make the comma or tab your default delimiter and use the file suffixes GitHub is expecting. I have noticed that GitHub is more easily confused than R about things like quoting, so always inspect the GitHub-rendered .csv or .tsv file in the browser. You may need to do light cleaning to get the automagic rendering to work properly. Think of it as yet another way to learn about imperfections in your data.\nHere’s an example of a tab delimited file on GitHub: lotr_clean.tsv, originally found here (nope, IBM shut down manyeyes July 2015).\nNote you can click on “Raw” in this context as well, to get just the plain text and nothing but the plain text.",
    "crumbs": [
      "Flujos de trabajo diarios",
      "<span class='chapter-number'>34</span>  <span class='chapter-title'>Make a GitHub repo browsable</span>"
    ]
  },
  {
    "objectID": "workflows-make-github-repo-browsable.html#pngs",
    "href": "workflows-make-github-repo-browsable.html#pngs",
    "title": "34  Make a GitHub repo browsable",
    "section": "\n34.10 PNGs",
    "text": "34.10 PNGs\nPNG is the “no brainer” format in which to store figures for the web. But many of us like a vector-based format, such as PDF, for general purpose figures. Bottom line: PNGs will drive you less crazy than PDFs on GitHub. To reduce the aggravation around viewing figures in the browser, make sure to have a PNG version in the repo.\nExamples:\n\n\nThis PNG figure just shows up in the browser\nA different figure stored as PDF produces the dreaded, annoying “View Raw” speed bump. You’ll have to click through and, on my OS + browser, wait for the PDF to appear in an external PDF viewer. 2015-06-19 update: since I first wrote this GitHub has elevated its treament of PDFs so YAY. It’s slow but it works.\n\n\nHopefully we are moving towards a world where you can have “web friendly” and “vector” at the same time, without undue headaches. As of October 2014, GitHub provides enhanced viewing and diffing of SVGs. So don’t read this advice as discouraging SVGs. Make them! But consider keeping a PNG around as emergency back up for now.",
    "crumbs": [
      "Flujos de trabajo diarios",
      "<span class='chapter-number'>34</span>  <span class='chapter-title'>Make a GitHub repo browsable</span>"
    ]
  },
  {
    "objectID": "workflows-make-github-repo-browsable.html#other-document-formats",
    "href": "workflows-make-github-repo-browsable.html#other-document-formats",
    "title": "34  Make a GitHub repo browsable",
    "section": "\n34.11 Other document formats",
    "text": "34.11 Other document formats\nYou may also have a document you want others to be able to browse and interact with, but it is not in the markdown format. Fortunately, the open-source Pandoc program, written by John MacFarlane, allows you to convert a range of formats into markdown, including the widely used .docx format.\nWhen you click the Knit button in RStudio it is actually Pandoc which performs the final conversion to HTML or Microsoft Word (.docx) formats. If you are willing to use the command-line, you can perform the opposite conversion (eg .docx to .md), commonly retaining features such as headings, tables, equations and even figures.\nAs some boilerplate, running in Windows PowerShell pandoc --extract-media .\\media  -f docx .\\example.docx -t markdown_github -o example_image.md converts a word document called example.docx to markdown, and extracts the images into a directory which corresponds to a filepath in the newly created example.md document. A full list of supported formats and example code for conversions are available at https://pandoc.org/.\nYou can also perform simple conversions to GitHub-flavored markdown from different markdown flavours (Pandoc supports markdown_mmd, markdown_php_extra and markdown_strict) from within RStudio. To do so you need to rename the file by changing the extension (eg from foo.md to foo.Rmd), then open the renamed file in RStudio and add the following text to the top of the document.\n---\noutput: github_document\n---\nYou can then click on “Knit” then “Knit to github document” to perform the conversion. See Output format for more details of controlling output formats with the YAML frontmatter.",
    "crumbs": [
      "Flujos de trabajo diarios",
      "<span class='chapter-number'>34</span>  <span class='chapter-title'>Make a GitHub repo browsable</span>"
    ]
  },
  {
    "objectID": "workflows-make-github-repo-browsable.html#linking-to-a-zip-archive-of-your-repo",
    "href": "workflows-make-github-repo-browsable.html#linking-to-a-zip-archive-of-your-repo",
    "title": "34  Make a GitHub repo browsable",
    "section": "\n34.12 Linking to a ZIP archive of your repo",
    "text": "34.12 Linking to a ZIP archive of your repo\nThe browsability of GitHub makes your work accessible to people who care about your content but who don’t (yet) use Git themselves. What if such a person wants all the files? Yes, there is a clickable “Download ZIP” button offered by GitHub. But what if you want a link to include in an email or other document? If you add /archive/master.zip to the end of the URL for your repo, you construct a link that will download a ZIP archive of your repository. Click here to try this out on a very small repo:\nhttps://github.com/jennybc/lotr/archive/master.zip\nGo look in your downloads folder!",
    "crumbs": [
      "Flujos de trabajo diarios",
      "<span class='chapter-number'>34</span>  <span class='chapter-title'>Make a GitHub repo browsable</span>"
    ]
  },
  {
    "objectID": "workflows-make-github-repo-browsable.html#links-and-embedded-figures",
    "href": "workflows-make-github-repo-browsable.html#links-and-embedded-figures",
    "title": "34  Make a GitHub repo browsable",
    "section": "\n34.13 Links and embedded figures",
    "text": "34.13 Links and embedded figures\n\nTo link to another page in your repo, just use a relative link: [admin](courseAdmin/) will link to the courseAdmin/ directory inside the current directory. [admin](/courseAdmin/) will link to the top-level courseAdmin/ directory from any where in the repo\nThe same idea also works for images. ![](image.png) will include image.png located in the current directory",
    "crumbs": [
      "Flujos de trabajo diarios",
      "<span class='chapter-number'>34</span>  <span class='chapter-title'>Make a GitHub repo browsable</span>"
    ]
  },
  {
    "objectID": "workflows-make-github-repo-browsable.html#let-people-correct-you-on-the-internet",
    "href": "workflows-make-github-repo-browsable.html#let-people-correct-you-on-the-internet",
    "title": "34  Make a GitHub repo browsable",
    "section": "\n34.14 Let people correct you on the internet",
    "text": "34.14 Let people correct you on the internet\nThey love that!\nYou can create a link that takes people directly to an editing interface in the browser. Behind the scenes, assuming the click-er is signed into GitHub but is not you, this will create a fork in their account and send you a pull request. When I click the link below, I am able to actually commit directly to master for this repo.\nCLICK HERE to suggest an edit to this page!\nHere’s what that link looks like in the Markdown source:\n[CLICK HERE to suggest an edit to this page!](https://github.com/jennybc/happy-git-with-r/edit/master/workflows-make-github-repo-browsable.Rmd)\nand here it is with placeholders:\n[INVITATION TO EDIT](&lt;URL to your repo&gt;/edit/master/&lt;path to target source file&gt;)\nAFAIK, to do that in a slick automatic way across an entire repo/site, you need to be using Jekyll or some other automated system. But you could easily handcode such links on a small scale.",
    "crumbs": [
      "Flujos de trabajo diarios",
      "<span class='chapter-number'>34</span>  <span class='chapter-title'>Make a GitHub repo browsable</span>"
    ]
  },
  {
    "objectID": "prompt-clone.html",
    "href": "prompt-clone.html",
    "title": "35  Clone a repo",
    "section": "",
    "text": "Clone someone else’s repository on GitHub where you just want a copy. But you also want to track its evolution. That is what differentiates a GitHub clone from, say, simply downloading the ZIP archive at a specific point in time.\nPick a GitHub repository that interests you. Inspiration:\n\nan R package you care about\na data analytic project you find interesting\n\nExample: The GitHub repo that underpins Polygraphing’s blog post analyzing 2,000 screenplays is here: https://github.com/brandles/scripts\nExample: FiveThirtyEight shared the data and code behind their Gun Deaths in America project on GitHub: https://github.com/fivethirtyeight/guns-data. Have a look around their other repos as well.\n\n\nCreate a new RStudio Project from this GitHub repo. Refresh your memory of how to do that by re-visiting our “GitHub first” workflow in Chapter 15.\nOnce you have the code locally, try to run some of it. Try to understand how it works.\nDo you want to make a change? Fine do that!\nDo you want to send changes back to the original author? Now you have firsthand knowledge of when you should fork instead of clone. See Chapter 31.",
    "crumbs": [
      "Indicaciones de actividad",
      "<span class='chapter-number'>35</span>  <span class='chapter-title'>Clone a repo</span>"
    ]
  },
  {
    "objectID": "prompt-fork-pr-bingo.html",
    "href": "prompt-fork-pr-bingo.html",
    "title": "36  Create a bingo card",
    "section": "",
    "text": "Here’s a specific suggestion for practicing “fork and pull”.\nThe general workflow is laid out in Chapter 31.\nJenny and Dean have a repository that makes bingo cards with R:\n\nhttps://github.com/jennybc/bingo\nRead the README to learn more about it!\n\nYour mission:\n\nMaybe find a partner? Or a couple of partners?\nFork the bingo repo.\nClone it to someone’s local machine.\nCreate a new bingo card by making a file of possible squares.\n\nFollow the instructions in https://github.com/jennybc/bingo/blob/master/CONTRIBUTING.md to see how to contribute a new card.\nProtip: It’s easy to be very funny, but create a very difficult bingo card. Remember to include some easy stuff so people have a chance to bingo.\n\nIf you’re feeling virtuous, run the tests and check the package. Ask us for help! Or live dangerously and skip this.\nCommit!\nPush your changes back to your copy of the repo on GitHub.\nMake a pull request back to the main bingo repo.\nIf your card is appropriate, we’ll merge your request and it will become part of the package and available via the Shiny app.\n\nSpecial inspiration for useR:\n\nMake useR-specific conference bingo.\nSee this issue thread for lots of square ideas!\n\nhttps://github.com/jennybc/bingo/issues/4",
    "crumbs": [
      "Indicaciones de actividad",
      "<span class='chapter-number'>36</span>  <span class='chapter-title'>Create a bingo card</span>"
    ]
  },
  {
    "objectID": "prompt-burn-it-all-down.html",
    "href": "prompt-burn-it-all-down.html",
    "title": "37  Burn it all down",
    "section": "",
    "text": "This is a highly inelegant, but effective technique for disaster recovery.\nIt has been immortalized in an xkcd comic, so it must be ok:\n\nhttps://xkcd.com/1597/\nhttp://explainxkcd.com/wiki/index.php/1597:_Git\n\nBasic idea:\n\nCommit early and often.\nPush to a remote, like GitHub, often.\nThe state of things on GitHub is your new “worst case scenario”.\nIf you really screw things up locally, copy all the files (or the ones that have changed) to a safe place.\n\nUsually your files are JUST FINE. But it is easy to goof up the Git infrastructure when you’re new at this. And it can be hard to get that straightened out on your own.\n\nRename the existing local repo as a temporary measure, i.e. before you do something radical, like delete it.\nClone the repo from GitHub to your local machine. You are back to a happy state.\nCopy all relevant files back over from your safe space. The ones whose updated state you need to commit.\nStage and commit. Push.\nCarry on with your life.\n\nPractice this before you need it, so you see how it works.",
    "crumbs": [
      "Indicaciones de actividad",
      "<span class='chapter-number'>37</span>  <span class='chapter-title'>Burn it all down</span>"
    ]
  },
  {
    "objectID": "prompt-practice-resets.html",
    "href": "prompt-practice-resets.html",
    "title": "38  Resetting",
    "section": "",
    "text": "Practice recovering from mistakes.\nUse a repository you’ve created earlier in the tutorial for this. It only needs to be local, i.e. this does not involve GitHub.\nIf it’s not your most recent commit, seriously consider just letting that go. Just. Let. It. Go.\nSo you want to undo the last commit?\nIf “YES UNDO IT COMPLETELY”: git reset --hard HEAD^. You will lose any changes that were not reflected in the commit-before-last!\nIf “YES undo the commit, but leave the files in that state (but unstaged)”: git reset HEAD^. Your files will stay the same but the commit will be undone and nothing will be staged.\nIf “YES go right back to the moment before I committed”: git reset --soft HEAD^. Your files will stay the same but the commit will be undone. Even your staged changes will be restored.\nIf you just want to fiddle with the most recent commit or its message, you can amend it. You can do this from RStudio!\n\nMake the change you want and amend the commit.\nDo you only want to change the commit message?\n\nMake another small change. Surely you have a typo somewhere? Amend the commit, which gives you the chance to edit the message\n\n\nTo amend from the command line, using an editor to create the message:\ngit commit --amend\nTo amend from the command line, providing the new message:\ngit commit --amend -m \"New commit message\"\nGit Reset Demystified:\nhttps://git-scm.com/book/en/v2/Git-Tools-Reset-Demystified",
    "crumbs": [
      "Indicaciones de actividad",
      "<span class='chapter-number'>38</span>  <span class='chapter-title'>Resetting</span>"
    ]
  },
  {
    "objectID": "prompt-search-github.html",
    "href": "prompt-search-github.html",
    "title": "39  Search GitHub",
    "section": "",
    "text": "39.1 Basic resources\nGitHub searching\nRead-only mirror of R source by Winston Chang:\nRead-only mirror of all packages on CRAN by Gábor Csárdi:",
    "crumbs": [
      "Indicaciones de actividad",
      "<span class='chapter-number'>39</span>  <span class='chapter-title'>Search GitHub</span>"
    ]
  },
  {
    "objectID": "prompt-search-github.html#basic-resources",
    "href": "prompt-search-github.html#basic-resources",
    "title": "39  Search GitHub",
    "section": "",
    "text": "https://github.com/search/advanced\nhttps://help.github.com/articles/searching-code/\nhttps://help.github.com/articles/search-syntax/\n\n\n\nhttps://github.com/wch/r-source\n\n\n\nhttps://github.com/cran\nhttp://cran.github.io\nMETACRAN",
    "crumbs": [
      "Indicaciones de actividad",
      "<span class='chapter-number'>39</span>  <span class='chapter-title'>Search GitHub</span>"
    ]
  },
  {
    "objectID": "prompt-search-github.html#use-case",
    "href": "prompt-search-github.html#use-case",
    "title": "39  Search GitHub",
    "section": "39.2 Use case",
    "text": "39.2 Use case\nWhat if a function in a package has no examples? Or is poorly exampled? Wouldn’t it be nice to find functioning instances of it “in the wild”?\nVia Twitter, Noam Ross taught me a clever way to do such searches on GitHub. Put this into the GitHub search box to see how packages on CRAN use the llply() function from plyr:\n\"llply\" user:cran language:R\nOr just click here.\nAnother example that recently came up on r-package-devel:\nHow to see lots of examples of roxygen templates?\nThis search finds &gt;1400 examples of roxygen templates in the wild:\nhttps://github.com/search?q=man-roxygen+in%3Apath&type=Code&ref=searchresults",
    "crumbs": [
      "Indicaciones de actividad",
      "<span class='chapter-number'>39</span>  <span class='chapter-title'>Search GitHub</span>"
    ]
  },
  {
    "objectID": "notes-intro.html",
    "href": "notes-intro.html",
    "title": "Notes",
    "section": "",
    "text": "This part holds content that is deprecated/stale, does not exist yet, or relates to bookdown mechanics.",
    "crumbs": [
      "Notas",
      "Notes"
    ]
  },
  {
    "objectID": "notes-classroom-overview.html",
    "href": "notes-classroom-overview.html",
    "title": "40  Run a course with GitHub",
    "section": "",
    "text": "40.1 Benefits\nFor the instructor\nFor the students",
    "crumbs": [
      "Notas",
      "<span class='chapter-number'>40</span>  <span class='chapter-title'>Run a course with GitHub</span>"
    ]
  },
  {
    "objectID": "notes-classroom-overview.html#benefits",
    "href": "notes-classroom-overview.html#benefits",
    "title": "40  Run a course with GitHub",
    "section": "",
    "text": "If you already use Git/GitHub, it’s extremely efficient to use the same workflows to manage course materials, student work, and communication with students and TAs.\n\nWhen I switched to Git/GitHub and R Markdown, abandoning my old “system” of accepting all manner of stuff as email attachments? It was the first time I actually ran the code in my students’ final projects, because it was so easy to get it on my computer in an organized fashion. I even made some corrections as pull requests!\n\nIf you’re still in your early days with Git/GitHub, the sheer volume of operations and regular small deadlines will increase your mastery very quickly. Practice makes perfect! However, I would not recommend running a course on GitHub as your first substantial version control project.\n\n\n\nI have found that students adjust to Git/GitHub fairly quickly and genuinely like it. They find it gratifying to see their beautiful, figure-rich R Markdown reports up on the internet. Since it’s easy to expose their work within the class, we do a lot of peer review. I find that expertise spreads around the class like a virus. That applies to the main course substance as well as workflow.\nMany students are specifically interested in learning Git and GitHub, as a complement to the coding and analytical skills we teach in these courses. The fact that we use it for course mechanics kills two birds with one stone. Teaching the use of distributed version control is a valid pedagogical goal in and of itself.",
    "crumbs": [
      "Notas",
      "<span class='chapter-number'>40</span>  <span class='chapter-title'>Run a course with GitHub</span>"
    ]
  },
  {
    "objectID": "notes-classroom-overview.html#the-stat-545-student-setup",
    "href": "notes-classroom-overview.html#the-stat-545-student-setup",
    "title": "40  Run a course with GitHub",
    "section": "40.2 The STAT 545 student setup",
    "text": "40.2 The STAT 545 student setup\nGitHub’s Organizations/Teams and API have changed over the 3+ years we’ve been doing this, so my approach has evolved over time and is also shaped by hard experience.\nMajor points:\n\nCreate an Organization for the course.\n\nImmediately request an Education discount for the Organization, so that you get unlimited private repos.\n\nHave your students register for free, personal GitHub accounts.\n\nEncourage them to request an Education discount on their own behalf (aka “student developer pack”). But rest assured, nothing you need for your course machinery will depend on this.\n\nGet the GitHub usernames from your students – we use a Shiny app! – plus some shred of information that allows you link them back to your official course list.\nCreate a students Team and a TA Team. I make such teams for each run of the course, e.g. 2016_students and 2016_ta.\nInvite students to join your course organization and the students team. Ditto for TAs and the TA team.\nCreate a canonical name for each student, based on the official course list, i.e. lastname_firstname.\nCreate a repository for each student, using the student’s canonical name.\n\nThis is a private repository within the course Organization.\nI turn wikis off and either let GitHub auto-initialize or immediately push files, including a README, into the repos.\nGive the student team read or pull access to each student’s repo. Yes, this allows them to see each others work. I discuss this elsewhere.\nGive the TA team write or push access to each student’s repo.\nAdd the student as collaborator with write or push access.\nUnwatch these repos personally! Wow such notification.\n\n\nThat’s the setup! I use the gh and purrr packages to script all of this GitHub API work. In a second wave, I’ll post code snippets for the above operations.\nWhat you should NOT do (voice of experience, here):\nDo NOT allow students to create their own repositories.\n\nYou will have a naming convention and they will never, ever, ever follow it.\nYou need to have admin rights over their course repo, so you can manipulate it at will via the GitHub API. You will ask them to add you and the TAs as collaborators, but they will not all manage to execute this task.\nYou will want to do various bulk operations on the repos and your API work will be simpler if the repos belong to the same Organization vs looping over randomly named repos owned by random people, subject to their whims.",
    "crumbs": [
      "Notas",
      "<span class='chapter-number'>40</span>  <span class='chapter-title'>Run a course with GitHub</span>"
    ]
  },
  {
    "objectID": "notes-classroom-overview.html#the-homework-flow",
    "href": "notes-classroom-overview.html#the-homework-flow",
    "title": "40  Run a course with GitHub",
    "section": "40.3 The homework-flow",
    "text": "40.3 The homework-flow\nIn class, the students take possession of their repos, from RStudio via File &gt; New Project. They do the bulk of their coursework here: it is a directory on their computer, a Git repo associated with GitHub remote, and an RStudio project.\nTypically homework is done in R Markdown, using the github_document output format. They commit and push .Rmd, .md, and any necessary files, such a figures.\nHomework is submitted by opening an issue:\n\nIssue name is “Mark homework x of lastname_firstname”. OK not really, but I can dream.\nBody should contain SHA of their latest commit, tag(s) for the marking TA or the TA team, and, ideally, links to the file(s) to be marked.\n\nTAs leave feedback here. Actual marks are stored elsewhere and distributed via email. As the TAs mark, they close the issues.\nAfter homework submission, we randomly assign each student to review the work of two peers. Each peer review assignment takes the form of an issue, assigned to the reviewer. Students leave feedback for each other here. As the TAs mark, they read and assess these peer reviews (also marked!) and close the issues.",
    "crumbs": [
      "Notas",
      "<span class='chapter-number'>40</span>  <span class='chapter-title'>Run a course with GitHub</span>"
    ]
  },
  {
    "objectID": "notes-classroom-overview.html#github-as-course-management-system",
    "href": "notes-classroom-overview.html#github-as-course-management-system",
    "title": "40  Run a course with GitHub",
    "section": "40.4 GitHub as course management system",
    "text": "40.4 GitHub as course management system\n2017-05-29 This section was excised from an article I am writing. It is partially redundant with the above and the the two will be merged.\nSTAT 545 is a data wrangling and analysis course at the University of British Columbia. I was the instructor in charge for several years, which coincided with my own adoption of Git/GitHub. GitHub is used to manage the development of course material, to serve the course website, to create a discussion forum, and to host all student-submitted work.\nGiven that students must submit their work and provide peer review of others’ work via GitHub, the use of hosted version control is an explicit, though modest, part of the course. The website Happy Git and GitHub for the useR holds our battle-tested instructions for setup and early usage. The students achieve basic competence quite quickly and find it gratifying to see their formatted, figure-rich R Markdown reports up on the internet. Since it’s easy to expose their work within the class, we conduct peer review, which helps expertise to spread quickly through the group.\n\n40.4.1 Use a GitHub Organization\nGitHub Organizations are “shared accounts where groups of people can collaborate across many projects at once”. This is the most appropriate structure for stewarding course resources, since I can grant TAs and students different levels of access to various repositories. Access can be controlled at the individual user level or, more conveniently, for entire Teams. The TA Team shares write access with me on a private repository for internal matters. I provide each student with their own private repository for coursework and grant other members of the Students Team read access, in order to facilitate peer review. There is a public repository that underpins the course website (see below). We have one other public repository that exists solely so the Issues can be used as a discussion forum.\nGitHub actively encourages the use of its platform in teaching. As an instructor you can request a free Organization account that provides features normally available only on paid plans, such as private repositories. In fact, GitHub provides tooling for specific teaching workflows via GitHub Classroom, although I do not use it. That is not an intentional knock on their tools. I started teaching with GitHub several years before this existed and developed a different way of using the platform. I also find the GitHub Education resources to be geared more towards computer science than data science.\n\n\n40.4.2 GitHub Pages for course website\nAll course content is provided on the STAT 545 website. Each page is generated from an R Markdown document that is rendered to HTML locally using the rmarkdown package, retaining the intermediate Markdown. These pages are a mix of prose and rendered R code, reflecting the live coding done in class. All of these files and their history can be explored in the source repository. The TA team has permission to write to this repo, meaning they can (and do!) help me maintain the website. I rejoice that I am no longer the webmaster. We also get typo corrections and other input from the world at large, since this is entirely public.\nIf I were starting from scratch today, I would continue to use R Markdown, RStudio, and GitHub Pages (see below), but would upgrade to a more modern, automated approach to rendering the pages. I now recommend R Markdown websites, bookdown, or blogdown to manage the process of creating a static website from a large and inter-related set of .Rmd files.\nGitHub offers several ways to host a website directly from a repository, collectively known as GitHub Pages. The STAT 545 website is a very simple Organization Page that uses a custom domain, stat545.com, instead of the default orgname.github.io.\nThis system for managing course content is a great example of integrating the doing of work and the sharing of it. We analyze data live in class, using R, based on the scripts on the website. I re-render the associated .R or .Rmd, commit the changed files, push, and see it reflected right away on http://stat545.com. There is no separation between having an idea, implementing it, and posting on the website.\n\n\n40.4.3 Student-specific private repos\nEarly in the course I elicit GitHub usernames for registered students, via a Shiny app, and invite them to join the course Organization. I then create one private repository per student, in the STAT 545 Organization. The targeted student has write access and the other students have read access. This is somewhat controversial, due to the possibility of cheating, but I have seen more pros than cons for this setup, in the STAT 545 context. In other settings, I have also used one repo per student per homework assignment, which allows you to keep the repos completely private until homework submission, then increase their visibility during marking and peer review. Some courses will work better with one model or the other.\nEach student does their work in this repo, submitting a major assignment approximately once a week. The first assignment is simply to claim the repository and create a README, which proves they have all the relevant software setup and they can write a little Markdown. Each week we tackle some new data analysis or wrangling task, with increasing latitude for independence. Homework is implemented in R Markdown documents, rendered to Markdown, and pushed to GitHub. Students submit their work by opening an issue in their repo, naming the assignment in the title, providing the SHA of the associated final commit, and linking to the main .md file. We leave feedback as comments in the issue thread or, occasionally, propose changes to code via “pull requests”. Two peers are selected at random to review each assignment, a process that we also implement via GitHub Issues.\nAt the end of term, the student (and their instructor!) can visit the repo to find an organized, navigable sequence of ~10 assignments. Each student leaves with self-written documentation of everything they’ve done, ready to consult in future projects. The last assignments require writing an R package or Shiny app, which they generally do in public repositories under their own accounts. They finish STAT 545 with several months of Git/GitHub experience and the start of a data science portfolio.",
    "crumbs": [
      "Notas",
      "<span class='chapter-number'>40</span>  <span class='chapter-title'>Run a course with GitHub</span>"
    ]
  },
  {
    "objectID": "notes-ideas.html",
    "href": "notes-ideas.html",
    "title": "41  Ideas for content",
    "section": "",
    "text": "41.1 Common workflow questions",
    "crumbs": [
      "Notas",
      "<span class='chapter-number'>41</span>  <span class='chapter-title'>Ideas for content</span>"
    ]
  },
  {
    "objectID": "notes-ideas.html#common-workflow-questions",
    "href": "notes-ideas.html#common-workflow-questions",
    "title": "41  Ideas for content",
    "section": "",
    "text": "41.1.1 Common predicaments and how to recover/avoid\nhttps://twitter.com/JennyBryan/status/743457387730735104\n\n\n41.1.2 Keep something out of Git\nList it in .gitignore.\n\n\n41.1.3 I didn’t mean to commit that\nCommitting things you didn’t mean to (too big, secret). How to undo.",
    "crumbs": [
      "Notas",
      "<span class='chapter-number'>41</span>  <span class='chapter-title'>Ideas for content</span>"
    ]
  },
  {
    "objectID": "notes-ideas.html#git-stuff",
    "href": "notes-ideas.html#git-stuff",
    "title": "41  Ideas for content",
    "section": "41.2 git stuff",
    "text": "41.2 git stuff\nGit explainers, heavy on the diagrams\nhttps://twitter.com/JennyBryan/status/743548245645791232\nA Visual Git Reference\nhttp://marklodato.github.io/visual-git-guide/index-en.html\nA successful Git branching model\nhttp://nvie.com/posts/a-successful-git-branching-model/\nA successful Git branching model considered harmful\nhttps://barro.github.io/2016/02/a-succesful-git-branching-model-considered-harmful/\nGit Tutorials from Atlassian https://www.atlassian.com/git/tutorials/\nSoftware Carpentry Git Novice Lesson\nhttp://swcarpentry.github.io/git-novice/\nMichael Freeman slides on Git collaboration\nhttp://slides.com/michaelfreeman/git-collaboration#/\nGitHub Training materials\nhttps://services.github.com/kit/\nGit for Ages 4 and Up\nhttps://www.youtube.com/watch?v=3m7BgIvC-uQ\nLearn Git Branching\nhttp://learngitbranching.js.org\nA Git Workflow Walkthrough Series http://vallandingham.me/git-workflow.html\n\nPart 1: Feature Branches\nPart 2: Reviewing Pull Requests\nPart 3: Reviewing Pull Requests Locally\nPart 4: Merging Pull Requests\n\nGit from the inside out\nhttps://codewords.recurse.com/issues/two/git-from-the-inside-out",
    "crumbs": [
      "Notas",
      "<span class='chapter-number'>41</span>  <span class='chapter-title'>Ideas for content</span>"
    ]
  },
  {
    "objectID": "notes-ideas.html#disaster-recovery",
    "href": "notes-ideas.html#disaster-recovery",
    "title": "41  Ideas for content",
    "section": "41.3 Disaster recovery",
    "text": "41.3 Disaster recovery\nhttp://stackoverflow.com/questions?sort=votes\nBreak it down:\n\nIs something wrong with my filesystem/files?\nIs my git repo messed up?\nHow can I keep this from happening again?\n\nRebase avoidance techniques.\nHeadless state. Rebase hell.\nWhat to do when you can’t, e.g., switch branches. Stashing and WIP commits.",
    "crumbs": [
      "Notas",
      "<span class='chapter-number'>41</span>  <span class='chapter-title'>Ideas for content</span>"
    ]
  },
  {
    "objectID": "notes-ideas.html#engage-with-r-source-on-github",
    "href": "notes-ideas.html#engage-with-r-source-on-github",
    "title": "41  Ideas for content",
    "section": "41.4 Engage with R source on GitHub",
    "text": "41.4 Engage with R source on GitHub\nBrowsing\nSearching\n\nMy gist, re: the cran user: https://gist.github.com/jennybc/4a1bf4e9e1bb3a0a9b56\n\nBeing a useful useR\n\nstay informed re: development\nuse issues for bug reports, feature requests\nmake pull requests",
    "crumbs": [
      "Notas",
      "<span class='chapter-number'>41</span>  <span class='chapter-title'>Ideas for content</span>"
    ]
  },
  {
    "objectID": "notes-ideas.html#workflow-and-psychology",
    "href": "notes-ideas.html#workflow-and-psychology",
    "title": "41  Ideas for content",
    "section": "41.5 Workflow and psychology",
    "text": "41.5 Workflow and psychology\nStress of working in the open\nWorkflows for group of 1, 2, 5, 10\n\nFork and Pull vs Shared Repository\n\nhttps://help.github.com/articles/about-collaborative-development-models/\nhttps://help.github.com/articles/using-pull-requests/",
    "crumbs": [
      "Notas",
      "<span class='chapter-number'>41</span>  <span class='chapter-title'>Ideas for content</span>"
    ]
  },
  {
    "objectID": "shell.html",
    "href": "shell.html",
    "title": "Appendix A — The shell",
    "section": "",
    "text": "A.1 What is the shell?\nThe shell is a program on your computer whose job is to run other programs. Pseudo-synonyms are “terminal”, “command line”, and “console”. There’s a whole StackExchange thread on the differences (What is the difference between Terminal, Console, Shell, and Command Line?), but I don’t find it to be terribly enlightening. Your mileage may vary.\nMany programmers spend lots of time in a shell, as opposed to in GUIs, because it is very fast, concise, and ubiquitous in their relevant computing environments. This is how all work was done before we got the mouse and GUIs.\nThe most common shell is bash and it gets thrown around as a proxy for “shell” sometimes, just like “Coke” and “Kleenex” are proxies for cola and tissues.\nIn Happy Git, sometimes we demo the use of a shell for certain tasks, like navigating the file system and doing Git operations, when we don’t want to or can’t use RStudio. Providing shell commands is also less ambiguous and less perishable than describing human interactions with a GUI.",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>A</span>  <span class='chapter-title'>The shell</span>"
    ]
  },
  {
    "objectID": "shell.html#starting-the-shell",
    "href": "shell.html#starting-the-shell",
    "title": "Appendix A — The shell",
    "section": "A.2 Starting the shell",
    "text": "A.2 Starting the shell\n\nA.2.1 From within RStudio\nYou can launch a shell from RStudio. This is often handy, because RStudio makes every effort to put you in a sane working directory, i.e. in the current project.\nThere are two ways:\n\nTools &gt; Terminal launches a shell within RStudio, graphically and process-wise. I believe this is usually what you want.\nTools &gt; Shell … launches a shell external to RStudio.\n\n\n\nA.2.2 Outside of RStudio\n\nA.2.2.1 macOS\nThe shell is often called the “terminal” on macOS, by which people mean Terminal.app. One way to launch is via Spotlight Search. Type Command + space and start typing “terminal”. This process will something like so:\n\nTerminal.app is typically located at /Applications/Utilities/Terminal.app.\nOpening Terminal.app brings you to a bash shell opened to your home directory ~/, which is shorthand for /Users/YOURUSERNAME. You should see something like this:\n\nIf you have administrative rights on your computer, prefacing any command with sudo will allow you to run the command as an administrator. Expect to be challenged for your password. If you need to change administrative privileges or your password, see this article from Apple.\n\n\nA.2.2.2 Windows\nWe defer this until the next section, due to the more complex shell situation on Windows.",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>A</span>  <span class='chapter-title'>The shell</span>"
    ]
  },
  {
    "objectID": "shell.html#sec-windows-shell-hell",
    "href": "shell.html#sec-windows-shell-hell",
    "title": "Appendix A — The shell",
    "section": "A.3 Windows is special … and not in a good way",
    "text": "A.3 Windows is special … and not in a good way\nWindows is not the ideal platform for scientific computing and software development. A lot of the functionality is going to feel janky and strapped on. Because it is.\nThere are no fewer than 4 possible shells you can end up in. Unless you know better, you almost certainly want to be in a Git Bash shell, especially here in Happy Git.\nWindows users will want to understand the different types of shell, how to launch them, and how to tell which one you’re in.\n\nA.3.1 Git Bash\nTL;DR how to tell if you’re in a Git Bash shell? Do this:\n$ echo $SHELL\n/usr/bin/bash\nGit Bash is a bash shell that ships with Git for Windows, which is the Happy Git way to install Git on Windows. Therefore, you will not have Git Bash on your system until you install Git for Windows.\nGit Bash is always the Windows shell we are targeting in Happy Git instructions.\nRStudio should automatically detect the presence of Git Bash. You can inspect and influence this directly via Tools &gt; Global Options &gt; Terminal. Unless you have good reason to do otherwise, you want to see “Git Bash” in the “New terminals open with …” dropdown menu.\n\nTroubleshooting tips:\n\nRestart RStudio. You need to restart all instances of RStudio after installing Git for Windows (+ Git Bash), in order for RStudio to auto-detect Git Bash.\nUpdate RStudio. The shell handling in RStudio has improved dramatically over time, so older versions might not behave as described here.\n\n\nA.3.1.1 Accessing Git Bash outside of RStudio\nSometimes you want to run Git Bash outside of RStudio. Here’s the easiest way: click the “Git” menu in the Windows menu and select “Git Bash”.\n\nA Git Bash shell running outside of RStudio looks something like this:\n\nNotice MSYS in the title bar. You might also see MINGW64.\nSometimes you need to run Git Bash as administrator, e.g. to run with higher privileges. Easiest way: click the “Git” menu in the Windows menu and right-click on “Git Bash”. This reveals a submenu. Select “more” and then “Run as administrator”.\n\n\n\n\nA.3.2 Command prompt\nTL;DR how to tell if you’re in Command Prompt? Do this:\nC:\\Users\\jenny&gt;echo %COMSPEC%\nC:\\WINDOWS\\system32\\cmd.exe\nThis is the native Windows command line interpreter. It’s rarely what you want, especially for the work described in Happy Git.\nA Command Prompt session running outside of RStudio looks something like this:\n\nNotice the cmd.exe in the title bar, although it is not always present. You might also see “Command Prompt”.\nIf you get an error message such as 'pwd' is not recognized as an internal or external command, operable program or batch file. from a shell command, that suggests you have somehow launched into cmd.exe when you did not mean to.\n\n\nA.3.3 PowerShell\nTL;DR how to tell if you’re in PowerShell? Do this:\nPS C:\\Users\\jenny&gt; Get-ChildItem Env:ComSpec\n\nName                           Value\n----                           -----\nComSpec                        C:\\WINDOWS\\system32\\cmd.exe\nPowerShell is yet another Windows shell, a more modern successor to Command Prompt. It’s also rarely what you want, especially for the work described in Happy Git.\nA PowerShell session running outside of RStudio looks something like this:\n\nNotice the powershell.exe in the title bar.\n\n\nA.3.4 Bash via Windows Services for Linux\nTL;DR how to tell if you’re in Bash via WSL? Do this:\n$ echo $SHELL\n/bin/bash\nIn 2016, Microsoft launched the Windows Subsystem for Linux (WSL), “a new Windows 10 feature that enables you to run native Linux command-line tools directly on Windows”. Overall, this is a fantastic development. However, at the time of writing (January 2019), you will only have this if you’re running Windows 10 64-bit and have chosen to install the optional WSL system component. Therefore, I expect only keeners to have this and, in that case, you probably don’t need this chapter.\nA WSL bash shell running outside of RStudio looks something like this:\n\nFYI Microsoft also refers to WSL as Bash on Ubuntu on Windows.\n\nA.3.4.1 Windows bottom line\nWhen in doubt, you probably want to be in a Git Bash shell.",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>A</span>  <span class='chapter-title'>The shell</span>"
    ]
  },
  {
    "objectID": "shell.html#basic-shell-commands",
    "href": "shell.html#basic-shell-commands",
    "title": "Appendix A — The shell",
    "section": "A.4 Basic shell commands",
    "text": "A.4 Basic shell commands\nThe most basic commands are listed below:\n\npwd (print working directory). Shows directory or “folder” you are currently operating in. This is not necessarily the same as the R working directory you get from getwd().\nls (list files). Shows the files in the current working directory. This is equivalent to looking at the files in your Finder/Explorer/File Manager. Use ls -a to also list hidden files, such as .Rhistory and .git.\ncd (change directory). Allows you to navigate through your directories by changing the shell’s working directory. You can navigate like so:\n\ngo to subdirectory foo of current working directory: cd foo\ngo to parent of current working directory: cd ..\ngo to your “home” directory: cd ~ or simply cd\ngo to directory using absolute path, works regardless of your current working directory: cd /home/my_username/Desktop. Windows uses a slightly different syntax with the slashes between the folder names reversed, \\, e.g. cd C:\\Users\\MY_USERNAME\\Desktop.\n\nPro tip 1: Dragging and dropping a file or folder into the terminal window will paste the absolute path into the window.\nPro tip 2: Use the tab key to autocomplete unambiguous directory and file names. Hit tab twice to see all ambiguous options.\n\n\nUse arrow-up and arrow-down to repeat previous commands. Or search for previous commands with CTRL + r.\n\nA few Git commands:\n\ngit status is the most used git command and informs you of your current branch, any changes or untracked files, and whether you are in sync with your remotes.\ngit remote -v lists all remotes. Very useful for making sure git knows about your remote and that the remote address is correct.\ngit remote add origin GITHUB_URL adds the remote GITHUB_URL with nickname origin.\ngit remote set-url origin GITHUB_URL changes the remote url of origin to GITHUB_URL. This way you can fix typos in the remote url.\nFeel free to suggest other commands that deserve listing in a GitHub issue.",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>A</span>  <span class='chapter-title'>The shell</span>"
    ]
  },
  {
    "objectID": "comic-relief.html",
    "href": "comic-relief.html",
    "title": "Appendix B — Comic relief",
    "section": "",
    "text": "It’s not you, it’s Git!\nIf you’re not crying already, these fictional-but-realistic Git man pages should do the trick:\n\ngit-man-page-generator\nAnd, of course, the underlying source is also available on GitHub:\n\nhttps://github.com/Lokaltog/git-man-page-generator\n\n\nIf you can tolerate adult and often offensive language, you might enjoy:\n\nhttp://www.commitlogsfromlastnight.com\nhttp://ohshitgit.com/\n\nYour commits will look more glorious scrolling by Star Wars style:\n\nhttp://starlogs.net\nhttp://starlogs.net/#jennybc/googlesheets\nDo this for any repo: http://starlogs.net/#USER/REPO",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>B</span>  <span class='chapter-title'>Comic relief</span>"
    ]
  },
  {
    "objectID": "resources.html",
    "href": "resources.html",
    "title": "Appendix C — Resources",
    "section": "",
    "text": "We practice what we preach! This site is created with Git and R markdown, using the bookdown package. Go ahead and peek behind the scenes.\nLong-term, you should understand more about what you are doing. Rote clicking in RStudio may be a short-term survival method but won’t work for long.\n\nGit for Humans is a great set of slides by Alice Bartlett, originally delivered in 2016 at UX Brighton.\nGit in Practice by Mike McQuaid is an more approachable book, probably better than Pro Git (below) for most people starting out. Ancillary materials on GitHub.\nThe book Pro Git is fantastic and comprehensive.\nOh My Git! is a free and open source interactive game for learning Git. It’s very beginner friendly, using a graph to visualise the worktree. Lessons can be completed using a playing card interface in addition to the built-in command line, which is there for when users become more comfortable.\nGitHub’s own training materials may be helpful. They also point to many other resources\nFind a powerful Git client (Chapter 8) if you’d like to minimize your usage of Git from the command line.\nTen Simple Rules for Taking Advantage of Git and GitHub http://journals.plos.org/ploscompbiol/article?id=10.1371/journal.pcbi.1004947\nRStudio’s guide Version Control with Git and SVN\nThe book Team Geek has insightful advice for the human and collaborative aspects of version control. It proposes Git strategies suited to different characteristics of teams.",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>C</span>  <span class='chapter-title'>Resources</span>"
    ]
  },
  {
    "objectID": "references.html",
    "href": "references.html",
    "title": "Appendix D — References",
    "section": "",
    "text": "Bartlett, Alice. 2016. “Git for Humans.” Financial Times,\nLondon; Talk at UX Brighton. https://speakerdeck.com/alicebartlett/git-for-humans.\n\n\nPerez-Riverol, Yasset, Laurent Gatto, Rui Wang, Timo Sachsenberg, Julian\nUszkoreit, Felipe da Veiga Leprevost, Christian Fufezan, et al. 2016.\n“Ten Simple Rules for Taking Advantage of Git and GitHub.”\nPLOS Computational Biology 12 (7): 1–11. https://doi.org/10.1371/journal.pcbi.1004947.\n\n\nRam, Karthik. 2013. “Git Can Facilitate Greater Reproducibility\nand Increased Transparency in Science.” Source Code for\nBiology and Medicine 8 (1): 7. https://doi.org/10.1186/1751-0473-8-7.\n\n\nWickham, Hadley. 2015. R Packages. 1st ed. O’Reilly Media, Inc.",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>D</span>  <span class='chapter-title'>References</span>"
    ]
  }
]